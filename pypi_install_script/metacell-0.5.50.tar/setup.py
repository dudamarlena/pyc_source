from glob import glob
from setuptools import Extension
from setuptools import find_packages
from setuptools import setup
from textwrap import dedent

import distutils.cmd
import distutils.log
import os
import re
import subprocess

extension = Extension('metacell.extension',
                      extra_compile_args=['--std=c++14', '-I.'],  # , '-D_GLIBCXX_DEBUG' ],
                      sources=['metacell/extension/optimize_graph_colors.cpp',
                               'metacell/extension/bindings.cpp',
                               'metacell/extension/prune_graph.cpp',
                               'metacell/extension/choose_seeds.cpp',
                               'metacell/extension/optimize_partitions.cpp',
                               'metacell/extension/sparse.cpp'])


def readme():
    sphinx = re.compile(':py:[a-z]+:(`[^`]+`)')
    with open('README.rst') as readme_file:
        return sphinx.sub('`\\1`', readme_file.read())


def version_from_git():
    subprocess.check_call(['tools/install_git_hooks'])

    # PEP440 forbids placing the commit hash in the version number.
    # Counting the commits since the tag must therefore suffice to identify the commit.
    command = ['git', 'describe', '--tags']
    results = subprocess.check_output(command).decode('utf8').strip().split('-')

    version = results[0]
    if len(results) > 1:
        version += '.' + results[1]

    command = ['git', 'status', '--porcelain']
    local_modifications = subprocess.check_output(command).strip()
    # Obey PEP440 so just add a `.dev0` suffix if this is not committed yet.
    if local_modifications:
        version += '.dev0'

    with open('metacell/version.py', 'w') as file:
        file.write("'''Version is generated by setup.py.'''\n\n")
        file.write("__version__ = '%s'\n" % version)

    return version


def version_from_file():
    if not os.path.exists('metacell/version.py'):
        raise RuntimeError('Failed to generate metacell/version.py')

    with open('metacell/version.py', 'r') as file:
        regex = re.compile("__version__ = '(.*)'")
        for line in file.readlines():
            match = regex.search(line)
            if match:
                return match.group(1)

    raise RuntimeError('Failed to parse metacell/version.py')


def generate_version():
    if os.path.exists('.git'):
        return version_from_git()
    return version_from_file()


class SimpleCommand(distutils.cmd.Command):
    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        subprocess.check_call(self.command)


class AllCommand(SimpleCommand):
    description = 'run all needed steps before commit'

    def run(self):
        self.run_command('no_unknown_files')
        self.run_command('no_todo' + 'x')
        self.run_command('is_formatted')
        self.run_command('pylint')
        self.run_command('mypy')
        self.run_command('check')
        self.run_command('build')
        self.run_command('nose')
        self.run_command('html')


class CleanCommand(SimpleCommand):
    description = 'remove all generated files and directories'
    command = ['tools/clean']


class HtmlCommand(SimpleCommand):
    description = 'run sphinx to generate HTML documentation'
    command = ['tools/generate_documentation']


class IsformattedCommand(SimpleCommand):
    description = 'use autopep8 and isort to check the formatting of all Python source files'
    command = ['tools/is_formatted']


class MypyCommand(SimpleCommand):
    description = 'run MyPy on all Python source files'
    command = ['mypy',
               '--warn-redundant-casts',
               '--disallow-untyped-defs',
               '--warn-unused-ignores',
               '--scripts-are-modules',
               *glob('metacell/**/*.py', recursive=True),
               *glob('tests/**/*.py', recursive=True)]

    def run(self):
        import tgutils.setup_mypy
        super().run()


def remove_fake_modules():
    os.remove('pandas.py')
    os.remove('numpy.py')


class NoseCommand(SimpleCommand):
    description = 'run nosetests and generate coverage reports'
    command = ['nosetests',
               '--with-coverage',
               '--cover-package=metacell',
               '--cover-branches',
               '--cover-html']

    def run(self):
        if os.path.exists('.coverage'):
            os.remove('.coverage')
        super().run()


class NoTodo_xCommand(SimpleCommand):
    description = 'ensure there are no leftover TODO' + 'X in the source files'
    command = ['tools/no_todo_x']


class PylintCommand(SimpleCommand):
    description = 'run Pylint on all Python source files'
    command = ['pylint',
               '--init-import=yes',
               '--ignore-imports=yes',
               '--ignore-comments=yes',
               '--ignore-docstrings=yes',
               '--disable=' + ','.join([
                   'bad-continuation',
                   'bad-whitespace',
                   'c-extension-no-member',
                   'duplicate-code',
                   'fixme',
                   'global-statement',
                   'line-too-long',
                   'no-member',
                   'too-few-public-methods',
                   'ungrouped-imports',
                   'wrong-import-order',
                   'too-many-arguments',
                   'too-many-locals',
                   'assignment-from-no-return',
                   'too-many-function-args',
                   'unsubscriptable-object',
               ]),
               'metacell', 'tests', *glob('bin/*')]


class ReformatCommand(SimpleCommand):
    description = 'use autopep8 and isort to fix the formatting of all Python source files'
    command = ['tools/reformat']


class NoUnknownFilesCommand(SimpleCommand):
    description = 'ensure there are no source files git is not aware of'
    command = ['tools/no_unknown_files']


INSTALL_REQUIRES = ['dynamake', 'tgutils',
                    'feather-format', 'h5py',
                    'numpy', 'pandas', 'scipy',
                    'plotly', 'dash', 'dash-core-components', 'dash-html-components',
                    'dash-table', 'flask']
TESTS_REQUIRE = ['nose', 'testfixtures', 'coverage']
DEVELOP_REQUIRES = ['autopep8', 'isort', 'mypy', 'pylint', 'sphinx', 'sphinx_rtd_theme']


setup(name='metacell',
      version=generate_version(),
      description='Single-cell RNA Sequencing Analysis',
      long_description=readme(),
      long_description_content_type='text/x-rst',
      classifiers=[
          'Development Status :: 3 - Alpha',
          'License :: OSI Approved :: MIT License',
          'Programming Language :: Python :: 3.6',
          'Programming Language :: Python :: 3.7',
          'Topic :: Software Development :: Libraries',
          'Topic :: Scientific/Engineering :: Bio-Informatics',
          'Intended Audience :: Developers',
          'Intended Audience :: Science/Research',
      ],
      keywords='logging configuration',
      url='https://github.com/orenbenkiki/metacell.py.git',
      author='Oren Ben-Kiki',
      author_email='oren@ben-kiki.org',
      license='MIT',
      packages=find_packages(exclude=['tests']),
      package_data={'metacell': ['py.typed'],
                    'metacell.bin': ['py.typed'],
                    'metacell.dash': ['py.typed'],
                    'metacell.storage': ['py.typed'],
                    'metacell.dynamake': ['py.typed']},
      entry_points={'console_scripts': [
          'metacell_call=metacell.bin.metacell_call:main',
          'metacell_dash=metacell.dash.main:main',
          'metacell_import=metacell.bin.metacell_import:main',
          'metacell_group=metacell.bin.metacell_group:main',
          'metacell_zone=metacell.bin.metacell_zone:main',
      ]},
      ext_modules=[extension],
      install_requires=INSTALL_REQUIRES,
      tests_require=TESTS_REQUIRE,
      test_suite='nose.collector',
      extras_require={  # TODO: Is this the proper way of expressing these dependencies?
          'develop': INSTALL_REQUIRES + TESTS_REQUIRE + DEVELOP_REQUIRES
      },
      cmdclass={
          # TODO: Add coverage command (if it is possible to get it to work).
          'all': AllCommand,
          'clean': CleanCommand,
          'html': HtmlCommand,
          'is_formatted': IsformattedCommand,
          'mypy': MypyCommand,
          'nose': NoseCommand,
          'pylint': PylintCommand,
          'reformat': ReformatCommand,
          'no_todo' + 'x': NoTodo_xCommand,
          'no_unknown_files': NoUnknownFilesCommand,
      })

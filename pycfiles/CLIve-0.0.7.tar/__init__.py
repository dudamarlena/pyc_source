# uncompyle6 version 3.6.7
# Python bytecode 2.4 (62061)
# Decompiled from: Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: build/bdist.macosx-10.3-i386/egg/cliutils/__init__.py
# Compiled at: 2008-10-04 00:17:48
__doc__ = '\nA collection of utilities easing the creation of command line scripts.\n\ncliutils is pure Python with no dependencies.\n\nThe package provides several features that may aid the simple CLI\nutility-writer. Process objects give a simple way to get output from shell\ncommands; the C{persistence} module provides easy access to .ini-style\nconfiguration files\n\nProcess objects\n===============\n    Although it isn\'t very difficult to execute shell commands from a Python\n    script, there are several lines of overhead in the standard pattern.\n    Process objects reduce the entire pattern to a single line. In addition,\n    they are more flexible; they may be piped into each other, just as regular\n    processes may be on the bash command line.\n\n        >>> Process("echo \'spam and eggs\'")\n        spam and eggs\n        >>> s = Process("echo \'spam and eggs\'").stdout\n        >>> s\n        \'spam and eggs\'\n        >>> p = Process("echo \'spam and eggs\'") | Process("wc -w")\n        >>> p.stdout\n        \'3\'\n\n    For convenience, a singleton object (L{sh}) is provided that is able to\n    create process objects from given attributes.\n\n        >>> sh.echo("spam and eggs") | sh.wc("-w") | sh.cat()\n        3\n\n    Arguments passed to Process objects are split using the C{shlex} module, so\n    most simple strings will work just fine. More complex arguments should be\n    passed in as lists:\n\n        >>> sh.echo(["spam", "and", "eggs"])\n        spam and eggs\n\n\nPersistence\n===========\n    There\'s a bit of overhead involved in finding a writable directory suitable\n    for storing a config file or a persistent settings hash. The L{storage_dir}\n    function removes that overhead. It accepts an optional directory name; if\n    it represents an absolute path, it will be treated as such. Otherwise, it\n    will be treated as a path relative to a writeable directory. On Windows,\n    that directory wil be the roaming profile Application Data directory; on\n    *nix, it will be the current user\'s home directory. If the resulting path\n    doesn\'t exist, it will be created.\n\n    For example, finding a path to store a persistent configuration file is as\n    easy as: C{f = storage_dir(\'.myscript.cfg\')}. Of course, it\'s easier still\n    with the L{config} function (explained below).\n\n    The L{config} function loads or creates a .ini-style config file at a given\n    directory, using ConfigParser; however, it is an improvement in two\n    respects. First, it is passed through L{storage_dir}, so locating the\n    config file is easier.  Second, it returns an instance of the\n    L{persistence.ConfigStorage} class, which wraps a ConfigParser instance to\n    provide a dictionary-like interface. Sections and options may be accessed\n    like nested dictionaries. In addition, the file is automatically saved when\n    values are set.\n\n        >>> import tempfile; filename = tempfile.mkstemp()[1]\n        >>> cfg = config(filename)\n        >>> cfg[\'sec1\'][\'option2\'] = 75\n        >>> cfg[\'sec2\'][\'option1\'] = "Some String"\n        >>> cfg[\'sec2\'][\'option2\'] = "Another value"\n        >>> f = file(filename)\n        >>> print f.read()\n        [sec1]\n        option2 = 75\n        <BLANKLINE>\n        [sec2]\n        option2 = Another value\n        option1 = Some String\n        <BLANKLINE>\n        <BLANKLINE>\n\n    Finally, the L{db} function returns a persistent dictionary, again run\n    through L{storage_dir} to make file creation and access simple. It uses\n    the C{shelve} module to create or load a pickled dictionary from a given\n    filename. When the dictionary is modified, the pickle is saved. This allows\n    for a simple, flexible database when it\'s unimportant that the user be able\n    to modify directly the data stored therein. For all intents and purposes,\n    it may be treated as a regular dictionary in the code.\n\n        >>> import tempfile; filename = tempfile.mkstemp()[1]\n        >>> cfg = db(\'.test-ignore\')\n        >>> cfg[\'option1\'] = 10L\n        >>> cfg[\'option2\'] = [1, 2, 3, 4, (5, 6)]\n        >>> print cfg\n        {\'option2\': [1, 2, 3, 4, (5, 6)], \'option1\': 10L}\n\n    See the C{shelve} documentation for more details. The only thing added by\n    this package is the mutation of the file path by L{storage_dir}.\n\nDecorators\n==========\n\nThe L{cliargs} decorator\n------------------------\n    A common pattern for shell scripts is::\n\n        def main():\n            parser = make_an_option_parser()\n            parser.parse(sys.argv[1:])\n            do_some_stuff_with_options()\n\n        if __name__=="__main__":\n            main()\n\n    Creation of shell scripts using C{setuptools}\' C{entry_points} results in a\n    similar pattern; a function is called with no arguments, and must do its\n    own command-line argument parsing. This makes sense in some cases, where\n    complex argument parsing is required. In simple cases, however, where\n    parsing of a few arguments or keywords is required, the L{cliargs}\n    decorator will be of use. It does a simple parse of C{sys.argv}, using a\n    parsing algorithm based on some code in C{getopt}, and calls the decorated\n    function with the results::\n\n        @cliargs\n        def myScript(anarg, anotherarg, someval="default")\n            "Usage: myscript anarg anotherarg [--someval VALUE]"\n            print anarg anotherarg someval\n\n    When that function is called as a result of a command line script, such\n    as::\n\n        $ myscript val1 val2 --someflag somevalue \n\n    L{cliargs} will parse C{sys.argv} and pass the results into myScript. If\n    improper arguments are passed such that a C{TypeError} is raised, the\n    docstring of the function will be printed; this makes that an ideal place\n    to include a usage string.\n\n    L{cliargs} is of course limited to very simple cases. More complex argument\n    parsing will require the use of the C{getopt} or C{optparse} modules.\n\nL{redirect}\n-------------------------------------\n    L{redirect} is an almost trivially simple decorator factory. When\n    called with a file-like object, it returns a decorator that redirects\n    C{sys.stdout} to that file for the duration of the execution of the\n    decorated function.\n\n        >>> from StringIO import StringIO\n        >>> logfile = StringIO()\n        >>> logger = redirect(logfile)\n        >>> @logger\n        ... def func():\n        ...     print "ABCDEFGHIJK"\n        ... \n        >>> func()\n        >>> logfile.seek(0)\n        >>> logfile.read().strip()\n        \'ABCDEFGHIJK\'\n\nL{indir}\n--------\n    L{indir} is a decorator factory that runs the decorated function in a given\n    directory, changing back to the original directory on completion.\n    \n        >>> import os\n        >>> d = os.path.realpath(\'/etc\')\n        >>> curdir = os.path.realpath(os.curdir)\n        >>> @indir(d)\n        ... def whereami():\n        ...     return os.path.realpath(os.curdir)\n        ...\n        >>> whereami() == d\n        True\n        >>> os.path.realpath(os.curdir) == curdir\n        True\n\n'
__version__ = '0.1.3'
__all__ = ['sh', 'Process', 'cliargs', 'redirect_decorator', 'redirect', 'indir', 'db', 'config']
from process import sh, Process
from decorators import cliargs, logged, log_decorator, redirect, indir
from persistence import *
# uncompyle6 version 3.6.7
# Python bytecode 3.4 (3310)
# Decompiled from: Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: /home/joshua/Dropbox/code/pyrostest/lib/python3.4/site-packages/pyrostest/launch_tools.py
# Compiled at: 2017-06-11 13:34:05
# Size of source mod 2**32: 5997 bytes
__doc__ = 'Utilities for launching ros nodes for tests.\n'
import functools, os, sys, time, roslaunch, pyrostest.rostest_utils

class RosLaunchException(Exception):
    """RosLaunchException"""
    pass


class ROSLauncher(roslaunch.scriptapi.ROSLaunch):
    """ROSLauncher"""

    def __init__(self, files, port=11311):
        super(ROSLauncher, self).__init__()
        uuid = roslaunch.rlutil.get_or_generate_uuid(None, True)
        self.parent = roslaunch.parent.ROSLaunchParent(uuid, files, is_core=False, port=port)


def with_launch_file(package, launch, **kwargs):
    """Decorator to source a launch file for running nodes.

    This should always be run first.

    This and launch nodes work together gracefully, as long as you follow the
    guidelines outlined in `buzzmobile/tests/test_utils/launch_tools.py`.
    """

    def launcher(func):
        """Decorator function created by the decorator-gen.
        """

        @functools.wraps(func)
        def new_test(self):
            """Wrapper around the user provided test that runs a launch file.
            """
            try:
                full_name = roslaunch.rlutil.resolve_launch_arguments([package,
                 launch])
            except roslaunch.core.RLException:
                raise Exception('The package {}/{} does not exist. Make surethe name is correct and you have initialized your ROSenvironment'.format(package, launch))

            os.environ['ROS_MASTER_URI'] = self.rosmaster_uri
            new_argvs = ['{}:={}'.format(k, v) for k, v in kwargs.iteritems()]
            sys.argv.extend(new_argvs)
            ros_launcher = ROSLauncher(full_name, port=self.port)
            ros_launcher.start()
            if self.port in self.LAUNCHER:
                raise RosLaunchException('Rosmaster port {} already in use. You must call use @with_launch_file only once for any single test, and before any @launch_node calls.'.format(self.port))
            self.LAUNCHER[self.port] = ros_launcher
            try:
                try:
                    temp = func(self)
                except Exception as exc:
                    raise exc

            finally:
                self.LAUNCHER[self.port].stop()
                sys.argv = sys.argv[:len(new_argvs)]
                del self.LAUNCHER[self.port]

            return temp

        return new_test

    return launcher


def launch_node(package, name, namespace=None):
    """Decorator to manage running a node and shutting it down gracefully.

    Note that this will wrap itself up cleanly and launch all nodes with a
    single launcher, instead of multiples.
    """
    if not namespace:
        namespace = '/' + package

    def launcher(func):
        """Actual decorator generated by the above.
        """

        @functools.wraps(func)
        def new_test(self):
            """Wrapper around the user-provided test that runs a ros node.
            """
            is_master = False
            if self.port not in self.LAUNCHER:
                os.environ['ROS_MASTER_URI'] = self.rosmaster_uri
                launch = ROSLauncher([], port=self.port)
                launch.start()
                self.LAUNCHER[self.port] = launch
                is_master = True
            else:
                launch = self.LAUNCHER[self.port]
            env = {'ROS_MASTER_URI': self.rosmaster_uri}
            node = roslaunch.core.Node(package, name, namespace=namespace, env_args=env.iteritems())
            process = launch.launch(node)
            while not any(nn.split('/')[(-1)].startswith(name.replace('.', '_')) for nn in pyrostest.rostest_utils.my_get_node_names(uri=self.rosmaster_uri)):
                time.sleep(0.1)

            try:
                try:
                    temp = func(self)
                except:
                    raise

            finally:
                process.stop()

            if is_master:
                self.LAUNCHER[self.port].stop()
                del self.LAUNCHER[self.port]
            return temp

        return new_test

    return launcher
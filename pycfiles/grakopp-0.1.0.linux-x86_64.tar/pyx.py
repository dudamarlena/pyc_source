# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /usr/lib64/python2.7/site-packages/grakopp/codegen/pyx.py
# Compiled at: 2014-08-01 18:56:24
from __future__ import absolute_import, division, print_function, unicode_literals
from grako.util import indent, trim, timestamp
from grako.exceptions import CodegenError
from grako.model import Node
from grako.codegen.cgbase import ModelRenderer, CodeGenerator

class PyxCodeGenerator(CodeGenerator):

    def _find_renderer_class(self, item):
        if not isinstance(item, Node):
            return
        else:
            name = item.__class__.__name__
            renderer = globals().get(name, None)
            if not renderer or not issubclass(renderer, ModelRenderer):
                raise CodegenError(b'Renderer for %s not found' % name)
            return renderer


def codegen(model):
    return PyxCodeGenerator().render(model)


class Grammar(ModelRenderer):

    def render_fields(self, fields):
        abstract_template = trim(self.abstract_rule_template)
        abstract_rules = [ abstract_template.format(parsername=fields[b'name'], name=rule.name) for rule in self.node.rules
                         ]
        abstract_rules = indent((b'\n').join(abstract_rules))
        rule_template = trim(self.rule_template)
        rules = [ rule_template.format(parsername=fields[b'name'], name=rule.name) for rule in self.node.rules
                ]
        rules = (b'\n').join(rules)
        if self.node.statetype is not None:
            statetype_arg = b', ' + self.node.statetype
        else:
            statetype_arg = b''
        version = str(tuple(int(n) for n in str(timestamp()).split(b'.')))
        fields.update(rules=indent(rules), abstract_rules=abstract_rules, version=version, statetype_arg=statetype_arg)
        return

    abstract_rule_template = b'\n            AstPtr _{name}_(AstPtr& ast) nogil:\n                with gil:\n                    print "{name}" # TODO: Actually invoke a wrapped rule.\n                return ast\n            '
    rule_template = b'\n        def _{name}_(self):\n            ast = PyAst()\n            ast.ast = deref(self.parser)._{name}_()\n            return ast\n        '
    template = b'                # -*- coding: utf-8 -*-\n                # CAVEAT UTILITOR\n                #\n                # This file was automatically generated by Grako++.\n                # https://pypi.python.org/pypi/grakopp/\n                #\n                # Any changes you make to it will be overwritten the next time\n                # the file is generated.\n                \n                # Version: {version}\n\n                from cython.operator cimport dereference as deref\n                from libcpp.string cimport string\n\n                from grakopp.buffer cimport PyBuffer\n                from grakopp.parser cimport Parser\n                from grakopp.ast cimport make_shared, Ast, AstPtr, PyAst\n\n                cdef cppclass {name}WrappedSemantics({name}Semantics):\n                    # TODO: Write a function to call Python objects\n                    # and return them in the Ast.\n                {abstract_rules}\n\n                cdef class {name}PyParser(object):\n                    """Parser for Grakopp grammar \'{name}\'."""\n\n                    cdef {name}Parser* parser\n                    # cdef {name}WrappedSemantics semantics\n\n                    def __cinit__(self):\n                        # TODO: Support semantics argument (C++? Python? Both? Use inheritance?)\n                        self.parser = new {name}Parser()\n\n                    def __dealloc__(self):\n                        del self.parser\n\n                    # Because Cython does not supported templated extension types,\n                    # we can\'t use inheritance but have to put all members here.\n\n                    def set_buffer(self, PyBuffer buffer):\n                        deref(self.parser).set_buffer(buffer.buffer)\n\n                    def set_whitespace(self, whitespace):\n                        deref(self.parser).set_whitespace(whitespace)\n\n                    def set_nameguard(self, nameguard):\n                        deref(self.parser).set_nameguard(nameguard)\n\n                    def reset(self):\n                        deref(self.parser).reset()\n\n                    # typedef AstPtr (nameParser::*rule_method_t) ();\n                    # rule_method_t find_rule(const std::string& name);\n\n                {rules}\n               '
# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build\bdist.win32\egg\biosignalsnotebooks\load.py
# Compiled at: 2020-03-23 15:40:39
# Size of source mod 2**32: 32696 bytes
"""
List of functions intended to load data (electrophysiological signals) inside the different file
formats generated by OpenSignals.

The existent formats are .h5, .txt and .edf

Available Functions
-------------------
[Public]

load
    Universal function for reading .txt, .h5 and .edf files generated by OpenSignals.
read_header
    Universal function for reading the header of .txt, .h5 and .edf files generated by OpenSignals.

Available Functions
-------------------
[Private]
_load_txt
    Used for reading .txt files generated by OpenSignals.
_load_h5
    Used for reading .h5 files generated by OpenSignals.
_check_shape_and_type
    With this function it is possible to check if the "devices" and "channels" fields of
    load function have the same shape.
_check_chn_type
    Function used for checking whether the elements in "channels" input of load function are
    coincident with the available channels (specified in the acquisition file).
_available_channels
    Intended for the determination of the available channels in each device.
_check_dev_type
    Function used for checking when the "devices" field of load function only contain devices
    used during the acquisition.
_file_type
    Returns the type of the file defined as input.

Observations/Comments
---------------------
None

/"""
import ast, os, datetime, magic, requests, mimetypes, numpy, wget, h5py, shutil, json, time
from .aux_functions import _is_instance, _filter_keywords
TEMP_PATH = (os.path.abspath(__file__).split(os.path.basename(__file__))[0] + 'temp\\').replace('\\', '/')

def load(file, channels=None, devices=None, get_header=False, remote=False, out_dict=False, signal_sample=False, **kwargs):
    """
    -----
    Brief
    -----
    Universal function for reading .txt, .h5 and .edf (future) files generated by OpenSignals.

    -----------
    Description
    -----------
    Each acquisition made using the OpenSignals software (available at https://www.biosignalsplux.com/en/software)
    stores the acquired data in three file formats: .txt, .h5 and .edf.

    This function facilitates the opening of the 3 types of files in order to provide the tools for the user to focus
    on the data processing and signal analysis instead of how to read the formatted files.

    ----------
    Parameters
    ----------
    file : file path or url (for url 'remote' field needs to be True)
        File path.

    channels : list [[mac_address_1_channel_1 <int>, mac_address_1_channel_2 <int>...],
                    [mac_address_2_channel_1 <int>...]...]
        From which channels will the data be loaded.

    devices : list ["mac_address_1" <str>, "mac_address_2" <str>...]
        List of devices selected by the user.

    get_header : boolean
        If True the file header will be returned as one of the function outputs.

    remote : boolean, optional
        If is True, then the file argument is assumed to be a url where the file can be downloaded.

    out_dict : bool, optional
        A flag that indicates if the returned dict should contain or not "Mac-address" has a key at level 1.

    signal_sample : bool, optional
        A flag indicating if the load function is being invoked by "load_signal" (function intended to load signal
        samples stored inside a repository).
        If it is True, then the loaded file will be renamed to a general identifier name "download_file".

    **kwargs : list of variable keyword arguments.

    Returns
    -------
    out : ndarray or dict, dict (optional)
        Data read from the input file and the header dictionary when get_header is True.
        When more than one device is specified the returned data is organized in a dictionary where
        each mac address of the device defines a key.
    """
    if remote is True:
        if 'drive.google' in file:
            response = requests.get(file)
            content_type = response.headers['content-type']
            extension = mimetypes.guess_extension(content_type)
        else:
            extension = '.' + file.split('.')[(-1)]
        if None not in [TEMP_PATH,
         datetime.datetime.now().strftime('%Y_%m_%d_%H_%M_%S'),
         extension]:
            remote_file_path = (TEMP_PATH + 'file_' + datetime.datetime.now().strftime('%Y_%m_%d_%H_%M_%S') + extension).replace('\\', '/')
            file = wget.download(file, remote_file_path)
        else:
            file = wget.download(file)
    else:
        file_type = _file_type(file)
        _check_shape_and_type(devices, channels)
        header = read_header(file)
        dev_list = list(header.keys())
        if devices is None:
            devices = dev_list
            if channels is not None:
                channels = [
                 channels]
        dev_list_standard = _check_dev_type(devices, dev_list)
        chn_dict = _available_channels(devices, header)
        chn_list_standard = _check_chn_type(channels, chn_dict)
        data = None
        if file_type in ('txt', 'plain', 'bat'):
            data = _load_txt(file, dev_list_standard, chn_list_standard, header, **kwargs)
            if remote is True and extension == None:
                extension = '.txt'
                remote_file_path = 'download_file_name' + extension
            else:
                if file_type in ('h5', 'x-hdf', 'a', 'bin'):
                    data = _load_h5(file, dev_list_standard, chn_list_standard)
                    if remote is True and extension == None:
                        extension = '.h5'
                        remote_file_path = 'download_file_name' + extension
                elif file_type in ('edf', 'octet-stream'):
                    raise RuntimeWarning('In the present package version loading data from .edf files is not available yet.')
            project_dir = '../../signal_samples'
            if remote is True:
                if os.path.isdir(project_dir):
                    devices = list(header.keys())
                    nbr_devices = len(devices)
                    if nbr_devices > 1:
                        devices_label = 'multi_hub'
                    else:
                        devices_label = 'single_hub'
                    sensor_list = []
                    channels_dev_str = ''
                    resolutions_str = ''
                    comments_str = ''
                    for mac_i, mac in enumerate(devices):
                        if len(devices) > 1 and mac_i != len(devices) - 1:
                            comment_sep = '\n'
                            other_sep = '\t'
                        else:
                            comment_sep = ''
                            other_sep = ''
                        sensor_list.append(header[mac]['sensor'])
                        channels_dev_str += '[' + mac + '] ' + str(len(sensor_list[(-1)])) + other_sep
                        resolutions_str += '[' + mac + '] ' + str(header[mac]['resolution'][0]) + ' bits' + other_sep
                        comments_str += '[' + mac + '] ' + str(header[mac]['comments']) + comment_sep

                    sensor_list = list(set(numpy.concatenate(sensor_list)))
                    date = header[mac]['date']
                    if type(date) is bytes:
                        date = date.decode('ascii')
                    if type(sensor_list[0]) in [bytes, numpy.bytes_]:
                        sensor_list = [item.decode('ascii') for item in sensor_list]
                    date = date.replace('-', '_')
                    file_extension = remote_file_path.split('.')[(-1)]
                    shutil.copy(remote_file_path, project_dir + '/' + 'signal_sample_' + devices_label + '_' + '_'.join(sensor_list) + '_' + date + '.' + file_extension)
                    aux_chn = list(data[mac].keys())[0]
                    json_dict = {'Signal Type':' | '.join(sensor_list),  'Acquisition Time':time.strftime('%H:%M:%S.0', time.gmtime(len(data[mac][aux_chn]) / int(header[mac]['sampling rate']))), 
                     'Sample Rate':str(header[devices[0]]['sampling rate']) + ' Hz', 
                     'Number of Hubs':str(len(devices)), 
                     'Number of Channels':channels_dev_str, 
                     'Resolutions':resolutions_str, 
                     'Observations':comments_str}
                    with open(project_dir + '/' + 'signal_sample_' + devices_label + '_' + '_'.join(sensor_list) + '_' + date + '_info.json', 'w') as (outfile):
                        json.dump(json_dict, outfile)
        else:
            nbr_devices = len(list(header.keys()))
            if nbr_devices == 1:
                if out_dict is False:
                    mac_out = list(data.keys())[0]
                    data = data[mac_out]
                    header = header[mac_out]
                if get_header is True:
                    out = (
                     data, header)
            else:
                out = data
        if os.path.exists(file):
            if remote is False and signal_sample is True:
                shutil.copy(file, 'download_file_name.' + file.split('.')[(-1)])
            else:
                if remote is True:
                    shutil.move(file, 'download_file_name' + extension)
    return out


def read_header(file):
    """
    -----
    Brief
    -----
    Universal function for reading the header of .txt, .h5 and .edf files generated by OpenSignals.

    -----------
    Description
    -----------
    Each file generated by the OpenSignals software (available at https://www.biosignalsplux.com/en/software) owns a set
    of metadata that allows the proper identification and characterization of each acquisition, by the identification of
    the mac address of the devices, date of acquisition, duration, number of samples, type of the devices and firmware
    version.

    This function allows to easily access all of this information using only one line of code and outputs a dictionary
    to easily identify each field of the header of file.

    ----------
    Parameters
    ----------
    file : file path
        File path.

    Returns
    -------
    out : dict
        Header data read from the input file as dictionary with keys:
            [mac address]: The key is a string with the mac address of the device;
            sensor: Sensor(s) used in the acquisition;
            device name: String with the mac address identifying the device used in the acquisition process;
            sync interval: Time interval (in seconds) at which a digital signal is sent by a
                “pacemaker” thread to a single device (used when the sync mode in on OpenSignals for synchronized data
                acquisition using multiple devices);
            time: Time of the acquisition;
            comments: Comments inserted in the OpenSignals software after the acquisition;
            device connection: Used connection to the device while using it;
            channels: Used channels;
            keywords: Keywords inserted in the OpenSignals software after the acquisition;
            digital IO: Digital channels available in each device (0 is the Input and 1 is the Output);
            firmware version: Firmware version of the device;
            device: Type of device used during the acquisition;
            sampling rate: Sampling rate set prior to the acquisition;
            resolution: Resolution set prior to the acquisition;
            date: Date of the acquisition;
            column labels: Labels of each set of data (e.g. channel 1).

    """
    file_type = _file_type(file)
    if file_type in ('txt', 'plain', 'bat'):
        file_temp = open(file, 'r')
        header = file_temp.readlines()[1]
        file_temp.close()
        header = ast.literal_eval(header.split('# ')[1].split('\n')[0])
        macs = header.keys()
        col_nbr = 0
        for mac in macs:
            del header[mac]['special']
            del header[mac]['position']
            del header[mac]['mode']
            column_labels = {}
            for chn_nbr, chn in enumerate(header[mac]['channels']):
                chn_label = header[mac]['label'][chn_nbr]
                column_labels[chn] = col_nbr + numpy.where(numpy.array(header[mac]['column']) == chn_label)[0][0]

            header[mac]['column labels'] = column_labels
            col_nbr += len(header[mac]['column'])
            del header[mac]['column']
            del header[mac]['label']

    else:
        if file_type in ('h5', 'x-hdf', 'a', 'bin'):
            file_temp = h5py.File(file, mode='r')
            macs = file_temp.keys()
            header = {}
            for mac in macs:
                header[mac] = dict(file_temp.get(mac).attrs.items())
                header[mac]['sensor'] = []
                for key in ('duration', 'mode', 'keywords', 'nsamples', 'forcePlatform values',
                            'macaddress'):
                    if key in header[mac].keys():
                        del header[mac][key]

                column_labels = {}
                for chn in header[mac]['channels']:
                    chn_label = 'channel_' + str(chn)
                    column_labels[chn] = chn_label
                    header[mac]['sensor'].append(dict(file_temp.get(mac).get('raw').get('channel_' + str(chn)).attrs.items())['sensor'])

                header[mac]['column labels'] = column_labels

            file_temp.close()
        else:
            raise RuntimeError('The type of the input file does not correspond to the predefined formats of OpenSignals')
    return header


def clean_temp():
    """
    -----
    Brief
    -----
    Function for cleaning the temporary folder inside the package.

    -----------
    Description
    -----------
    Data processing may generate temporary files that occupy the storage of the computer.

    This function allows the user to clean the temporary files when necessary.

    source:
    https://stackoverflow.com/questions/185936/how-to-delete-the-contents-of-a-folder-in-python
    """
    folder = 'tempOST'
    for the_file in os.listdir(folder):
        file_path = os.path.join(folder, the_file)
        try:
            if os.path.isfile(file_path):
                os.unlink(file_path)
        except Exception as exception:
            try:
                print(exception)
            finally:
                exception = None
                del exception


def _load_txt(file, devices, channels, header, **kwargs):
    """
    Function used for reading .txt files generated by OpenSignals.

    ----------
    Parameters
    ----------
    file : file, str, or pathlib.Path
        File, filename, or generator to read.  If the filename extension is
        ``.gz`` or ``.bz2``, the file is first decompressed. Note that
        generators should return byte strings for Python 3k.

    devices : list ["mac_address_1" <str>, "mac_address_2" <str>...]
        List of devices selected by the user.

    channels : list [[mac_address_1_channel_1 <int>, mac_address_1_channel_2 <int>...],
                    [mac_address_2_channel_1 <int>...]...]
        From which channels will the data be loaded.

    header : dict
        File header with relevant metadata for identifying which columns may be read.

    **kwargs : list of variable keyword arguments. The valid keywords are those used by
               numpy.loadtxt function.

    Returns
    -------
    out_dict : dict
        Data read from the text file.
    """
    kwargs_txt = _filter_keywords(numpy.loadtxt, kwargs)
    out_dict = {}
    for dev_nbr, device in enumerate(devices):
        out_dict[device] = {}
        columns = []
        for chn in channels[dev_nbr]:
            columns.append(header[device]['column labels'][chn])
            out_dict[device]['CH' + str(chn)] = (numpy.loadtxt)(fname=file, usecols=header[device]['column labels'][chn], **kwargs_txt)

    return out_dict


def _load_h5(file, devices, channels):
    """
    Function used for reading .h5 files generated by OpenSignals.

    ----------
    Parameters
    ----------
    file : file path.
        File Path.

    devices : list ["mac_address_1" <str>, "mac_address_2" <str>...]
        List of devices selected by the user.

    channels : list [[mac_address_1_channel_1 <int>, mac_address_1_channel_2 <int>...],
                    [mac_address_2_channel_1 <int>...]...]
        From which channels will the data be loaded.

    Returns
    -------
    out_dict : dict
        Data read from the h5 file.
    """
    h5_object = h5py.File(file, mode='r')
    out_dict = {}
    for dev_nbr, device in enumerate(devices):
        out_dict[device] = {}
        for chn in channels[dev_nbr]:
            data_temp = list(h5_object.get(device).get('raw').get('channel_' + str(chn)))
            out_dict[device]['CH' + str(chn)] = numpy.concatenate(data_temp)

    return out_dict


def _check_shape_and_type--- This code section failed: ---

 L. 602         0  LOAD_GLOBAL              isinstance
                2  LOAD_FAST                'devices'
                4  LOAD_GLOBAL              type
                6  LOAD_FAST                'channels'
                8  CALL_FUNCTION_1       1  '1 positional argument'
               10  CALL_FUNCTION_2       2  '2 positional arguments'
               12  POP_JUMP_IF_FALSE   170  'to 170'

 L. 603        14  LOAD_GLOBAL              type
               16  LOAD_FAST                'devices'
               18  CALL_FUNCTION_1       1  '1 positional argument'
               20  STORE_FAST               'dev_chn_type'

 L. 604        22  LOAD_FAST                'devices'
               24  LOAD_CONST               None
               26  COMPARE_OP               is
               28  POP_JUMP_IF_FALSE    32  'to 32'

 L. 605        30  JUMP_ABSOLUTE       202  'to 202'
             32_0  COME_FROM            28  '28'

 L. 606        32  LOAD_FAST                'dev_chn_type'
               34  LOAD_GLOBAL              list
               36  COMPARE_OP               ==
               38  POP_JUMP_IF_FALSE   160  'to 160'

 L. 608        40  LOAD_GLOBAL              len
               42  LOAD_FAST                'devices'
               44  CALL_FUNCTION_1       1  '1 positional argument'
               46  LOAD_GLOBAL              sum
               48  LOAD_GENEXPR             '<code_object <genexpr>>'
               50  LOAD_STR                 '_check_shape_and_type.<locals>.<genexpr>'
               52  MAKE_FUNCTION_0          'Neither defaults, keyword-only args, annotations, nor closures'
               54  LOAD_FAST                'channels'
               56  GET_ITER         
               58  CALL_FUNCTION_1       1  '1 positional argument'
               60  CALL_FUNCTION_1       1  '1 positional argument'
               62  COMPARE_OP               ==
               64  POP_JUMP_IF_FALSE   150  'to 150'

 L. 610        66  SETUP_LOOP          158  'to 158'
               68  LOAD_GLOBAL              enumerate
               70  LOAD_FAST                'devices'
               72  CALL_FUNCTION_1       1  '1 positional argument'
               74  GET_ITER         
               76  FOR_ITER            146  'to 146'
               78  UNPACK_SEQUENCE_2     2 
               80  STORE_FAST               'dev_nbr'
               82  STORE_FAST               'device'

 L. 612        84  LOAD_GLOBAL              isinstance
               86  LOAD_FAST                'device'
               88  LOAD_GLOBAL              str
               90  CALL_FUNCTION_2       2  '2 positional arguments'
               92  POP_JUMP_IF_FALSE   136  'to 136'

 L. 615        94  SETUP_LOOP          144  'to 144'
               96  LOAD_FAST                'channels'
               98  LOAD_FAST                'dev_nbr'
              100  BINARY_SUBSCR    
              102  GET_ITER         
              104  FOR_ITER            132  'to 132'
              106  STORE_FAST               'channel'

 L. 616       108  LOAD_GLOBAL              isinstance
              110  LOAD_FAST                'channel'
              112  LOAD_GLOBAL              int
              114  CALL_FUNCTION_2       2  '2 positional arguments'
              116  POP_JUMP_IF_FALSE   122  'to 122'

 L. 617       118  CONTINUE            104  'to 104'
              120  JUMP_BACK           104  'to 104'
            122_0  COME_FROM           116  '116'

 L. 619       122  LOAD_GLOBAL              RuntimeError
              124  LOAD_STR                 "At least one of the 'channels' elements is not an integer"
              126  CALL_FUNCTION_1       1  '1 positional argument'
              128  RAISE_VARARGS_1       1  'exception instance'
              130  JUMP_BACK           104  'to 104'
              132  POP_BLOCK        
              134  JUMP_BACK            76  'to 76'
            136_0  COME_FROM            92  '92'

 L. 622       136  LOAD_GLOBAL              RuntimeError
              138  LOAD_STR                 "At least one of the 'devices' elements is not a mac address string"
              140  CALL_FUNCTION_1       1  '1 positional argument'
              142  RAISE_VARARGS_1       1  'exception instance'
            144_0  COME_FROM_LOOP       94  '94'
              144  JUMP_BACK            76  'to 76'
              146  POP_BLOCK        
              148  JUMP_ABSOLUTE       168  'to 168'
            150_0  COME_FROM            64  '64'

 L. 625       150  LOAD_GLOBAL              RuntimeError
              152  LOAD_STR                 "The shape of devices and channels lists are not the same. The number of sublists in the 'channels' input may be equal to the number of devices specified in 'devices' field."
              154  CALL_FUNCTION_1       1  '1 positional argument'
              156  RAISE_VARARGS_1       1  'exception instance'
            158_0  COME_FROM_LOOP       66  '66'
              158  JUMP_ABSOLUTE       202  'to 202'
            160_0  COME_FROM            38  '38'

 L. 629       160  LOAD_GLOBAL              RuntimeError
              162  LOAD_STR                 "The chosen data type of 'devices' and 'channels' fields is not supported."
              164  CALL_FUNCTION_1       1  '1 positional argument'
              166  RAISE_VARARGS_1       1  'exception instance'
              168  JUMP_FORWARD        202  'to 202'
            170_0  COME_FROM            12  '12'

 L. 632       170  LOAD_FAST                'devices'
              172  LOAD_CONST               None
              174  COMPARE_OP               is
              176  POP_JUMP_IF_FALSE   194  'to 194'
              178  LOAD_GLOBAL              _is_instance
              180  LOAD_GLOBAL              int
              182  LOAD_FAST                'channels'
              184  LOAD_STR                 'all'
              186  LOAD_CONST               ('condition',)
              188  CALL_FUNCTION_KW_3     3  '3 total positional and keyword args'
              190  POP_JUMP_IF_FALSE   194  'to 194'

 L. 633       192  JUMP_FORWARD        202  'to 202'
            194_0  COME_FROM           190  '190'
            194_1  COME_FROM           176  '176'

 L. 636       194  LOAD_GLOBAL              RuntimeError
              196  LOAD_STR                 "The input 'devices' and 'channels' must be of the same type (None or list). When only one device is being used is also possible to specify None as 'device' input and a list of integers in the 'channel' field"
              198  CALL_FUNCTION_1       1  '1 positional argument'
              200  RAISE_VARARGS_1       1  'exception instance'
            202_0  COME_FROM           192  '192'
            202_1  COME_FROM           168  '168'

Parse error at or near `COME_FROM_LOOP' instruction at offset 158_0


def _check_chn_type(channels, available_channels):
    """
    Function used for checking weather the elements in "channels" input are coincident with the
    available channels.

    ----------
    Parameters
    ----------
    channels : list [[mac_address_1_channel_1 <int>, mac_address_1_channel_2 <int>...],
                    [mac_address_2_channel_1 <int>...]...]
        From which channels will the data be loaded.

    available_channels : dict
        Dictionary with the list of all the available channels per device.

    Returns
    -------
    out : list
        It is returned a list of the selected channels in a standardized format.

    """
    chn_list_standardized = []
    devices = list(available_channels.keys())
    for dev_nbr, device in enumerate(devices):
        if channels is not None:
            sub_unit = channels[dev_nbr]
            for channel in sub_unit:
                if channel in available_channels[devices[dev_nbr]]:
                    continue
                else:
                    raise RuntimeError('At least one of the specified channels is not available in the acquisition file.')

            chn_list_standardized.append(sub_unit)
        else:
            chn_list_standardized.append(available_channels[device])

    return chn_list_standardized


def _available_channels(devices, header):
    """
    Function used for the determination of the available channels in each device.

    ----------
    Parameters
    ----------
    devices : list ["mac_address_1" <str>, "mac_address_2" <str>...]
        List of devices selected by the user.

    header: dict
        Dictionary that contains auxiliary data of the acquisition.

    Returns
    -------
    out : dict
        Returns a dictionary where each device defines a key and the respective value will be a list
        of the available channels for the device.

    """
    chn_dict = {}
    for dev in devices:
        chn_dict[dev] = header[dev]['column labels'].keys()

    return chn_dict


def _check_dev_type(devices, dev_list):
    """
    Function used for checking weather the "devices" field only contain devices used during the
    acquisition.

    ----------
    Parameters
    ----------
    devices : list ["mac_address_1" <str>, "mac_address_2" <str>...]
        List of devices selected by the user.

    dev_list : list
        List of available devices in the acquisition file.

    Returns
    -------
    out : list
        Returns a standardized list of devices.

    """
    if devices is not None:
        for device in devices:
            if device in dev_list:
                continue
            else:
                raise RuntimeError('At least one of the specified devices is not available in the acquisition file.')

        out = devices
    else:
        out = dev_list
    return out


def _file_type(file):
    """
    Function intended for identification of the file type.

    ----------
    Parameters
    ----------
    file : file path
        File path.

    Returns
    -------
    out : str
        Identified file type.

    """
    if '.' in file:
        file_type = file.split('.')[(-1)]
    else:
        file_type = magic.from_file(file, mime=True).split('/')[(-1)]
    return file_type
# uncompyle6 version 3.6.7
# Python bytecode 3.5 (3351)
# Decompiled from: Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: \.\cx_Freeze\macdist.py
# Compiled at: 2019-08-29 22:24:38
# Size of source mod 2**32: 14650 bytes
from distutils.core import Command, DistutilsFileError
import os, plistlib, stat, subprocess
from cx_Freeze.common import normalize_to_list
__all__ = [
 'bdist_dmg', 'bdist_mac']

class bdist_dmg(Command):
    description = 'create a Mac DMG disk image containing the Mac application bundle'
    user_options = [
     ('volume-label=', None, 'Volume label of the DMG disk image'),
     ('applications-shortcut=', None, 'Boolean for whether to include shortcut to Applications in the DMG disk image')]

    def initialize_options(self):
        self.volume_label = self.distribution.get_fullname()
        self.applications_shortcut = False

    def finalize_options(self):
        pass

    def buildDMG(self):
        if os.path.exists(self.dmgName):
            os.unlink(self.dmgName)
        createargs = [
         'hdiutil', 'create', '-fs', 'HFSX', '-format', 'UDZO',
         self.dmgName, '-imagekey', 'zlib-level=9', '-srcfolder',
         self.bundleDir, '-volname', self.volume_label]
        if self.applications_shortcut:
            scriptargs = ['osascript', '-e',
             'tell application "Finder" to make alias                 file to POSIX file "/Applications" at POSIX file "%s"' % os.path.realpath(self.buildDir)]
            if os.spawnvp(os.P_WAIT, 'osascript', scriptargs) != 0:
                raise OSError('creation of Applications shortcut failed')
            createargs.append('-srcfolder')
            createargs.append(self.buildDir + '/Applications')
        if os.spawnvp(os.P_WAIT, 'hdiutil', createargs) != 0:
            raise OSError('creation of the dmg failed')

    def run(self):
        self.run_command('bdist_mac')
        self.bundleDir = self.get_finalized_command('bdist_mac').bundleDir
        self.buildDir = self.get_finalized_command('build').build_base
        self.dmgName = os.path.join(self.buildDir, self.volume_label + '.dmg')
        self.execute(self.buildDMG, ())


class bdist_mac(Command):
    description = 'create a Mac application bundle'
    user_options = [
     ('iconfile=', None, 'Path to an icns icon file for the application.'),
     ('qt-menu-nib=', None, 'Location of qt_menu.nib folder for Qt applications. Will be auto-detected by default.'),
     ('bundle-name=', None, 'File name for the bundle application without the .app extension.'),
     ('custom-info-plist=', None, 'File to be used as the Info.plist in the app bundle. A basic one will be generated by default.'),
     ('include-frameworks=', None, 'A comma separated list of Framework directories to include in the app bundle.'),
     ('include-resources=', None, "A list of tuples of additional files to include in the app bundle's resources directory, with the first element being the source, and second the destination file or directory name."),
     ('codesign-identity=', None, 'The identity of the key to be used to sign the app bundle.'),
     ('codesign-entitlements=', None, "The path to an entitlements file to use for your application's code signature."),
     ('codesign-deep=', None, 'Boolean for whether to codesign using the --deep option.'),
     ('codesign-resource-rules', None, "Plist file to be passed to codesign's --resource-rules option."),
     ('absolute-reference-path=', None, 'Path to use for all referenced libraries instead of @executable_path.'),
     ('rpath-lib-folder', None, 'replace @rpath with given folder for any files')]

    def initialize_options(self):
        self.iconfile = None
        self.qt_menu_nib = False
        self.bundle_name = self.distribution.get_fullname()
        self.custom_info_plist = None
        self.include_frameworks = []
        self.include_resources = []
        self.codesign_identity = None
        self.codesign_entitlements = None
        self.codesign_deep = None
        self.codesign_resource_rules = None
        self.absolute_reference_path = None
        self.rpath_lib_folder = None

    def finalize_options(self):
        self.include_frameworks = normalize_to_list(self.include_frameworks)

    def create_plist(self):
        """Create the Contents/Info.plist file"""
        if self.custom_info_plist:
            contents = plistlib.readPlist(self.custom_info_plist)
        else:
            contents = {'CFBundleIconFile': 'icon.icns', 
             'CFBundleDevelopmentRegion': 'English', 
             'CFBundleIdentifier': self.bundle_name}
        contents['CFBundleExecutable'] = self.bundle_executable
        plist = open(os.path.join(self.contentsDir, 'Info.plist'), 'wb')
        plistlib.writePlist(contents, plist)
        plist.close()

    def setAbsoluteReferencePaths(self, path=None):
        """
        For all files in Contents/MacOS, set their linked library paths to be
        absolute paths using the given path instead of @executable_path.
        """
        if not path:
            path = self.absolute_reference_path
        files = os.listdir(self.binDir)
        for filename in files:
            filename = os.path.join(self.binDir, filename)
            if not filename[-1:] in ('txt', 'zip'):
                if os.path.isdir(filename):
                    pass
                else:
                    otool = subprocess.Popen(('otool', '-L', filename), stdout=subprocess.PIPE)
                    for line in otool.stdout.readlines()[1:]:
                        lib = line.decode('utf-8').lstrip('\t').split(' (compat')[0]
                        if lib.startswith('@executable_path'):
                            replacement = lib.replace('@executable_path', path)
                            path, name = os.path.split(replacement)
                            if name in files:
                                subprocess.call((
                                 'install_name_tool', '-change', lib, replacement,
                                 filename))

    def setRelativeReferencePaths(self):
        """ Create a list of all the Mach-O binaries in Contents/MacOS.
            Then, check if they contain references to other files in
            that dir. If so, make those references relative. """
        files = []
        for root, dirs, dir_files in os.walk(self.binDir):
            for f in dir_files:
                p = subprocess.Popen(('file', os.path.join(root, f)), stdout=subprocess.PIPE)
                if 'Mach-O' in p.stdout.readline().decode():
                    files.append(os.path.join(root, f).replace(self.binDir + '/', ''))

        for fileName in files:
            filePath = os.path.join(self.binDir, fileName)
            mode = os.stat(filePath).st_mode
            if not mode & stat.S_IWUSR:
                os.chmod(filePath, mode | stat.S_IWUSR)
            subprocess.call(('install_name_tool', '-id',
             '@executable_path/' + fileName, filePath))
            otool = subprocess.Popen(('otool', '-L', filePath), stdout=subprocess.PIPE)
            references = otool.stdout.readlines()[1:]
            for reference in references:
                referencedFile = reference.decode().strip().split()[0]
                if referencedFile.startswith('@executable_path'):
                    pass
                else:
                    if self.rpath_lib_folder is not None:
                        referencedFile = str(referencedFile).replace('@rpath', self.rpath_lib_folder)
                    if not os.path.exists(referencedFile):
                        print('skip unknown file {} '.format(referencedFile))
                        continue
                        path, name = os.path.split(referencedFile)
                        if name not in files and not path.startswith('/usr') and not path.startswith('/System'):
                            print(referencedFile)
                            try:
                                self.copy_file(referencedFile, os.path.join(self.binDir, name))
                            except DistutilsFileError as e:
                                print('issue copying {} to {} error {} skipping'.format(referencedFile, os.path.join(self.binDir, name), e))
                            else:
                                files.append(name)
                            if name in files:
                                newReference = '@executable_path/' + name
                                subprocess.call(('install_name_tool', '-change',
                                 referencedFile, newReference, filePath))

    def find_qt_menu_nib(self):
        """Returns a location of a qt_menu.nib folder, or None if this is not
           a Qt application."""
        if self.qt_menu_nib:
            return self.qt_menu_nib
        if any(n.startswith('PyQt4.QtCore') for n in os.listdir(self.binDir)):
            from PyQt4 import QtCore
        else:
            if any(n.startswith('PySide.QtCore') for n in os.listdir(self.binDir)):
                from PySide import QtCore
            else:
                return
        libpath = str(QtCore.QLibraryInfo.location(QtCore.QLibraryInfo.LibrariesPath))
        for subpath in ['QtGui.framework/Resources/qt_menu.nib',
         'Resources/qt_menu.nib']:
            path = os.path.join(libpath, subpath)
            if os.path.exists(path):
                return path

        for path in ['/opt/local/Library/Frameworks/QtGui.framework/Versions/4/Resources/qt_menu.nib']:
            if os.path.exists(path):
                return path

        print('Could not find qt_menu.nib')
        raise IOError('Could not find qt_menu.nib')

    def prepare_qt_app(self):
        """Add resource files for a Qt application. Should do nothing if the
           application does not use QtCore."""
        nib_locn = self.find_qt_menu_nib()
        if nib_locn is None:
            return
        self.copy_tree(nib_locn, os.path.join(self.resourcesDir, 'qt_menu.nib'))
        f = open(os.path.join(self.resourcesDir, 'qt.conf'), 'w')
        f.close()

    def run(self):
        self.run_command('build')
        build = self.get_finalized_command('build')
        self.bundleDir = os.path.join(build.build_base, self.bundle_name + '.app')
        self.contentsDir = os.path.join(self.bundleDir, 'Contents')
        self.resourcesDir = os.path.join(self.contentsDir, 'Resources')
        self.binDir = os.path.join(self.contentsDir, 'MacOS')
        self.frameworksDir = os.path.join(self.contentsDir, 'Frameworks')
        executable = self.distribution.executables[0].targetName
        _, self.bundle_executable = os.path.split(executable)
        self.mkpath(self.resourcesDir)
        self.mkpath(self.binDir)
        self.mkpath(self.frameworksDir)
        self.copy_tree(build.build_exe, self.binDir)
        if self.iconfile:
            self.copy_file(self.iconfile, os.path.join(self.resourcesDir, 'icon.icns'))
        for framework in self.include_frameworks:
            self.copy_tree(framework, self.frameworksDir + '/' + os.path.basename(framework))

        for resource, destination in self.include_resources:
            if os.path.isdir(resource):
                self.copy_tree(resource, self.resourcesDir + '/' + destination)
            else:
                self.copy_file(resource, self.resourcesDir + '/' + destination)

        self.execute(self.create_plist, ())
        self.execute(self.setRelativeReferencePaths, ())
        if self.absolute_reference_path:
            self.execute(self.setAbsoluteReferencePaths, ())
        self.execute(self.prepare_qt_app, ())
        if self.codesign_identity:
            signargs = ['codesign', '-s', self.codesign_identity]
            if self.codesign_entitlements:
                signargs.append('--entitlements')
                signargs.append(self.codesign_entitlements)
            if self.codesign_deep:
                signargs.insert(1, '--deep')
            if self.codesign_resource_rules:
                signargs.insert(1, '--resource-rules=' + self.codesign_resource_rules)
            signargs.append(self.bundleDir)
            if os.spawnvp(os.P_WAIT, 'codesign', signargs) != 0:
                raise OSError('Code signing of app bundle failed')
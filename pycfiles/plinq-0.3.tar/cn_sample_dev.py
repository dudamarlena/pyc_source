# uncompyle6 version 3.6.7
# Python bytecode 2.5 (62131)
# Decompiled from: Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: build/bdist.macosx-10.6-i386/egg/birdsuite/cn_sample_dev.py
# Compiled at: 2010-07-13 12:32:47
__doc__ = "%prog [options] summaries-files...\nCalculates a measure of a sample's tendency to be an outlier (with respect to a set of samples) \nin measurements on an 'invariant set' of autosomal copy-number probes in non-CNV regions.  \nThe invariant set is dictated by the a list of CN probe names.\n"
from __future__ import division
import optparse, sys, string, numpy
from mpgutils import utils
LOCUS_NUM_PROBE_FIELDS = 4

def readProbeFile(probeFile):
    probes = set()
    fIn = open(probeFile, 'rU')
    for strLine in fIn:
        probes.add(strLine)

    probes = map(string.rstrip, probes)
    return probes


def getIntensitiesForProbes(probeFile, locusFile, verbose=True):
    """reads in the locus file and list of probes, creates a 2d matrix of data with 1 probe per row, 1 sample per column
    samples are returned as the sample names (in order)
    samples, intensities are returned."""
    probes = readProbeFile(probeFile)
    fIn = open(locusFile)
    intensities = []
    sampleNames = []
    bStart = False
    for strLine in fIn:
        if bStart == True:
            data = strLine.split()
            probeName = data[0]
            if probeName in probes:
                probeData = data[LOCUS_NUM_PROBE_FIELDS:]
                intensities.append(map(float, probeData))
                if verbose:
                    print '.',
        elif strLine.startswith('probeset_id'):
            data = strLine.split()
            sampleNames = data[LOCUS_NUM_PROBE_FIELDS:]
            bStart = True

    return (
     sampleNames, intensities)


def zScoreIntensities(intensities, verbose=True):
    """BLATENTLY STOLEN (almost) from cn_probeset_summarize"""
    rawIntensities = numpy.array(intensities)
    if verbose:
        print 'Size of matrix:' + str(rawIntensities.shape)
    means = rawIntensities.mean(axis=1)
    means = utils.repmat(means, rawIntensities.shape[1], 1).transpose()
    stDevs = rawIntensities.std(axis=1)
    stDevs = utils.repmat(stDevs, rawIntensities.shape[1], 1).transpose()
    matIntensitiesProcessed = rawIntensities - means
    matIntensitiesProcessed /= stDevs
    matIntensitiesProcessed = abs(matIntensitiesProcessed)
    result = numpy.median(matIntensitiesProcessed)
    return result


def sortby(nlist, n):
    """Fast sort a set of tuples by an element in the tuple"""
    nlist[:] = [ (x[n], x) for x in nlist ]
    nlist.sort()
    nlist[:] = [ val for (key, val) in nlist ]
    return nlist


def getIndividualIntensityZscores(sampleNameList, probeIntensityList):
    """returns a list of tuples, with the first element being the sample name, and the second the intensity.
    This list is sorted by intensity"""
    intensities = zScoreIntensities(probeIntensityList)
    if len(intensities) != len(sampleNameList):
        print 'Something went wrong!'
    result = []
    for i in xrange(len(intensities)):
        t = [
         sampleNameList[i], intensities[i]]
        result.append(t)

    resultSorted = sortby(result, 1)
    return resultSorted


def writeScores(sampleScores, fileOut):
    fOut = open(fileOut, 'w')
    print >> fOut, 'sample\tintensity_score'
    for (s, i) in sampleScores:
        print >> fOut, ('\t').join([s, str(i)])

    fOut.close()


def main(argv=None):
    if argv is None:
        argv = sys.argv
    parser = optparse.OptionParser(usage=__doc__)
    parser.add_option('-p', '--probes', dest='probeFile', help='A list of probes to use in the analysis process.\n                      This file has no header and 1 column of probe names.\n                      ')
    parser.add_option('-l', '--locus', dest='locusFile', help='A locus file generated by cn_locus_summarize')
    parser.add_option('-o', '--outfile', dest='outFile', help='Output file name')
    (dctOptions, lstArgs) = parser.parse_args(argv)
    if len(lstArgs) > 1:
        print >> sys.stderr, 'ERROR: Too many arguments on command line.\n'
        parser.print_help()
        return 1
    lstRequiredOptions = ['probeFile', 'locusFile', 'outFile']
    if utils.validateRequiredOptions(dctOptions, lstRequiredOptions) is False:
        parser.print_help()
        return 1
    (sampleNameList, probeIntensityList) = getIntensitiesForProbes(dctOptions.probeFile, dctOptions.locusFile)
    sampleScores = getIndividualIntensityZscores(sampleNameList, probeIntensityList)
    writeScores(sampleScores, dctOptions.outFile)
    print 'DONE'
    return


if __name__ == '__main__':
    sys.exit(main())
# uncompyle6 version 3.7.4
# Python bytecode 3.5 (3350)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /usr/lib/python3.5/site-packages/zipdep.py
# Compiled at: 2016-04-08 12:29:52
# Size of source mod 2**32: 11392 bytes
import os, zipfile
from types import ModuleType
import sys
try:
    from base91 import encode
    __b95_available = True
except ImportError:
    from base64 import b85encode as encode
    __b95_available = False

import importlib, io
from collections import OrderedDict
if hasattr(zipfile, 'ZIP_DEFLATED'):
    mode = zipfile.ZIP_DEFLATED
else:
    mode = zipfile.ZIP_STORED
__version__ = '1.1.0'
uppertemplate = '#!/usr/bin/env python\n# This file was partially generated by zipdep.py version {zd_version}\n# For more information about zipdep.py, see https://github.com/SunDwarf/zipdep.py\n\n# region zipdep\nfrom base64 import b85decode as __zipdep_bdecode\nimport tempfile\nimport sys\nimport os\nimport struct\n\n# Declare zip file.\n# THIS IS VERY UGLY. YOU SHOULD NOT BE USING THIS FOR DEVELOPMENT. IT WILL BE NEAR IMPOSSIBLE.\n\n__zipdep__zf = """\n{zd_zipfile}\n"""\n\n# Base91 implementation\n# see: https://github.com/SunDwarf/base91-python/blob/master/base91/__init__.py\n__zipdep__base91_alphabet = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\', \'H\', \'I\', \'J\', \'K\', \'L\', \'M\',\n                   \'N\', \'O\', \'P\', \'Q\', \'R\', \'S\', \'T\', \'U\', \'V\', \'W\', \'X\', \'Y\', \'Z\',\n                   \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\', \'j\', \'k\', \'l\', \'m\',\n                   \'n\', \'o\', \'p\', \'q\', \'r\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\',\n                   \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\', \'!\', \'#\', \'$\',\n                   \'%\', \'&\', \'(\', \')\', \'*\', \'+\', \',\', \'.\', \'/\', \':\', \';\', \'<\', \'=\',\n                   \'>\', \'?\', \'@\', \'[\', \']\', \'^\', \'_\', \'`\', chr(123), \'|\', chr(125), \'~\', \'"\']\n\n__zipdep__decode_table = dict((v, k) for k, v in enumerate(__zipdep__base91_alphabet))\n\ndef __zipdep_b91_decode(encoded_str):\n v=-1\n b=0\n n=0\n out=bytearray()\n for strletter in encoded_str:\n  if not strletter in __zipdep__decode_table:\n   continue\n  c=__zipdep__decode_table[strletter]\n  if(v<0):\n   v=c\n  else:\n   v+=c*91\n   b|=v<<n\n   n+=13 if(v&8191)>88 else 14\n   while True:\n    out+=struct.pack(\'B\',b&255)\n    b>>=8\n    n-=8\n    if not n>7:\n     break\n   v=-1\n if v+1:\n  out+=struct.pack(\'B\',(b|v<<n)&255)\n return out\n\n__zipdep_has_base91 = {zd_hasb91}\n\n__zipdep__tmpdir = tempfile.mkdtemp()\n\ndef __zipdep__dextract():\n    # Base85-decode the zf.\n    if __zipdep_has_base91:\n        d = __zipdep_b91_decode\n    else:\n        d = __zipdep_bdecode\n    data = d(__zipdep__zf.replace("\\n", ""))\n    # Create the zipfile in the temporary directory.\n    with open(os.path.join(__zipdep__tmpdir, "zipdep.zip"), mode=\'wb\') as f:\n        f.write(data)\n    # Update sys.path.\n    sys.path.insert(0, os.path.join(__zipdep__tmpdir, "zipdep.zip"))\n\ndef __zipdep__cleanup():\n    # Remove the zipdep.zip file\n    os.remove(os.path.join(__zipdep__tmpdir, "zipdep.zip"))\n    os.removedirs(__zipdep__tmpdir)\n\n__zipdep__dextract()\n\n# endregion\n\n# ======================================================================================================================\n\n'
lowertemplate = '\n\n# ======================================================================================================================\n# Zipdep cleanup.\n__zipdep__cleanup()\n'

def zipdir(path, ziph, name):
    if not os.path.isdir(path):
        print(os.path.join(name, path), '->', name)
        ziph.write(os.path.join(name, path), arcname=name + '.py')
    for root, dirs, files in os.walk(path):
        newroot = '/'.join([_.lstrip('/') for _ in root.partition(name) if _][1:])
        if '__pycache__' in root:
            pass
        else:
            for file in files:
                ziph.write(os.path.join(root, file), arcname=os.path.join(newroot, file))


def extract_path(obj: ModuleType):
    if hasattr(obj, '__package__') and obj.__package__:
        print('found package: {}'.format(obj.__package__))
    if obj.__package__ == obj.__name__:
        pass
    else:
        try:
            mod = importlib.import_module(obj.__package__)
        except ImportError:
            print('unable to import module/package: {}'.format(obj.__package__))
        else:
            print('found&imported module/package:', obj.__package__)
            path = extract_path(mod)
            if path:
                return (
                 path, obj.__package__)
        if hasattr(obj, '__path__'):
            if len(obj.__path__) == 0:
                pass
            else:
                print('path:', obj.__path__[0])
                if 'site-packages' not in obj.__path__[0]:
                    print('module {} appears to be stdlib, skipping'.format(obj.__name__))
                    return
                else:
                    return obj.__path__[0]
        else:
            if hasattr(obj, '__file__'):
                if obj.__file__ == '__zipdep':
                    return
                else:
                    print('path:', obj.__file__)
                    if 'site-packages' not in obj.__file__:
                        print('module {} appears to be stdlib/project file, skipping'.format(obj.__name__))
                        return
                    return obj.__file__
            else:
                print('(assuming builtin, no __path__/__file__)')
                return


def __main__():
    sys.path.insert(0, os.getcwd())
    if len(sys.argv) == 1:
        print('usage: zipdep file.py')
        sys.exit(1)
    filenames = sys.argv[1:]
    final_zipdep = sys.argv[1]
    loc = OrderedDict({'__name__': '__zipdep'})
    for filename in filenames:
        if not os.path.exists(filename):
            print('skipping file {} - does not exist'.format(filename))
        with open(filename) as (f):
            try:
                exec(f.read(), {}, loc)
            except ImportError as e:
                print("seems like your modules weren't installed. error: {}".format(e))
                raise

    modules = {}
    if '__zipdep_zipmodules' in loc:
        print('found `zipdep_zipmodules, loading modules from here instead of scanning')
        for mod in loc['__zipdep_zipmodules']:
            print('importing {}'.format(mod))
            md = importlib.import_module(mod)
            path = extract_path(md)
            if path:
                modules[mod] = (
                 path, mod)

    else:
        for name, obj in loc.items():
            if isinstance(obj, ModuleType):
                print('found module:', name)
                path = extract_path(obj)
                if path:
                    if len(path) == 2:
                        modules[path[1]] = path
            elif path:
                modules[name] = (
                 path, name)
            if hasattr(obj, '__module__'):
                print('found object: {} with __module__: {}'.format(name, obj.__module__))
                if not obj.__module__:
                    print('skipping object in local scope')
                    continue
                    if obj.__module__ in modules:
                        print('module already imported; skipping')
                    try:
                        mod = importlib.import_module(obj.__module__)
                    except ImportError:
                        print('unable to import module: {}'.format(obj.__module__))
                    else:
                        print('found&imported module:', obj.__module__)
                        path = extract_path(mod)
                        if path:
                            modules[name] = (
                             path, name)

    print('constructing zipfile with modules: {}'.format(', '.join(['{} from {}'.format(name, path[0]) for name, path in modules.items()])))
    in_mem_zip = io.BytesIO()
    zf = zipfile.ZipFile(in_mem_zip, mode='w', compression=mode)
    for mod, path in modules.items():
        print('zipping module', mod)
        zipdir(path[0], zf, path[1])

    zf.close()
    in_mem_zip.seek(0)
    b85_data = encode(in_mem_zip.read())
    if isinstance(b85_data, bytes):
        b85_str = b85_data.decode()
    else:
        b85_str = b85_data
    b85_str = b85_str.replace('"', '\\"')
    b85 = '\n'.join([b85_str[i:i + 80] for i in range(0, len(b85_str), 80)])
    templated = uppertemplate.format(zd_version=__version__, zd_zipfile=b85, zd_hasb91=__b95_available)
    in_mem_zip.close()
    with open(final_zipdep) as (f):
        contents = f.read()
    with open(final_zipdep + '.zipdep.py', 'w') as (f):
        f.write(templated + contents + lowertemplate)
    print('success! written to file {}'.format(final_zipdep + '.zipdep.py'))


if __name__ == '__main__':
    __main__()
# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /home/bill/py3/.virtualenvs/pytest/lib/python2.7/site-packages/Csys/Parsebraces.py
# Compiled at: 2009-11-24 21:22:40
"""Celestial Software's configuration file processing.

This package parses an input file returning an object hash with
array references to an array of the highest level elements
parsed.  It assumes that logical elements are surrounded by
curley braces or parenthesis.

=head1 USAGE

import Csys.Parsebraces;

    config = Csys.Parsebraces("filename")
    rlines = obj.lines # lines
    rargs = obj.args;   # string arguments

=head1 EXAMPLES

This might be used to parse the DNS configuration files:

    import Csys.Parsebraces
    config = Csys.Parsebraces.Config("/etc/named.conf")
    To parse the lines, a general routine might be

    options = {}
    zones   = {}

    for line in config.get_lines(): #{
        args = line.split()
        keyword = args.pop(0)
        if(keyword == 'options'): #{{
            # process global options;
            options[keyword] = ' '.join(args)
        #}
        elif(keyword == 'zone'): #{
            name = args.pop(0)
            zones[name] = Zone(config, name, args)
        #}}
    #}
    class Zone: #{
        def __init__(self, config, name, args): #{
            ndx = args.pop() # last argument
            my $index = pop(@args); # get last argument
            self.name = name
            for line in config.get_text_array(ndx): #{
                args1 = line.split()
                keyword = args1.pop(0)
                if(keyword in ('type', 'file'): #{{ # simple arguments
                    self.__dict__[keyword] = args[-1]
                #}
                # these require further parsing of elements in braces.
                elif(keyword == 'masters'):# {
                    self.masters = Master(args1);
                #}
                elsf(keyword == 'transfer-allowed'): #{
                    self.transfer_allowed = Transfer(args1);
                #}}
                ...
            #}}
        #} __init__
    #} class Zone

$Id: Parsebraces.py,v 1.3 2009/11/25 02:22:40 csoftmgr Exp $"""
__version__ = '$Revision: 1.3 $'[11:-2]
import Csys, os, sys, re
_patBraces = re.compile('[{(]([^{}()]*)[)}]')
_patIndex = re.compile('^(.*)\\s+(\\d+);*$')

class Config(Csys.CSClass):
    """Configuration parsed from file"""
    _attributes = {'lines': [], 'args': []}

    def __init__(self, input):
        """Parse configuration file"""
        Csys.CSClass.__init__(self)
        self.lines = Csys.rmComments(input, C=True, Cplusplus=True, wantarray=True, pattern='.')
        input = ('\n').join(self.lines)
        while True:
            reg = _patBraces.search(input)
            if not reg:
                break
            n = len(self.args)
            self.args.append(reg.group(1))
            input = _patBraces.sub('%d' % n, input, 1)

        self.lines = [ line.rstrip() for line in input.split('\n') if line.rstrip() ]

    def get_text_array(self, idx):
        """get array by splitting the line from arg_strings"""
        if isinstance(idx, basestring):
            idx = int(idx.rstrip(';'))
        val = self.args[idx]
        lines = []
        for line in val.splitlines():
            if line:
                lines.append(line)

        return lines

    def split_line(self, ndx):
        """Break line into key, options, and index"""
        parts = self.lines[ndx].rstrip(';').split()
        return (parts[0], parts[1:-1], int(parts[(-1)]))

    def get_line_parts(self):
        """return key, options, index from line"""
        output = []
        for line in self.lines:
            parts = line.rstrip(';').split()
            output.append((parts[0], parts[1:-1], int(parts[(-1)])))

        return output

    def get_lines(self):
        return self.lines

    def dumpall(self):
        """Hopefully dump out original without comments"""
        outlines = []
        for line in self.lines:
            r = _patIndex.search(line)
            if r:
                pre, idx = r.group(1), int(r.group(2))
                outlines.append(pre)
                outlines += ['{', self.get_text_array(idx), '}']
            else:
                outlines.append(line)

        return outlines


if __name__ == '__main__':
    print 'OK'
    testinput = '\n// generated by named-bootconf.pl\n\noptions {\n\tdirectory "/usr/local/lib/named";\n\tcheck-names master warn;\n\tcheck-names slave warn;\n\tpid-file "/etc/named.pid";\n\t/*\n\t * If there is a firewall between you and nameservers you want\n\t * to talk to, you might need to uncomment the query-source\n\t * directive below.  Previous versions of BIND always asked\n\t * questions using port 53, but BIND 8.1 uses an unprivileged\n\t * port by default.\n\t */\n\t// query-source address * port 53;\n};\n\n// \n// Celestial Software nameserver boot file\n// \n// type\t\tdomain\t\t\t\tsource file or host\nzone "." {\n\ttype hint;\n\tfile "named.ca";\n};\n\nzone "0.0.127.in-addr.arpa" {\n\ttype master;\n\tfile "primary/0.0.127.in-addr.arpa";\n};\nzone "111.136.192.in-addr.arpa" {\n\ttype slave;\n\tfile "secondary/111.136.192.in-addr.arpa";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tmasters {\n\t\t192.136.111.40;\n\t};\n};\nzone "254.168.192.in-addr.arpa" {\n\ttype slave;\n\tfile "secondary/254.168.192.in-addr.arpa";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tallow-query {\n\t\t127.0.0.1;\n\t\t192.136.111.0/24;\n\t\t192.168.254.0/24;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t192.136.111.0/24;\n\t\t192.168.254.0/24;\n\t};\n\tmasters {\n\t\t192.136.111.40;\n\t};\n};\nzone "celestial.com" {\n\ttype slave;\n\tfile "secondary/celestial.com";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tmasters {\n\t\t192.136.111.3;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t204.57.191.163;\n\t\t204.57.191.242;\n\t};\n};\nzone "mi.celestial.com" {\n\ttype slave;\n\tfile "secondary/mi.celestial.com";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tallow-query {\n\t\t127.0.0.1;\n\t\t192.168.254.0/24;\n\t\t192.136.111.0/24;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t192.168.254.0/24;\n\t\t192.136.111.0/24;\n\t};\n\tmasters {\n\t\t192.136.111.3;\n\t};\n};\nzone "celestial.net" {\n\ttype slave;\n\tfile "secondary/celestial.net";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t192.136.111.0/24;\n\t\t192.168.254.0/24;\n\t\t204.57.191.1;\n\t};\n\tmasters {\n\t\t192.136.111.40;\n\t};\n};\nzone "rbl.celestial.net" {\n\ttype slave;\n\tfile "secondary/rbl.celestial.net";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t\t192.168.254.0/24;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t192.168.254.0/24;\n\t\t192.136.111.0/24;\n\t};\n\tmasters {\n\t\t192.136.111.40;\n\t};\n};\n'
    fhout = open('/tmp/named.conf', 'w')
    fhout.write(testinput)
    fhout.close()
    t = Config(open('/tmp/named.conf'))
    for line in t.lines:
        print line
        args = line.split()
        idx = int(args[(len(args) - 1)][:-1])
        txta = t.get_text_array(idx)
        print txta

    print t.dumpall()
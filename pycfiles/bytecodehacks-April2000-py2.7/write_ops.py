# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.macosx-10.7-x86_64/egg/bytecodehacks/code_gen/write_ops.py
# Compiled at: 2000-04-01 06:02:52
import dis, re, sys, os, string
from bytecodehacks.code_gen import method_spec
temphead = '#   Copyright 1999-2000 Michael Hudson mwh@python.net\n#\n#                        All Rights Reserved\n#\n#\n# Permission to use, copy, modify, and distribute this software and\n# its documentation for any purpose is hereby granted without fee,\n# provided that the above copyright notice appear in all copies and\n# that both that copyright notice and this permission notice appear in\n# supporting documentation.\n#\n# THE AUTHOR MICHAEL HUDSON DISCLAIMS ALL WARRANTIES WITH REGARD TO\n# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n# AND FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,\n# INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER\n# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF\n# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n# this file is autogenerated by running\n# from bytecodehacks.code_gen import write_ops\n# write_ops.Main()\n\nfrom bytecodehacks import opbases\nfrom bytecodehacks.label import Label\n\n_opbases = opbases\n_Label = Label\n\ndel Label\ndel opbases\n\n_bytecodes={}\n\n'
noargtemplate = "class %(name)s(_opbases.%(base)s):\n    op = %(index)d\n    opc = '\\%(index)03o'\n\n    def __init__(self,cs=None,code=None):\n        if cs is not None:\n            _opbases.%(base)s.__init__(self,cs,code)\n%(execute_method)s\n%(stack_bump_method)s\n\n_bytecodes[%(name)s.opc]=%(name)s\n\n"
argtemplate = "class %(name)s(_opbases.%(base)s):\n    op = %(index)d\n    opc = '\\%(index)03o'\n\n    def __init__(self,csorarg,code=None):\n        if code is not None:\n            _opbases.%(base)s.__init__(self,csorarg,code)\n        else:\n            self.user_init(csorarg)\n%(execute_method)s\n%(stack_bump_method)s\n\n_bytecodes[%(name)s.opc]=%(name)s\n\n"
jumptemplate = "class %(name)s(_opbases.%(base)s):\n    op = %(index)d\n    opc = '\\%(index)03o'\n\n    def __init__(self,csorarg=None,code=None):\n        if csorarg is not None:\n            if code is not None:\n                _opbases.%(base)s.__init__(self,csorarg,code)\n            else:\n                self.label = _Label()\n                self.user_init(csorarg)\n        else:\n            self.label = _Label()\n%(execute_method)s\n%(stack_bump_method)s\n\n\n_bytecodes[%(name)s.opc]=%(name)s\n\n"
execute_template = '    def execute(self,stack):\n%s'
stack_bump_template = '    def stack_manipulate(self,push,pop,block_push,block_pop,tracker):\n%s'
idprog = re.compile('^[_a-zA-Z][_a-zA-Z0-9]*$')
notopprog = re.compile('^<[0-9]+>$')

def choose_base_class_and_template(opc):
    if opc < dis.HAVE_ARGUMENT:
        return (noargtemplate, 'GenericOneByteCode')
    else:
        if opc in dis.hasjrel:
            return (jumptemplate, 'JRel')
        if opc in dis.hasjabs:
            return (jumptemplate, 'JAbs')
        if opc in dis.hasname:
            return (argtemplate, 'NameOpcode')
        if opc in dis.haslocal:
            return (argtemplate, 'LocalOpcode')
        return (argtemplate, 'GenericThreeByteCode')


execute_methods = method_spec.MethodSpecifier(os.path.join(os.path.dirname(__file__), 'execute_methods'))
stack_bump_methods = method_spec.MethodSpecifier(os.path.join(os.path.dirname(__file__), 'stack_bump_methods'))
execute_methods.set_template(execute_template)
stack_bump_methods.set_template(stack_bump_template)

def main(file=sys.stdout):
    file.write(temphead)
    trans = string.maketrans('+', '_')
    for index in range(len(dis.opname)):
        name = string.translate(dis.opname[index], trans)
        if notopprog.match(name):
            continue
        if not idprog.match(name):
            name = 'Opcode_%d' % index
        s = 'generating %s ...' % name
        pad = ' ' * (30 - len(s))
        template, base = choose_base_class_and_template(index)
        execute_method = execute_methods.get_method(name)
        stack_bump_method = stack_bump_methods.get_method(name)
        file.write(template % locals())


def Main():
    opsfile = os.path.join(os.path.dirname(__file__), os.pardir, 'ops.py')
    main(open(opsfile, 'w'))
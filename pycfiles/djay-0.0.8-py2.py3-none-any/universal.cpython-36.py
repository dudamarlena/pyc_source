# uncompyle6 version 3.7.4
# Python bytecode 3.6 (3379)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /tmp/pip-install-m_4qh6p6/docutils/docutils/transforms/universal.py
# Compiled at: 2019-07-30 18:47:12
# Size of source mod 2**32: 11102 bytes
"""
Transforms needed by most or all documents:

- `Decorations`: Generate a document's header & footer.
- `Messages`: Placement of system messages stored in
  `nodes.document.transform_messages`.
- `TestMessages`: Like `Messages`, used on test runs.
- `FinalReferences`: Resolve remaining references.
"""
__docformat__ = 'reStructuredText'
import re, sys, time
from docutils import nodes, utils
from docutils.transforms import TransformError, Transform
from docutils.utils import smartquotes

class Decorations(Transform):
    __doc__ = "\n    Populate a document's decoration element (header, footer).\n    "
    default_priority = 820

    def apply(self):
        header_nodes = self.generate_header()
        if header_nodes:
            decoration = self.document.get_decoration()
            header = decoration.get_header()
            header.extend(header_nodes)
        footer_nodes = self.generate_footer()
        if footer_nodes:
            decoration = self.document.get_decoration()
            footer = decoration.get_footer()
            footer.extend(footer_nodes)

    def generate_header(self):
        pass

    def generate_footer(self):
        settings = self.document.settings
        if settings.generator or settings.datestamp or settings.source_link or settings.source_url:
            text = []
            if settings.source_link and settings._source or settings.source_url:
                if settings.source_url:
                    source = settings.source_url
                else:
                    source = utils.relative_path(settings._destination, settings._source)
                text.extend([
                 nodes.reference('', 'View document source', refuri=source),
                 nodes.Text('.\n')])
            if settings.datestamp:
                datestamp = time.strftime(settings.datestamp, time.gmtime())
                text.append(nodes.Text('Generated on: ' + datestamp + '.\n'))
            if settings.generator:
                text.extend([
                 nodes.Text('Generated by '),
                 nodes.reference('', 'Docutils', refuri='http://docutils.sourceforge.net/'),
                 nodes.Text(' from '),
                 nodes.reference('', 'reStructuredText', refuri='http://docutils.sourceforge.net/rst.html'),
                 nodes.Text(' source.\n')])
            return [(nodes.paragraph)(*('', ''), *text)]
        else:
            return


class ExposeInternals(Transform):
    __doc__ = '\n    Expose internal attributes if ``expose_internals`` setting is set.\n    '
    default_priority = 840

    def not_Text(self, node):
        return not isinstance(node, nodes.Text)

    def apply(self):
        if self.document.settings.expose_internals:
            for node in self.document.traverse(self.not_Text):
                for att in self.document.settings.expose_internals:
                    value = getattr(node, att, None)
                    if value is not None:
                        node['internal:' + att] = value


class Messages(Transform):
    __doc__ = '\n    Place any system messages generated after parsing into a dedicated section\n    of the document.\n    '
    default_priority = 860

    def apply(self):
        unfiltered = self.document.transform_messages
        threshold = self.document.reporter.report_level
        messages = []
        for msg in unfiltered:
            if msg['level'] >= threshold and not msg.parent:
                messages.append(msg)

        if messages:
            section = nodes.section(classes=['system-messages'])
            section += nodes.title('', 'Docutils System Messages')
            section += messages
            self.document.transform_messages[:] = []
            self.document += section


class FilterMessages(Transform):
    __doc__ = '\n    Remove system messages below verbosity threshold.\n    '
    default_priority = 870

    def apply(self):
        for node in self.document.traverse(nodes.system_message):
            if node['level'] < self.document.reporter.report_level:
                node.parent.remove(node)


class TestMessages(Transform):
    __doc__ = '\n    Append all post-parse system messages to the end of the document.\n\n    Used for testing purposes.\n    '
    default_priority = 880

    def apply(self):
        for msg in self.document.transform_messages:
            if not msg.parent:
                self.document += msg


class StripComments(Transform):
    __doc__ = '\n    Remove comment elements from the document tree (only if the\n    ``strip_comments`` setting is enabled).\n    '
    default_priority = 740

    def apply(self):
        if self.document.settings.strip_comments:
            for node in self.document.traverse(nodes.comment):
                node.parent.remove(node)


class StripClassesAndElements(Transform):
    __doc__ = '\n    Remove from the document tree all elements with classes in\n    `self.document.settings.strip_elements_with_classes` and all "classes"\n    attribute values in `self.document.settings.strip_classes`.\n    '
    default_priority = 420

    def apply(self):
        if not (self.document.settings.strip_elements_with_classes or self.document.settings.strip_classes):
            return
        self.strip_elements = dict([(key, None) for key in self.document.settings.strip_elements_with_classes or []])
        self.strip_classes = dict([(key, None) for key in self.document.settings.strip_classes or []])
        for node in self.document.traverse(self.check_classes):
            node.parent.remove(node)

    def check_classes(self, node):
        if isinstance(node, nodes.Element):
            for class_value in node['classes'][:]:
                if class_value in self.strip_classes:
                    node['classes'].remove(class_value)
                if class_value in self.strip_elements:
                    return 1


class SmartQuotes(Transform):
    __doc__ = '\n    Replace ASCII quotation marks with typographic form.\n\n    Also replace multiple dashes with em-dash/en-dash characters.\n    '
    default_priority = 850
    nodes_to_skip = (
     nodes.FixedTextElement, nodes.Special)
    literal_nodes = (
     nodes.image, nodes.literal, nodes.math,
     nodes.raw, nodes.problematic)
    smartquotes_action = 'qDe'

    def __init__(self, document, startnode):
        Transform.__init__(self, document, startnode=startnode)
        self.unsupported_languages = set()

    def get_tokens(self, txtnodes):
        texttype = {True:'literal', 
         False:'plain'}
        for txtnode in txtnodes:
            nodetype = texttype[isinstance(txtnode.parent, self.literal_nodes)]
            yield (nodetype, txtnode.astext())

    def apply(self):
        smart_quotes = self.document.settings.smart_quotes
        if not smart_quotes:
            return
        try:
            alternative = smart_quotes.startswith('alt')
        except AttributeError:
            alternative = False

        document_language = self.document.settings.language_code
        lc_smartquotes = self.document.settings.smartquotes_locales
        if lc_smartquotes:
            smartquotes.smartchars.quotes.update(dict(lc_smartquotes))
        for node in self.document.traverse(nodes.TextElement):
            if isinstance(node, self.nodes_to_skip):
                pass
            else:
                if isinstance(node.parent, nodes.TextElement):
                    pass
                else:
                    txtnodes = [txtnode for txtnode in node.traverse(nodes.Text) if not isinstance(txtnode.parent, nodes.option_string)]
                    lang = node.get_language_code(document_language)
                    if alternative:
                        if '-x-altquot' in lang:
                            lang = lang.replace('-x-altquot', '')
                        else:
                            lang += '-x-altquot'
                    for tag in utils.normalize_language_tag(lang):
                        if tag in smartquotes.smartchars.quotes:
                            lang = tag
                            break
                    else:
                        if lang not in self.unsupported_languages:
                            self.document.reporter.warning(('No smart quotes defined for language "%s".' % lang),
                              base_node=node)
                        self.unsupported_languages.add(lang)
                        lang = ''

                    teacher = smartquotes.educate_tokens((self.get_tokens(txtnodes)), attr=(self.smartquotes_action),
                      language=lang)
                    for txtnode, newtext in zip(txtnodes, teacher):
                        txtnode.parent.replace(txtnode, nodes.Text(newtext, rawsource=(txtnode.rawsource)))

        self.unsupported_languages = set()
# uncompyle6 version 3.7.4
# Python bytecode 3.5 (3350)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /usr/local/lib/python3.5/dist-packages/HdlLib/SysGen/HDLEditor.py
# Compiled at: 2017-07-08 08:29:58
# Size of source mod 2**32: 56286 bytes
FSM_STYLE = 'OneBlock'
import sys, os, logging, datetime, math, unicodedata, re, collections
from HdlLib.SysGen.Assignment import AssignmentStatement
Generator = 'YANGO'
ExtensionDict = {'VHDL': '.vhd', 'Verilog': '.v'}
INDENT_VALUE = '\t'

def Header(Module, Title, Purpose, Desc, Issues='', Speed='', Area='', Tool='Xilinx ISE (13.1)', Rev=''):
    """
        Return string commented header.
        """
    Head = '\n----------------------------------------------------------------------------------------------------\n-- Actual File Name      = {MODULE}.vhd\n-- Title & purpose       = {TITLE} - {PURPOSE}\n-- Author                = Automaticaly generated by {GENERATOR} - made by Matthieu PAYET (ADACSYS) - matthieu.payet@adacsys.com\n-- Creation Date         = {TIME}\n-- Version               = 0.1\n-- Simple Description    = {DESCRIPTION}\n-- Specific issues       = {ISSUES}\n-- Speed                 = {SPEED}\n-- Area estimates        = {AREA}\n-- Tools (version)       = {TOOL}\n-- HDL standard followed = VHDL 2001 standard\n-- Revisions & ECOs      = {REV}\n----------------------------------------------------------------------------------------------------\n\t'
    return Head.format(GENERATOR=Generator, MODULE=Module, TITLE=Title, PURPOSE=Purpose, DESCRIPTION=Desc, ISSUES=Issues, SPEED=Speed, AREA=Area, TOOL=Tool, REV=Rev, TIME=datetime.datetime.now().strftime('%Y-%m-%d %H:%M'))


def Libraries(LibList):
    Headers = ''
    for Lib in list(set(LibList)):
        Headers += '\nlibrary {0};'.format(Lib)

    return Headers


def Packages(Library, PackageList, All=True):
    Code = ''
    for PackageName in PackageList:
        Code += Package(Library, PackageName, All)

    return Code + '\n'


def Package(Library, PackageName, All=True):
    if All:
        return '\nuse {0}.{1}.all;'.format(Library, PackageName)
    else:
        return '\nuse {0}.{1};'.format(Library, PackageName)


def AbsoluteAssignment(AssignmentList):
    """
        Return code for data flow absolute assignments.
        """
    Code = '\n' + '--' * 30
    Code += '\n-- Direct connections'
    Code += '\n' + '--' * 30
    for A in AssignmentList:
        Code += If(A, Comments=A.Desc())

    Code += '\n' + '--' * 30
    return Code


def Process(Name, SensitivList, Declarations, Content, Comments=''):
    """
        Return code for process declaration and insert specified content/declaration List.
        """
    Text = '\n' + CommentSeparator(Length=35)
    Text += '\n' + Comment('Process ' + Name + ' : ' + Comments)
    Text += '\n{0}: process('.format(Name) + ', '.join([str(x) for x in SensitivList]) + ')'
    if Declarations != '':
        Text += '\n' + Indent(Declarations)
    Text += '\nbegin'
    Text += '\n' + Indent(Content) + '\n'
    Text += '\nend process;\n'
    return Text


def SyncProcess(Name, Clock=None, Reset=None, Declarations='', SyncAssignments=[], InitAssignments=[], Comments='Synchronous process'):
    """
        Return code for synchronous process implementation.
        """
    SC = SyncCondition(ClockName=str(Clock), EveryEdge=False, Rising=True)
    SyncAssignments = AssignmentStatement(Assignee=SyncAssignments, Assignor=None, Cond=SC, Desc='')
    ASyncAssignments = AssignmentStatement(Assignee=SyncAssignments, Assignor=None, Cond=Equals(ValueA=Reset, ValueB=0, Size=1), Desc='')
    ASyncAssignments.Add(Assignee=InitAssignments, Assignor=None, Cond=None, Desc='')
    Content = If(ASyncAssignments, Comments='')
    return Process(Name, SensitivList=[Clock, Reset], Declarations=Declarations, Content=Content, Comments=Comments)


def SyncCondition(ClockName, EveryEdge=False, Rising=True):
    """
        Return code for clock synchronous condition.
        """
    if EveryEdge:
        return "{0}'event".format(ClockName)
    else:
        if Rising:
            return 'rising_edge({0})'.format(ClockName)
        return 'falling_edge({0})'.format(ClockName)


def Entity(Name, Generics=[], Ports=[], Comments='entity declaration'):
    Text = '\n' + '--' * 40
    Text += '\n-- ENTITY: {0} - {1}\n'.format(Name, Comments)
    Text += '--' * 40
    PortDeclaration = ''
    GenericDeclaration = ''
    if len(Generics):
        GenericDeclaration = '\ngeneric('
        while Generics.count([]):
            Generics.remove([])

        MGW = max([len(x.GetName()) for x in Generics])
        MGTW = max([len(x.GetType()) for x in Generics])
        for G in Generics:
            GenericDeclaration += Indent(Generic(('{0:' + str(MGW) + '}').format(G.Name), ('{0:' + str(MGTW) + '}').format(G.GetType()), G.GetValue()) + ';')

        GenericDeclaration = GenericDeclaration[:-1] + ');'
    if len(Ports):
        PortDeclaration = '\nport('
        MPW = max([len(x.GetName()) for x in Ports])
        for P in Ports:
            PortDeclaration += Indent(Port(('{0:' + str(MPW) + '}').format(P.GetName()), '{0:3}'.format(P.Direction), P.GetType())) + ';'

        PortDeclaration = PortDeclaration[:-1] + '\n);'
    return Text + '\nentity {0} is {1}{2}\nend entity {0};\n'.format(Name, Indent(GenericDeclaration), Indent(PortDeclaration))


def Component(Name, Generics=[], Ports=[], Comments='component declaration'):
    Text = '\n' + '--' * 40
    Text += '\n-- Component: {0} - {1}\n'.format(Name, Comments)
    Text += '--' * 40
    PortDeclaration = ''
    GenericDeclaration = ''
    if len(Generics):
        GenericDeclaration = '\ngeneric('
        while Generics.count([]):
            Generics.remove([])

        MGW = max([len(x.GetName()) for x in Generics])
        MGTW = max([len(x.GetType()) for x in Generics])
        for G in Generics:
            GenericDeclaration += Indent(Generic(('{0:' + str(MGW) + '}').format(G.Name), ('{0:' + str(MGTW) + '}').format(G.GetType()), G.GetValue()) + ';')

        GenericDeclaration = GenericDeclaration[:-1] + ');'
    if len(Ports):
        PortDeclaration = '\nport('
        MPW = max([len(x.GetName()) for x in Ports])
        for P in Ports:
            PortDeclaration += Indent(Port(('{0:' + str(MPW) + '}').format(P.GetName()), '{0:3}'.format(P.Direction), P.GetType())) + ';'

        PortDeclaration = PortDeclaration[:-1] + '\n);'
    return Text + '\ncomponent {0} is {1}{2}\nend component {0};\n'.format(Name, Indent(GenericDeclaration), Indent(PortDeclaration))


def Port(PortName, IO, PortType):
    return '\n{0} : {1} {2}'.format(PortName, IO, PortType)


def Generic(GenericName, GenericType, GenericValue):
    if GenericType.find('integer') != -1:
        Type = 'integer'
    else:
        Type = GenericType
    return '\n{0} : {1} := {2}'.format(GenericName, Type, GenericValue)


def Architecture(Name, Entity, Declarations='', Content='', Comments='Version 0'):
    """
        Return code for the architecture of a module in VHDL.
        An instance is made up of 5 data (in a list) : InstanceName, Module, SignalDict, GenericDict, comment.
        A signal is described by its SignalName, SignalType and InitialValue (in a list). 
        """
    Text = '\n' + '--' * 40
    Text += '\n-- ARCHITECTURE: {0} - {1}\n'.format(Name, Comments)
    Text += '--' * 40
    return Text + '\narchitecture {0} of {1} is\n{2}\n\nbegin\n{3}\n\nend architecture {0};\n\n'.format(Name, Entity, Indent(Declarations), Indent(Content))


def Constant(ConstName, ConstType, Value, Size=1):
    return '\nconstant {0} : {1} := {2};'.format(ConstName, NormalizeType(ConstType), Value)


def Instantiate(InstanceName, Module, Architecture=None, SignalDict={}, GenericDict={}, Comment='', FromLib='work'):
    """
        Generate code for instanciation (VHDL)
        """
    Text = ''
    if Comment != '':
        Text += '\n' + '-' * min(len(Comment) + 3, 35) + '\n-- ' + Comment + '\n' + '-' * min(len(Comment) + 3, 35)
    if not (FromLib is None or FromLib == ''):
        FromLib += '.'
        if not (Architecture is None or Architecture == ''):
            Text += '\n{0}: entity {3}{1}({2})'.format(InstanceName, Module, Architecture, FromLib)
        else:
            Text += '\n{0}: entity {2}{1}'.format(InstanceName, Module, FromLib)
    else:
        if not (Architecture is None or Architecture == ''):
            Text += '\n{0}: {1}({2})'.format(InstanceName, Module, Architecture)
        else:
            Text += '\n{0}: {1}'.format(InstanceName, Module)
    if len(GenericDict) > 0:
        Text += '\n\tgeneric map(\n\t\t'
        Links = []
        MaxWidth = max([len(x) for x in GenericDict])
        for GenericValue, Actual in list(GenericDict.items()):
            if isinstance(Actual, Signal):
                Links.append(('{0:' + str(MaxWidth) + '}').format(GenericValue) + ' => ' + str(Actual.GetName()))
            else:
                Links.append(('{0:' + str(MaxWidth) + '}').format(GenericValue) + ' => ' + str(Actual))

        Text += ',\n\t\t'.join(Links) + '\n\t\t)'
    if len(SignalDict) > 0:
        Text += '\n\tport map(\n\t\t'
        Links = []
        MaxWidth = max([len(x) for x in SignalDict])
        for SignalName, Actual in list(SignalDict.items()):
            if isinstance(Actual, Signal):
                Links.append(('{0:' + str(MaxWidth) + '}').format(SignalName) + ' => ' + str(Actual.GetName()))
            else:
                Links.append(('{0:' + str(MaxWidth) + '}').format(SignalName) + ' => ' + str(Actual))

        Text += ',\n\t\t'.join(Links) + '\n\t\t);'
    return Text + '\n\n'


def Case(SignalName, Assignment, Comments=''):
    """
        Return code for process declaration and insert specified content/declaration List.
                Assignment:  AssignmentStatement instance
        """
    Text = '\ncase {0} is '.format(SignalName) + Comment(Comments)
    NullAssignments = []
    for Condition, Statements in Assignment:
        if Condition is None:
            NullAssignments += Statements
            continue
            Text += Indent('\nwhen {0} =>'.format(Condition))
            for S in Statements:
                if isinstance(S, AssignmentStatement):
                    Text += Indent(If(S, Comments=S.Desc()), 2)
                elif not isinstance(S, dict):
                    logging.error('[HDL:Case] Statement must be a AssignmentStatement instance or a Statement dictionary.')
                    continue
                    A = S['Assignee']
                    if isinstance(A, AssignmentStatement):
                        Text += Indent(If(A, Comments=A.Desc()), 2)
                    else:
                        if not isinstance(A, Signal):
                            logging.error('[HDL:Case] Assignee must be a Signal or AssignmentStatement instance.')
                        else:
                            Text += Indent(A.Connect(S['Assignor']))

    if len(NullAssignments) == 0:
        Text += Indent('\nwhen others => null;')
    else:
        Text += Indent('\nwhen others =>')
        for S in NullAssignments:
            if isinstance(S, AssignmentStatement):
                Text += Indent(If(S, Comments=S.Desc()), 2)
            elif not isinstance(S, dict):
                logging.error('[HDL:Case] Statement must be a AssignmentStatement instance or a Statement dictionary.')
                continue
                A = S['Assignee']
                if isinstance(A, AssignmentStatement):
                    Text += Indent(If(A, Comments=A.Desc()), 2)
                else:
                    if not isinstance(A, Signal):
                        logging.error('[HDL:Case] Assignee must be a Signal or AssignmentStatement instance.')
                    else:
                        Text += Indent(A.Connect(S['Assignor']))

    Text += '\nend case;\n'
    return Text


def If(Assignment, Comments=''):
    """
        Return code for if/elsif/else declaration according to Condition/Action pairs in Allocation List.
        Else item is represented by a condition='None'.
        """
    Text = ''
    FirstItem = True
    if not isinstance(Assignment, AssignmentStatement):
        raise TypeError("[HDL:If] Statement must be a dictionary, not '{0}'.".format(type(Assignment)))
    for Condition, Statements in Assignment:
        if not Condition or str(Condition) == '':
            if FirstItem:
                for SDict in Statements:
                    if isinstance(SDict, dict):
                        A = SDict['Assignee']
                        if isinstance(A, Signal):
                            Text += A.Connect(SDict['Assignor'])
                        else:
                            if isinstance(A, AssignmentStatement):
                                Text += If(A, Comments=A.Desc())
                            else:
                                if isinstance(A, dict):
                                    Text += Case(A['Name'], A['Assignments'], A['Comments'])
                                else:
                                    logging.error("[HDL:If] Assignee must be a Signal or AssignmentStatement instance, not '{0}'.".format(type(A)))
                    else:
                        logging.error("[HDL:If] Statement must be a dictionary, not '{0}'.".format(type(SDict)))

            else:
                AList = []
                for SDict in Statements:
                    if isinstance(SDict, dict):
                        A = SDict['Assignee']
                        if isinstance(A, Signal):
                            AList.append('{0}'.format(A.Connect(SDict['Assignor'])))
                        else:
                            if isinstance(A, AssignmentStatement):
                                AList.append('{0}'.format(If(A, Comments=A.Desc())))
                            else:
                                logging.error("[HDL:If] Assignee must be a Signal or AssignmentStatement instance, not '{0}'.".format(type(SDict)))
                    else:
                        logging.error("[HDL:If] Statement must be a dictionary, not '{0}'.".format(type(SDict)))

                Text += '\nelse {0}'.format(Indent(''.join(AList)))
        elif FirstItem:
            AList = []
            for S in Statements:
                if isinstance(S, dict):
                    A = S['Assignee']
                    if isinstance(A, Signal):
                        A = AssignmentStatement(Assignee=A, Assignor=S['Assignor'], Cond=None, Desc='')
                        AList.append(If(A, Comments=''))
                    else:
                        if isinstance(A, AssignmentStatement):
                            AList.append(If(A, Comments=''))
                        else:
                            logging.error("[HDL:If] Assignee must be a Signal or AssignmentStatement instance, not '{0}'.".format(type(A)))
                else:
                    logging.error("[HDL:If] Statement must be a dictionary, not '{0}'.".format(type(S)))

            Text += '\nif {0} then {1}'.format(Condition, Indent(''.join(AList)))
            FirstItem = False
        else:
            AList = []
            for S in Statements:
                if isinstance(S, dict):
                    A = S['Assignee']
                    if isinstance(A, Signal):
                        A = AssignmentStatement(Assignee=A, Assignor=S['Assignor'], Cond=None, Desc='')
                        AList.append(If(A, Comments=''))
                    else:
                        if isinstance(A, AssignmentStatement):
                            AList.append(If(A, Comments=''))
                        else:
                            logging.error("[HDL:If] Assignee must be a Signal or AssignmentStatement instance, not '{0}'.".format(type(A)))
                else:
                    logging.error("[HDL:If] Statement must be a dictionary, not '{0}'.".format(type(S)))

            Text += '\nelsif {0} then {1}'.format(Condition, Indent(''.join(AList)))

    if not FirstItem:
        return Text + '\nend if;'
    else:
        return Text


def For(Name, Var, Start, Stop, Content, Comments=''):
    """
        Return code for 'for' declaration of a content.
        """
    Text = '\n{0}: for {1} in {2} to {3} generate {4}\nend generate {0};'.format(Name, Var, Start, Stop, Indent(Content))
    return '\n--' + Comments + Text


def LogicValue(Integer, BitLength):
    if Integer is None:
        Integer = 0
    if int(BitLength) < 2:
        if int(Integer) > 1:
            logging.error("[LogicValue] Bit value '{0}' for bit length '{1}' is higher than 1: set 0 instead.".format(Integer, int(BitLength)))
            return "'0'"
        else:
            return "'{0:b}'".format(int(Integer))
    else:
        if isinstance(Integer, str):
            I = ParseVHDLValue(Integer, int, {})
        else:
            I = int(Integer)
        return str('"{0:0' + str(int(BitLength)) + 'b}"').format(I)


def Equals(ValueA, ValueB=None, Size=1):
    if ValueB:
        if isinstance(ValueB, int):
            return '({0})'.format(Associate(ValueA, LogicValue(ValueB, Size), '='))
        else:
            return '({0})'.format(Associate(ValueA, ValueB, '='))
    else:
        if Size > 1:
            return '({0})'.format(Associate(ValueA, "(others=>'0')", '='))
        else:
            return '({0})'.format(Associate(ValueA, "'0'", '='))


def NotEquals(ValueA, ValueB=None, Size=1):
    if ValueB:
        if isinstance(ValueB, int):
            return '({0})'.format(Associate(ValueA, LogicValue(ValueB, Size), '/='))
        else:
            return '({0})'.format(Associate(ValueA, ValueB, '/='))
    else:
        if Size > 1:
            return '({0})'.format(Associate(ValueA, "(others=>'0')", '/='))
        else:
            return '({0})'.format(Associate(ValueA, "'0'", '/='))


def Associate(ValueA, ValueB, Symbol='='):
    return '{0} {1} {2}'.format(ValueA, Symbol, ValueB)


def Assign(S0, S1):
    if isinstance(S1, Signal):
        return '\n' + Associate(S0.GetName(), S1.GetName(), Symbol='<=') + ';'
    else:
        return '\n' + Associate(S0.GetName(), str(S1), Symbol='<=') + ';'


def Indent(Text, TabNB=1):
    """
        Add specified number of tabulation to each line of the text and return it.
        """
    if Text:
        Indented = str(Text).replace('\n', '\n' + INDENT_VALUE * TabNB)
        if Indented.startswith('\n'):
            return Indented
        else:
            return '\n' + INDENT_VALUE * TabNB + Indented
    else:
        return ''


def Comment(Text):
    if Text:
        CommmentedText = str(Text).replace('\n', '\n-- ')
        if not CommmentedText.startswith('--'):
            CommmentedText = '-- ' + CommmentedText
        return CommmentedText
    else:
        return ''


def CommentSeparator(Length=35):
    return '\n' + '-' * Length + '\n'


def NormalizeType(SignalType, Size, IsArray=False, Direction=None, UnConstrained=False):
    if SignalType == 'logic':
        try:
            Max = int(Size) - 1
        except:
            Max = str(Size) + '-1'

        try:
            S = int(Size)
            if S == 1:
                return 'std_logic'
            if S > 1:
                if UnConstrained is True:
                    return 'std_logic_vector'
                else:
                    return 'std_logic_vector({0} downto {1})'.format(str(Max), 0)
            else:
                raise NameError("Unable to recognize size format '{0}': aborted.".format(S))
        except:
            if UnConstrained is True:
                return 'std_logic_vector'
            else:
                return 'std_logic_vector({0} downto {1})'.format(Max, 0)

    else:
        if SignalType == 'numeric':
            return 'natural'
            try:
                Max = int(Size) - 1
                if Size == 1:
                    Vector = False
                else:
                    Vector = True
            except:
                Max = str(Size) + '-1'
                Vector = True

            if Vector:
                if UnConstrained is True or Size is None:
                    return SignalType
                else:
                    return SignalType + '({0} downto {1})'.format(str(Max), 0)
        else:
            if IsArray and Direction is not None:
                if UnConstrained is True:
                    return SignalType
                else:
                    return SignalType + '(0 downto 0)'
            else:
                return SignalType


def NewName(BaseName, NameList):
    """
        Return a Name that is unique to the list, based on the pattern Base-Name + number
        """
    NameList = list(NameList)
    NB = 0
    while NameList.count('{0}_{1}'.format(BaseName, NB)):
        NB += 1

    return '{0}_{1}'.format(BaseName, NB)


def PkgDeclaration(Name, Declaration=''):
    """
        Return code for Package declaration.
        """
    return '\npackage {0} is\n{1}\n\nend {0};'.format(Name, Indent(Declaration))


def PkgBody(Name, Body=''):
    """
        Return code for Package body.
        """
    return '\npackage body {0} is\n{1}\n\nend {0};'.format(Name, Indent(Body))


def Type(TName, TType):
    """
        Return code for type declaration.
        """
    return '\ntype {0} is {1};'.format(TName, TType)


def SubType(TName, TType):
    """
        Return code for type declaration.
        """
    return '\nsubtype {0} is {1};'.format(TName, TType)


def ArrayType(Name, Size, SubType, ArraySize=None, CustomElmts=[]):
    """
        Return code for array type declaration.
        """
    if len(CustomElmts) > 0:
        return '\ntype {0} is ({1});'.format(Name, ', '.join(map(str, CustomElmts)))
    if ArraySize is not None:
        return '\ntype {0} is array(natural range 0 to {1}-1) of {2};'.format(Name, ArraySize, NormalizeType(SubType, Size))
    if SubType == 'numeric':
        if Size != None:
            return '\ntype {0} is array(natural range 0 to {1}-1) of {2};'.format(Name, Size, NormalizeType(SubType, Size))
        else:
            return '\ntype {0} is array(natural range <>) of {1};'.format(Name, NormalizeType(SubType, Size))
    else:
        return '\ntype {0} is array(natural range <>) of {1};'.format(Name, NormalizeType(SubType, Size))


def ParseVHDLValue(Value, Type, Vars):
    """
        Return a python variable corresponding to a given VHDL value.
        """
    Val = Value.replace(' ', '')
    if Val.startswith('x"'):
        return Type(Val[2:-1], 16)
    if Val.startswith('o"'):
        return Type(Val[2:-1], 8)
    if Val.startswith('"'):
        return Type(Val[1:-1], 2)
    if Val.startswith("'"):
        return Type(Val[1:-1], 2)
    Regex = re.match('([0-9]+)', Value)
    if Regex:
        try:
            return Type(Regex.group(0))
        except:
            pass

    else:
        Evaluation = eval(str(Value), Vars)
        if Evaluation is None:
            return Type(0)
        else:
            return Type(str(Evaluation))


def Access(NewType, Accessed):
    """
        Return code for VHDL Access declaration of type pointer.
        """
    return '\ntype {0} is access {1};'.format(NewType, Accessed)


def FSM_3Blocks(StateGraph, Name, Clock, Reset):
    """
        Return code for VHDL FSM.
        """
    Declaration = ''
    Content = ''
    Nodes = StateGraph.Nodes()
    TypeName = 'STATE_{0}'.format(Name.upper())
    FuturState = Signal('FuturState_{0}_i'.format(Name), Direction='IN', Size=1, Type=TypeName, InitVal='STATE_INIT', IsArray=False)
    CurrentState = Signal('CurrentState_{0}_i'.format(Name), Direction='IN', Size=1, Type=TypeName, InitVal='STATE_INIT', IsArray=False)
    Declaration += ArrayType(TypeName, 0, SubType=None, ArraySize=None, CustomElmts=Nodes)
    Declaration += FuturState.Declare(Constant=False, UnConstrained=True)
    Declaration += CurrentState.Declare(Constant=False, UnConstrained=True)
    SA = AssignmentStatement(Assignee=CurrentState, Assignor=FuturState, Cond=None, Desc='SyncAssignments')
    IA = AssignmentStatement(Assignee=CurrentState, Assignor=None, Cond=None, Desc='InitAssignments')
    Content += SyncProcess('FSMStateRegister_{0}'.format(Name), Clock=Clock, Reset=Reset, Declarations='', SyncAssignments=SA, InitAssignments=[IA] + StateGraph.GetResetAssignments(), Comments='FSM State Register')
    FSMAssignment = AssignmentStatement(Desc='FSM State assignment')
    SensitivityList = []
    for Node in sorted(Nodes, key=lambda N: N.Position):
        StateAssignments = AssignmentStatement()
        FSMAssignment.Add(Assignee=StateAssignments, Assignor=None, Cond=Node.GetName(), Desc='')
        for EC in list(Node.GetEnteringCondition().values()):
            if not EC:
                pass
            else:
                for S in EC.GetSignals():
                    if S.Name not in [x.Name for x in SensitivityList]:
                        SensitivityList.append(S)

        for A in Node.GetAssignments():
            StateAssignments.Add(Assignee=A, Assignor=None, Cond=None, Desc='')

        ElseCond = None
        for Successor in StateGraph.Graph.successors(Node):
            EC = Successor.GetEnteringCondition()[Node]
            if EC is None:
                ElseCond = Successor
            else:
                StateAssignments.Add(Assignee=FuturState, Assignor=str(Successor), Cond=EC, Desc='')

        if ElseCond:
            ECAssignment = StateAssignments.Add(Assignee=FuturState, Assignor=str(ElseCond), Cond=None, Desc='')

    CaseContent = Case(FuturState.GetName(), FSMAssignment, Comments='Assignments for FSM FuturState')
    Content += Process('FSMStateAssignment_{0}'.format(Name), [CurrentState] + SensitivityList, Declarations='', Content=CaseContent, Comments='FSM State assignments')
    return (
     Declaration, Content)


def FSM_OneBlock(StateGraph, Name, Clock, Reset):
    """
        Return code for VHDL FSM.
        """
    Declaration = ''
    Content = ''
    Nodes = StateGraph.Nodes()
    TypeName = 'STATE_{0}'.format(Name.upper())
    CurrentState = Signal('CurrentState_{0}_i'.format(Name), Direction='IN', Size=1, Type=TypeName, InitVal='STATE_INIT', IsArray=False)
    Declaration += ArrayType(TypeName, 0, SubType=None, ArraySize=None, CustomElmts=Nodes)
    Declaration += CurrentState.Declare(Constant=False, UnConstrained=True)
    for Sig in StateGraph.GetUsedSignals():
        Declaration += Sig.Declare(Constant=False, UnConstrained=False)

    FSMAssignment = AssignmentStatement(Desc='FSM State assignment')
    for Node in sorted(Nodes, key=lambda N: N.Position):
        StateAssignments = AssignmentStatement()
        for A in Node.GetAssignments():
            StateAssignments.Add(Assignee=A, Assignor=None, Cond=None, Desc='')

        ElseCond = None
        for Successor in StateGraph.Graph.successors(Node):
            EC = Successor.GetEnteringCondition()[Node]
            if EC is None:
                ElseCond = Successor
            else:
                StateAssignments.Add(Assignee=CurrentState, Assignor=str(Successor), Cond=EC, Desc='')
                TransAssignments = Node.GetTransitionAssignments()
                if len(TransAssignments):
                    for A in TransAssignments:
                        StateAssignments.Add(Assignee=A, Assignor=None, Cond=EC, Desc='')

        if ElseCond:
            ECAssignment = StateAssignments.Add(Assignee=CurrentState, Assignor=str(ElseCond), Cond=None, Desc='')
        FSMAssignment.Add(Assignee=StateAssignments, Assignor=None, Cond=Node.GetName(), Desc='')

    CaseDict = {'Name': CurrentState.GetName(), 'Assignments': FSMAssignment, 'Comments': 'Assignments for FSM FuturState'}
    CaseAssignments = AssignmentStatement(Assignee=CaseDict, Cond=None)
    IA = AssignmentStatement(Assignee=CurrentState, Assignor=None, Cond=None, Desc='InitAssignments')
    Content += SyncProcess('FSMStateAssignment_{0}'.format(Name), Clock=Clock, Reset=Reset, Declarations='', SyncAssignments=CaseAssignments, InitAssignments=[IA] + StateGraph.GetResetAssignments(), Comments='FSM State assignments')
    return (
     Declaration, Content)


def FSM_2Blocks(StateGraph, Name, Clock, Reset):
    """
        Return code for VHDL FSM.
        """
    Declarations = ''
    Content = ''
    Nodes = StateGraph.Nodes()
    TypeName = 'STATE_{0}'.format(Name.upper())
    CurrentState = Signal('CurrentState_{0}_i'.format(Name), Direction='IN', Size=1, Type=TypeName, InitVal='STATE_INIT', IsArray=False)
    Declarations += ArrayType(TypeName, 0, SubType=None, ArraySize=None, CustomElmts=Nodes)
    Declarations += CurrentState.Declare(Constant=False, UnConstrained=True)
    for Sig in StateGraph.GetUsedSignals():
        Declarations += Sig.Declare(Constant=False, UnConstrained=False)

    FSMAssignment = AssignmentStatement(Desc='FSM State assignment')
    for Node in sorted(Nodes, key=lambda N: N.Position):
        StateAssignments = AssignmentStatement()
        if len(StateGraph.CounterSignals) != 0:
            for A in Node.GetAssignments(ReqList=StateGraph.CounterSignals):
                StateAssignments.Add(Assignee=A, Assignor=None, Cond=None, Desc='')

        ElseCond = None
        for Successor in StateGraph.Graph.successors(Node):
            EC = Successor.GetEnteringCondition()[Node]
            if EC is None:
                ElseCond = Successor
            else:
                StateAssignments.Add(Assignee=CurrentState, Assignor=str(Successor), Cond=EC, Desc='')

        if ElseCond:
            ECAssignment = StateAssignments.Add(Assignee=CurrentState, Assignor=str(ElseCond), Cond=None, Desc='')
        FSMAssignment.Add(Assignee=StateAssignments, Assignor=None, Cond=Node.GetName(), Desc='')

    CaseDict = {'Name': CurrentState.GetName(), 'Assignments': FSMAssignment, 'Comments': 'Assignments for FSM FuturState'}
    CaseAssignments = AssignmentStatement(Assignee=CaseDict, Cond=None)
    IA = AssignmentStatement(Assignee=CurrentState, Assignor=None, Cond=None, Desc='InitAssignments')
    Content += SyncProcess('FSMStateAssignment_{0}'.format(Name), Clock=Clock, Reset=Reset, Declarations='', SyncAssignments=CaseAssignments, InitAssignments=[IA], Comments='FSM State assignments')
    SensitivityList = []
    FSMAssignment = AssignmentStatement(Desc='{0} FSM signal assignment'.format(Name))
    for RA in StateGraph.GetResetAssignments():
        FSMAssignment.Add(Assignee=RA, Assignor=None, Cond=None, Desc='')

    for Node in sorted(Nodes, key=lambda N: N.Position):
        StateAssignments = AssignmentStatement()
        for A in Node.GetAssignments(SkipList=StateGraph.CounterSignals):
            StateAssignments.Add(Assignee=A, Assignor=None, Cond=None, Desc='')

        for EC in list(Node.GetEnteringCondition().values()):
            if not EC:
                pass
            else:
                TransAssignments = Node.GetTransitionAssignments()
                if len(TransAssignments):
                    for A in TransAssignments:
                        StateAssignments.Add(Assignee=A, Assignor=None, Cond=EC, Desc='')

                for S in EC.GetSignals():
                    if S.Name not in [x.Name for x in SensitivityList] and S.Name not in StateGraph.CounterSignals:
                        SensitivityList.append(S)

        FSMAssignment.Add(Assignee=StateAssignments, Assignor=None, Cond=Node.GetName(), Desc='')

    Content += Process(Name='FSMSignalAssignments_{0}'.format(Name), SensitivList=[
     CurrentState] + SensitivityList, Declarations='', Content=Case(CurrentState.GetName(), FSMAssignment, Comments='Assignments for FSM FuturState'), Comments='Signal assignments according to {0} FSM state.'.format(Name))
    return (
     Declarations, Content)


class Signal:
    __doc__ = '\n\tObject that contains basic parameters for a signal definition.\n\t'

    def __init__(self, Item, Direction='IN', Size=1, Type=None, InitVal=0, CurValue=0, IsArray=False, GenericSize=None, Vars={}):
        if isinstance(Item, Signal):
            self.Name = Item.Name
            self.Direction = Item.Direction
            self.Size = Item.Size
            self.GenericSize = Item.GenericSize
            self.Type = Item.Type
            self.InitVal = Item.InitVal
            self.Index = Item.Index
            self.IsArray = Item.IsArray
            self.Value = Item.Value
            self.TestCond = Item.TestCond
        else:
            if isinstance(Item, list) or isinstance(Item, tuple):
                if len(Item) == 0:
                    raise TypeError('HDLEditor.Signal cannot be built from an empty list.')
                for Elmt in Item:
                    if not isinstance(Elmt, Signal):
                        raise TypeError("HDLEditor.Signal cannot be built from list of non signal instances (received '{0}').".format(Item))

                TEMP = Item[0]
                for Elmt in Item[1:]:
                    TEMP = TEMP.Concatenate(Elmt, Vars=Vars)

                self.Name = TEMP.Name
                self.Direction = TEMP.Direction
                self.Size = TEMP.Size
                self.GenericSize = TEMP.GenericSize
                self.Type = TEMP.Type
                self.InitVal = TEMP.InitVal
                self.Index = TEMP.Index
                self.IsArray = TEMP.IsArray
                self.Value = TEMP.Value
                self.TestCond = TEMP.TestCond
            else:
                self.Name = Item
                if Direction:
                    self.Direction = Direction.upper()
                else:
                    self.Direction = None
                self.Size = Size
                self.GenericSize = self.Size if GenericSize is None else GenericSize
                self.Index = None
                self.Type = Type
                self.IsArray = IsArray
                if IsArray and not isinstance(InitVal, list) and InitVal is not None:
                    logging.warning("[Signal '{2}'] Initial value ('{0}') of array signal '{1}' is not a list.".format(InitVal, self.Name, self))
                self.InitVal = InitVal
                self.Value = self.ConvertType(0, TypeOfValue='natural') if CurValue is None else self.ConvertType(CurValue, TypeOfValue=None)
                if self.IsArray and self.Size == 1:
                    self.SetIndex(0)
                self.TestCond = OPSYMBOL_DICT['__eq__']

    def GetName(self):
        if self.Index != None or self.IsArray and self.Size == 1:
            if isinstance(self.Index, list):
                start, stop = self.Index
                return self.Name + '({0} downto {1})'.format(str(stop), start)
            return self.Name + '({0})'.format(self.Index)
        else:
            return self.Name.replace('.', '_')

    def AVAName(self):
        """
                Return signal name respecting AVA format.
                """
        if self.Index != None or self.IsArray and self.Size == 1:
            if isinstance(self.Index, list):
                start, stop = self.Index
                return self.Name + '({0}:{1})'.format(str(stop), start)
            return self.Name + '({0})'.format(self.Index)
        else:
            if self.Size > 1:
                return self.Name + '({0}:{1})'.format(self.Size - 1, 0)
            return self.Name

    def GetSize(self, Full=False, Vars={}):
        if Full:
            if isinstance(self.GetType(), str):
                return self.Size
            else:
                return self.Size * self.Type.GetSize()
        else:
            try:
                return int(eval(self.Size, Vars.copy()))
            except:
                return self.Size

    def GetType(self, UnConstrained=False):
        Type = None
        if self.Type:
            if isinstance(self.Type, Signal):
                if self.GenericSize is None:
                    logging.error("Signal array '{0}' has no size.".format(self.Name))
                    Type = 'ARRAY{0}_{1}'.format(1, self.Type.Type)
                else:
                    Type = 'ARRAY{0}_{1}'.format(self.GenericSize, self.Type.Type)
            else:
                Type = NormalizeType(self.Type, self.GenericSize, IsArray=self.IsArray, Direction=self.Direction, UnConstrained=UnConstrained)
        else:
            Type = NormalizeType('logic', self.GenericSize, IsArray=False, Direction=self.Direction, UnConstrained=UnConstrained)
        return Type

    def SetValue(self, Val, TypeOfValue=None):
        """
                Set Value attribute (eventually with type conversion).
                """
        self.Value = self.ConvertType(Val, TypeOfValue=TypeOfValue)
        return self.Value

    def GetValue(self, Val=None, WriteBits=False, Vars={}):
        """
                return HDL format for Value Val or self.InitVal.
                """
        if self.Value is None:
            self.Value = self.InitVal
        if isinstance(self.Index, list):
            Size = eval(str(self.Index[1]) + '+1-' + str(self.Index[0]), Vars)
        else:
            if isinstance(self.Index, int):
                Size = 1
            else:
                if self.Size is None:
                    Size = 32
                else:
                    Size = eval(str(self.Size), Vars)
        if self.Type and self.Type.startswith('STATE'):
            if isinstance(Val, str):
                return Val
            logging.warning("FSM State Value '{0}' is not of string type.".format(Val))
            return str(self.InitVal)
        BaseType = self.GetType().split('(')[0].split()[0]
        if Val is None:
            if str(self.Value).lower() != 'open':
                if not BaseType.lower().startswith('std_logic'):
                    if isinstance(self.Value, list) or isinstance(self.Value, tuple):
                        if self.Type.lower() == 'real':
                            return str(float(self.Value[0]))
                        else:
                            return self.Value[0]
                    else:
                        if self.Type.lower() == 'real':
                            return str(float(self.Value))
                        else:
                            return self.Value
                else:
                    if isinstance(self.Value, list) or isinstance(self.Value, tuple):
                        LogicValue(self.Value[0], Size)
                    else:
                        return LogicValue(self.Value, Size)
            else:
                if not BaseType.lower().startswith('std_logic'):
                    return 0
                else:
                    if int(Size) < 2:
                        return "'0'"
                    if WriteBits:
                        return '"{0}"'.format('0' * int(Size))
                    return "(others=>'0')"
        elif isinstance(Val, Signal):
            return Val.GetValue(WriteBits=WriteBits, Vars=Vars)
        if Val == 0:
            if not BaseType.lower().startswith('std_logic'):
                if self.Type.lower() == 'real':
                    return str(float(Val))
                else:
                    return Val
            else:
                if int(Size) < 2:
                    return "'0'"
                else:
                    if WriteBits:
                        return '"{0}"'.format('0' * int(Size))
                    return "(others=>'0')"
        elif not BaseType.lower().startswith('std_logic') and BaseType not in ('integer',
                                                                               'natural'):
            if isinstance(Val, list) or isinstance(Val, tuple):
                return '(' + ','.join([str(x) for x in Val]) + ')'
            else:
                if isinstance(self.InitVal, list) or isinstance(self.InitVal, tuple):
                    return '(' + ','.join([str(x) for x in self.InitVal]) + ')'
                return Val
        try:
            int(Val)
            if not BaseType.lower().startswith('std_logic'):
                return Val
            else:
                return LogicValue(int(Val), Size)
        except:
            return Val

    def SetInitialValue(self, InitVal):
        """
                Change Initial value of signal.
                """
        self.InitVal = InitVal
        return self.InitVal

    def GetInitialValue(self):
        """
                Return Initial value of signal.
                """
        return self.InitVal

    def SetIndex(self, Min, Max=None):
        """
                Change signal name with it's VHDL indexation representation.
                """
        if Min is None:
            self.Index = None
            if self.IsArray and self.Size == 1:
                self.SetIndex(0)
        else:
            if isinstance(Min, (slice,)):
                self.Index = [
                 Min.stop, Min.start - 1]
            else:
                if Max is None:
                    self.Index = Min
                else:
                    self.Index = [
                     Min, Max]
        return self

    def InverseDirection(self):
        """
                Change 'IN' into 'OUT' and conversely.
                """
        if self.Direction == 'IN':
            self.Direction = 'OUT'
        elif self.Direction == 'OUT':
            self.Direction = 'IN'

    def Connect(self, SignalX=None, UseValue=False, ValCondPairs=[]):
        """
                Generate code for 2 signals connection (VHDL)
                """
        if len(ValCondPairs):
            Drivers = []
            for Val, Cond in ValCondPairs:
                Drivers.append('{0} when {1}'.format(Val, Cond))

            Sep = '\n' + ' ' * (len(SignalA) + 4)
            Driver = Sep.join(Drivers)
        else:
            if SignalX != None:
                if isinstance(SignalX, Signal):
                    if UseValue:
                        Driver = SignalX.GetValue()
                    else:
                        Driver = SignalX.GetName()
                else:
                    Driver = self.GetValue(SignalX)
            else:
                if UseValue:
                    Driver = self.GetValue()
                else:
                    Driver = self.GetValue(self.InitVal)
        return '\n' + Associate(self.GetName(), Driver, '<=') + ';'

    def Parameters(self):
        """
                return a list with parameters according to HDLEditor signal representation.
                """
        return [
         self.GetName(), self.GetType(), self.InitVal, self.Size]

    def Driven(self, Value):
        """
                Signal connection: Example:"S0.Driven(S1+S2)"
                """
        return Connect(self.Name, str(Value))

    def Declare(self, Constant=False, UnConstrained=False, AvailableParam=None):
        """
                return Signal declaration code.
                """
        if Constant:
            Text = '\nconstant '
        else:
            Text = '\nsignal '
        Name = self.Name
        if self.InitVal is None:
            if Constant is True:
                logging.error('Constant has no initial value: bad declaration.')
            Text += '{0} : {1};'.format(Name, self.GetType(UnConstrained=UnConstrained))
        else:
            InitValue = self.GetValue(self.InitVal)
            if str(self.InitVal).lower() == 'open' or InitValue == '':
                if Constant is True:
                    logging.error('Constant has no initial value: bad declaration.')
                Text += '{0} : {1};'.format(Name, self.GetType(UnConstrained=UnConstrained))
            else:
                Text += '{0} : {1} := {2};'.format(Name, self.GetType(UnConstrained=UnConstrained), InitValue)
        return Text

    def MapConstants(self, Mapping={}, Vars={}):
        """
                Replace generics by their mapping counterparts.
                """
        if len(Mapping) == 0 or self.GenericSize is None:
            return
            try:
                int(self.GenericSize)
                return
            except:
                for Formal, ActualCond in Mapping.items():
                    FullNames = []
                    ConcatList, Condition, Vars = ActualCond
                    for InstName, SigName, AIndex in ConcatList:
                        BaseName = SigName if InstName == '' or InstName is None else '_'.join([InstName, SigName])
                        if AIndex is None:
                            FullNames.append(BaseName)
                        else:
                            FullNames.append(BaseName + '({0})'.format(AIndex))

                    ActualName = ' & '.join(FullNames)
                    Decomposed = re.split('(\\W)', self.GenericSize)
                    for i, Item in enumerate(Decomposed):
                        if Item == Formal:
                            Decomposed[i] = ActualName

                    self.GenericSize = ''.join(Decomposed)

    def AliasOf(self, Sig):
        """
                Declare Signal as alias of another signal.
                """
        return '\nalias {0} is {1};'.format(self.Name, Sig.GetName())

    def __getitem__(self, index):
        if isinstance(index, int) or isinstance(index, str):
            Sig = self.Copy().SetIndex(index)
            return Sig
        if isinstance(index, (slice, range)):
            Start, Stop, Step = index.start, index.stop, index.step
            if Start == Stop:
                return self.__getitem__(Start)
            Sig = Signal(self.GetName(), self.Direction, str(Start) + '+1-' + str(Stop), Type=None, InitVal=0)
            Sig.SetIndex(Stop, Start)
            return Sig
        raise TypeError('index must be int or slice')

    def __add__(self, SignalName):
        """
                Signal concatenation(if logic) or addition(if numeric): "S0 + S1"
                """
        return self.Concatenate(SignalName)

    def Concatenate(self, Sig, Vars={}):
        """
                Return a new signal object which name is the VHDL representation
                of signals concatenation.
                """
        NewSig = self.Copy()
        NewSig = self.SetIndex(None)
        if isinstance(Sig, Signal):
            SignalName = Sig.GetName()
            Val1, Val2 = self.GetValue(Vars=Vars), Sig.GetValue(Vars=Vars)
            try:
                Val1, Val2 = Val1[1:].replace('"', ''), Val2[1:].replace('"', '')
            except:
                pass

            Template = '{0:0' + str(self.GetSize(Vars=Vars)) + 'b}{1:0' + str(Sig.GetSize(Vars=Vars)) + 'b}'
            NewSig.Size = str(self.Size) + '+' + str(Sig.Size)
            NewSig.SetValue(int(Template.format(int(Val1, 2), int(Val2, 2)), 2))
        else:
            if isinstance(Sig, str):
                SignalName = Sig
                raise TypeError("Signal '{0}' cannot be a string object.")
            else:
                raise TypeError("Signal '{0}' is not a string or a Signal object.")
                return
        NewSig.Name = '{0} & {1}'.format(self.GetName(), SignalName)
        return NewSig

    def Copy(self):
        return Signal(self)

    def SetTestCondition(self, TestCond='__eq__'):
        """
                Set the test comparator type. Only used in Test() method.
                """
        self.TestCond = OPSYMBOL_DICT[TestCond]

    def ConvertType(self, Value, TypeOfValue=None):
        """
                Format value so as to fit the signal type.
                """
        if TypeOfValue == 'logic':
            if self.Type == 'logic':
                return Value
            else:
                if self.Type == 'numeric':
                    return 'TO_INTEGER(UNSIGNED({0}))'.format(Value)
                return Value
        else:
            if TypeOfValue == 'numeric':
                if self.Type == 'logic':
                    return Value
                else:
                    if self.Type == 'numeric':
                        return "STD_LOGIC_VECTOR(TO_UNSIGNED({0}, {1}'length))".format(Value, self.Name)
                    return Value
            else:
                return Value

    def Test(self):
        """
                return code for value test. 
                Value attribute must be set before calling this method.
                """
        if isinstance(self.Value, str):
            return '{0}{1}{2}'.format(self.Name, self.TestCond, self.Value)
        else:
            SigSize = self.GetSize()
            if SigSize > 1:
                return ('{0}{1}"{2:0' + str(SigSize) + 'b}"').format(self.Name, self.TestCond, self.Value)
            if self.Value not in (0, 1):
                logging.error("{0}'s value: {1}".format(self, self.Value))
                raise TypeError
            return "{0}{1}'{2}'".format(self.Name, self.TestCond, self.Value if self.Value < 2 else 1)

    def __str__(self):
        """
                Return string representation.
                """
        return self.GetName()

    def __repr__(self):
        """
                Return object representation.
                """
        return 'HDLEditor.Signal(Item={Item}, Direction={Direction}, Size={Size}, Type={Type}, InitVal={InitVal}, CurValue={CurValue}, IsArray={IsArray}, GenericSize={GenericSize})'.format(Item=self.Name, Direction=self.Direction, Size=self.Size, Type=self.Type, InitVal=self.InitVal, CurValue=self.Value, IsArray=self.IsArray, GenericSize=self.GenericSize) + '>'

    def __len__(self):
        """
                Return size of signal.
                """
        return self.Size

    def __lt__(self, Other):
        """
                'lower than' comparison.
                """
        SelfName = self.GetName()
        if min(SelfName, Other.GetName()) == SelfName:
            return True
        else:
            return False


OPSYMBOL_DICT = {'__setitem__': None, 
 '__getitem__': None, 
 '__lt__': '<', 
 '__le__': '<=', 
 '__eq__': '=', 
 '__ne__': '/=', 
 '__gt__': '>', 
 '__ge__': '>=', 
 '__add__': '+', 
 '__sub__': '-', 
 '__mul__': '*', 
 '__and__': ' and ', 
 '__or__': ' or ', 
 '__init__': None}

def Connect(SignalA, SignalB=None, ValCondPairs=[], Size=1):
    """
        Generate code for 2 signals connection (VHDL)
        """
    if len(ValCondPairs):
        Drivers = []
        for Val, Cond in ValCondPairs:
            Drivers.append('{0} when {1}'.format(Val, Cond))

        Sep = '\n' + ' ' * (len(SignalA) + 4)
        Driver = Sep.join(Drivers)
    else:
        if SignalB:
            Driver = SignalB
        else:
            Driver = LogicValue(0, Size)
    return '\n' + Associate(SignalA, Driver, '<=') + ';'


def NormalizeText(text):
    """
        Return a normalized format for the input text.
        """
    return unicodedata.normalize('NFKD', str(text)).encode('ASCII', 'ignore')


def GetTBProcess(DUTName):
    """
        Return VHDL code for the read of textio stimuli file.
        """
    return '\n-----------------------------------------------------------------------------\n-----------------------------------------------------------------------------\nTEST: process\n\t--file TestFile : text is in "./stimValues.txt";\n\tfile TestFile : text open read_mode is "./stimValues.txt";\n\tvariable L           : line;\n\tvariable TimeVector  : time;\n\tvariable R           : integer;--real\n\tvariable good_number : boolean := True;\n\tvariable index       : integer;\n\tvariable TooMuchStim : boolean := True;\n\nbegin  -- process Test\n\n\t--WRITE_STRING (OUTPUT, "*** {0} test ***");\n\twrite(output, "*** Start {0} test ***");\n\n\twhile not endfile(TestFile) loop\n\t\treadline(TestFile, L);\n\t\t--writeline(output, L);\n\t\n\t\tread(L, R, GOOD => good_number);-- read the time from the beginning of the line\n\t\tif not good_number then\n\t\t\twrite(output, "Skip line:");\n\t\t\twriteline(output, L);\n\t\tend if;\n\t\tnext when not good_number;-- skip the line if it doesn\'t start with a number\n\n\t\tTimeVector := natural(R) * 1 ns; -- convert real number to time\n\t\tif (now < TimeVector) then -- wait until vector time\n\t\t\twait for TimeVector - now;\n\t\t\twrite(output, "Time : " & integer\'image(R));\n\t\tend if;\n\t\tindex := NbStimuli-1;\n\t\tTooMuchStim := False;\n\t\t--write(output, "NbStimuli=" & integer\'image(NbStimuli));\n\n\t\t--For each caracter in line:\n\t\tfor i in L\'range loop\n\t\t\tif index<0 then -- wait until vector time\n\t\t\t\tif L(i)=\'0\' or  L(i)=\'1\' or L(i)=\'H\' or  L(i)=\'L\' or L(i)=\'X\' then\n\t\t\t\t\twrite(output, "Error parsing line:");\n\t\t\t\t\twriteline(output, L);\n\t\t\t\t\tassert false report "Given stimuli bit number exceeds the number of stimuli signals." severity ERROR;\n\t\t\t\t\texit;\n\t\t\t\tend if;\n\t\t\tend if;\n\t\t\t--write(output, "index : " & integer\'image(index));\n\t\t\t--write(output, "Stimuli length : " & integer\'image(Stimuli\'length));\n\t\t\tcase L(i) is\n\t\t\t\twhen \'0\' => -- Drive 0\n\t\t\t\t\tStimuli(index) <= \'0\';\n\t\t\t\twhen \'1\' => -- Drive 1\n\t\t\t\t\tStimuli(index) <= \'1\';\n\t\t\t\twhen \'H\' => -- Test for 1\n\t\t\t\t\tassert Stimuli(index) = \'1\';\n\t\t\t\twhen \'L\' => -- Test for 0\n\t\t\t\t\tassert Stimuli(index) = \'0\';\n\t\t\t\twhen \'X\' => -- Don\'t care\n\t\t\t\t\tnull;\n\t\t\t\twhen \' \' | HT => -- Skip white space\n\t\t\t\t\tnext;\n\t\t\t\twhen others =>\n\t\t\t\t\t-- Illegal character\n\t\t\t\t\tassert false report "Illegal char in vector file: " & L(i);\n\t\t\t\texit;\n\t\t\tend case;\n\t\t\tindex := index-1;\n\t\tend loop;  -- end of line\n\n\tend loop;  -- end of file\n\nassert false report "*** Test complete ***";\nwait;\n\nend process TEST;'.format(DUTName)


def ReplaceDict(Item, AvailableDict={}):
    """
        Replace each occurence of a parameter by its driver.
        """
    for Key, Val in AvailableDict.items():
        if not Item is None:
            if isinstance(Item, (int, float)):
                pass
            else:
                if isinstance(Item, (list, tuple)):
                    pass
                else:
                    Item = Item.replace(Key, str(AvailableDict[Key]))

    return Item


if __name__ == '__main__':
    HDLTopFile = os.path.abspath('./HDLEditor/NOC.vhd')
    toVHDL.name = 'NOC'
    toVHDL(*HDL2myHDL(HDLTopFile))
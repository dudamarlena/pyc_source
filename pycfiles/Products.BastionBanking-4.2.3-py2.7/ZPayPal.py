# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-x86_64/egg/Products/BastionBanking/Merchants/PayPal/ZPayPal.py
# Compiled at: 2015-07-18 19:38:10
import os, logging, re
from urllib import urlencode, unquote
from DateTime import DateTime
import AccessControl
from AccessControl import ClassSecurityInfo
from AccessControl.Permissions import view
from OFS.ObjectManager import ObjectManager
from OFS.PropertyManager import PropertyManager
from OFS.SimpleItem import SimpleItem
from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate
from Products.PageTemplates.PageTemplateFile import PageTemplateFile
from Products.BastionBanking.ConnectionMgr import Transport
import returncode
from Products.BastionBanking.interfaces.BastionMerchantInterface import IBastionMerchant
from Products.BastionBanking.BastionPayment import BastionPayment
from Products.BastionBanking.Exceptions import ProcessingFailure
from Products.BastionBanking.Permissions import operate_bastionbanking
from Acquisition import aq_base
from Products.CMFCore.utils import getToolByName
from zope.interface import implements
logger = logging.getLogger('BastionBanking.ZPayPal')
TENMINUTES = 10.0 * 60 / 86400
PAYPAL_SUPPORTED_CURRENCIES = (
 'USD', 'JPY', 'GBP', 'EUR', 'CAD', 'AUD')
PAYPAL_URL = 'https://www.paypal.com/cgi-bin/webscr'
PAYPAL_SANDBOX_URL = 'https://www.sandbox.paypal.com/cgi-bin/webscr'
PAYPAL_PAYMENT_STATUSES = ('Cancelled_Reversed', 'Completed', 'Pending', 'Denied',
 'Failed', 'Refunded', 'Reversed')
PAYPAL_PENDING_REASONS = ('address', 'echeck', 'intl', 'multi_currency', 'unilateral',
 'upgrade', 'verify', 'other')
PAYPAL_REASON_CODES = ('buyer_complaint', 'chargeback', 'guarantee', 'refund', 'other')
TRANSACTION_ID_RE = re.compile("'TRANSACTIONID': '(.+?)'")
form = '\n<tal:block metal:define-macro="pay">\n<img src="" valign="bottom"\n     tal:attributes="src string:${request/BASEPATH1}/misc_/BastionBanking/paypal.gif"/>&nbsp;&nbsp;\n<span class="form-label">Number</span>&nbsp;\n<input type="text" size="16" name="cc_number">&nbsp;&nbsp;\n<span class="form-label">Expires</span>&nbsp;\n<select name="cc_year" tal:define="year python: DateTime().year()">\n    <option tal:repeat="yy python: range(0, 4)" tal:content="python: year + yy"/>\n</select>\n<strong>&nbsp;/&nbsp;</strong>\n<select name="cc_month">\n    <option tal:repeat="mm python: range(1, 13)" tal:content="python: \'%02d\' % mm"/>\n</select>\n</tal:block>\n'
AuthenticationHeader = '\n<RequesterCredentials xmlns="urn:ebay:api:PayPalAPI"\n                      xsi:type="ebl:CustomSecurityHeaderType">\n  <Credentials xmlns="urn:ebay:apis:eBLBaseComponents" xsi:type="ebl:UserIdPasswordType">\n    <Username xsi:type="xs:string">usename</Username>\n    <Password xsi:type="xs:string">password</Password>\n  </Credentials>\n</RequesterCredentials>\n'
AbstractRequestType = '\n<xs:complexType name="AbstractRequestType" abstract="true">\n  <xs:annotation>\n    <xs:documentation>\n       Base type definition of request payload that can carry any type\n       of payload content with optional versioning information and\n       detail-level requirements.\n    </xs:documentation>\n  </xs:annotation>\n  <xs:sequence>\n    <xs:any processContents="lax" minOccurs="0"/>\n  </xs:sequence>\n  <xs:attribute name="detailLevel" type="xs:token" use="optional"/>\n  <xs:attribute name="errorLanguage" type="xs:string" use="optional"/>\n    <xs:annotation>\n      <xs:documentation>\n         This shoudl be the standard RFC 3066 language identification\n         tag, e.g., en_US.\n      </xs:documentation>\n    </xs:annotation>\n  </xs:attribute>\n  <xs:attribute name="version" type="xs:string" use="required">\n    <xs:annotation>\n      <xs:documentation>\n         This refers to the version of the request payload schema.\n      </xs:documentation>\n    </xs:annotation>\n  </xs:attribute>\n</xs:complexType>\n'
AbstractResponseType = '\n<xs:complexType name="AbstractResponseType" abstract="true">\n  <xs:annotation>\n    <xs:documentation>\n       Base type definition of response payload that can carry any \n       type of payload content with following optional elements:\n         - typestamp of response message,\n         - application-level acknowledgement, and\n         - applicaiton-level errors and warnings.\n    </xs:documentation>\n  </xs:annotation>\n  <xs:sequence>\n    <xs:element name="Timestamp" type="xs:dateTime" minOccurs="0">\n      <xs:annotation>\n        <xs:documentation>\n           This value represents the date and time (GMT) when the\n           response was generated by a service provider (as a result of\n           processing of a request).\n        </xs:documentation>\n      </xs:annotation>\n    </xs:element>\n    <xs:element ref="ns:Ack">\n      <xs:annotation>\n        <xs:documentation>\n           Application level acknowledgement code\n           response was generated by a service provider (as a result of\n           processing of a request).\n        </xs:documentation>\n      </xs:annotation>\n    </xs:element>\n    <xs:element ref="ns:CorrelationId" minOccurs="0">\n      <xs:annotation>\n        <xs:documentation>\n           CorrelationId may be used optionally with an application\n           level acknowledgement.\n        </xs:documentation>\n      </xs:annotation>\n    </xs:element>\n    <xs:element name="Errors" type="ns:ErrorType" minOccurs="0" maxOccurs="unbounded"/>\n    <xs:any processContents="lax" minOccurs="0"/>\n  </xs:sequence>\n  <xs:attribute name="version" type="xs:string" use="required">\n    <xs:annotation>\n      <xs:documentation>\n         This refers to the version of the response payload schema.\n      </xs:documentation>\n    </xs:annotation>\n  </xs:attribute>\n  <xs:attribute name="build" type="xs:string" use="required">\n    <xs:annotation>\n      <xs:documentation>\n         This refers to the specific software build that was used in the\n         deployment for processing the request and generating the \n         response.\n      </xs:documentation>\n    </xs:annotation>\n  </xs:attribute>\n</xs:complexType>\n'

class ZPayPal(ObjectManager, PropertyManager, SimpleItem):
    """
    Zope-based PayPal interface.
    """
    meta_type = 'ZPayPal'
    implements(IBastionMerchant)
    _security = ClassSecurityInfo()
    __ac_permissions__ = ObjectManager.__ac_permissions__ + ((view, ('url', 'business', 'formAction', 'SetExpressCheckout', 'DoExpressCheckoutPayment')), (operate_bastionbanking, ('RefundTransaction', 'GetExpressCheckoutDetails', 'GetTransactionDetails'))) + PropertyManager.__ac_permissions__ + SimpleItem.__ac_permissions__
    __allow_access_to_unprotected_subobjects__ = 1
    Locales = ('AU', 'AT', 'BE', 'CA', 'CH', 'CN', 'DE', 'ES', 'GB', 'FR', 'IT', 'NL',
               'PL', 'US')
    manage_options = ({'label': 'Configuration', 'action': 'manage_propertiesForm'}, {'label': 'Advanced', 'action': 'manage_main'}) + SimpleItem.manage_options
    _properties = PropertyManager._properties + ({'id': 'account', 'type': 'string', 'mode': 'w'}, {'id': 'password', 'type': 'string', 'mode': 'w'}, {'id': 'signature', 'type': 'string', 'mode': 'w'}, {'id': 'test_account', 'type': 'string', 'mode': 'w'}, {'id': 'test_password', 'type': 'string', 'mode': 'w'}, {'id': 'test_signature', 'type': 'string', 'mode': 'w'}, {'id': 'locale', 'type': 'selection', 'mode': 'w', 'select_variable': 'Locales'})

    def __init__(self, id, account='', password='', signature='', test_account='', test_password='', test_signature=''):
        self.id = id
        self.title = self.meta_type
        self.account = account
        self.password = password
        self.signature = signature
        self.test_account = test_account
        self.test_password = test_password
        self.test_signature = test_signature
        self.locale = 'US'
        self._setObject('widget', ZopePageTemplate('widget', form))

    def url(self):
        if self.aq_parent.mode == 'live':
            return PAYPAL_URL
        else:
            return PAYPAL_SANDBOX_URL

    def business(self):
        if self.aq_parent.mode == 'live':
            return self.account
        else:
            return self.test_account

    def _generateBastionPayment(self, id, amount, ref, REQUEST):
        """
        return a BastionPayment - based upon us knowing what we've stuck in the form ...
        """
        return BastionPayment(id, None, amount, ref)

    def _pay(self, payment, return_url, REQUEST=None):
        """
        PayPal expect us to do a POST directly to their site, but that sucks because
        we want to be able to setup a BastionLedger transaction first (and associate it's
        id as the reference for this PayPal).

        So, we're doing a redirect with a GET with our collected and extended parameters!
        """
        if REQUEST is None:
            REQUEST = self.REQUEST
        amount = payment.amount
        assert amount.currency() in PAYPAL_SUPPORTED_CURRENCIES, 'doh currency not supported!'
        token = self.SetExpressCheckout(amount, return_url)
        payment.setRemoteRef(token)
        rc = returncode.returncode(token, amount, 0, 0, 'SetExpressCheckout', '')
        request = {'cmd': '_express-checkout', 'token': token}
        return (
         rc, '%s?%s' % (self.url(), urlencode(request)))

    def _refund(self, payment, REQUEST=None):
        """
        we're doing full refunds - or nothing ...
        """
        txn_id = self._getTransactionId(payment)
        if txn_id:
            rc = self.RefundTransaction(txn_id, payment.amount, 'Full')
            return returncode.returncode(rc['REFUNDTRANSACTIONID'], payment.amount, 0, 0, 'RefundTransaction', str(rc))
        raise ValueError, 'No TRANSACTIONID!'

    def _reconcile(self, payment, REQUEST=None):
        """
        go complete payment on PayPal side (if necessary) 
        """
        tid = self._getTransactionId(payment)
        if not tid:
            return False
        remote_info = self.GetTransactionDetails(tid)
        return remote_info.get('AMT', '') == '%0.2f' % payment.amount.amount() and remote_info.get('CURRENCYCODE', '') == payment.amount.currency() and remote_info.get('PAYMENTSTATUS', '') in ('Processed',
                                                                                                                                                                                                 'Completed')

    def _doExpressCheckout(self, token, payerid, payment):
        """
        helper to do express checkout and record the results for posterity ...
        """
        results = self.DoExpressCheckoutPayment(token, payerid, payment.amount, payment.getId())
        rc = returncode.returncode(token, payment.amount, 0, 0, 'DoExpressCheckoutPayment', str(results))
        payment._setReturnCode(rc)
        payment.manage_changeStatus('accept')
        return results

    _security.declarePublic('ipn')

    def ipn(self, REQUEST):
        """
        process payment notification

        Note we have to do the whole workflow thing here as the MerchantService
        has no idea about this function ...
        """
        request = dict(REQUEST.form)
        logger.debug('ipn() %s' % str(request))
        request['cmd'] = '_notify-validate'
        transport = Transport(self.url())
        response, data = transport(urlencode(request))
        logger.debug('ipn() response %s, %s, %s' % (response.status, response.reason, data))
        if response.status >= 400:
            msg = '%s: %i - %s\n%s' % (self.url(), response.status, response.reason, data)
            logger.error(msg)
            raise IOError, msg
        pmt_id = request['custom']
        try:
            payment = self.aq_parent._getOb(pmt_id)
        except:
            logger.error('unknown payment id: %s' % pmt_id)
            return

        rc = returncode.returncode(request.get('txn_id', ''), payment.amount, 0, 0, 'ipn', str(request))
        payment._setReturnCode(rc)
        wftool = getToolByName(self, 'portal_workflow')
        wf = wftool.getWorkflowsFor(payment)[0]
        if data == 'INVALID':
            wf._executeTransition(payment, wf.transitions.reject)
        elif data == 'VERIFIED':
            wf._executeTransition(payment, wf.transitions.accept)
        else:
            logger.error('Unknown return type, expected INVALID/VERIFIED, got: %s' % data)

    def supportedCurrencies(self):
        return PAYPAL_SUPPORTED_CURRENCIES

    def SetExpressCheckout(self, amount, url, email=''):
        """
        calls PayPal SetExpressCheckout function and returns the express checkout token
        """
        params = {'NOSHIPPING': '1', 'PAYMENTACTION': 'Sale', 
           'RETURNURL': url, 
           'CANCELURL': url, 
           'LOCALECODE': self.locale, 
           'CHANNELTYPE': 'Merchant', 
           'CURRENCYCODE': amount.currency(), 
           'AMT': amount.amount(), 
           'ITEMAMT': amount.amount(), 
           'L_AMT0': amount.amount()}
        if email:
            params['EMAIL'] = email
        brandname = self.aq_parent.store_name
        if brandname:
            params['BRANDNAME'] = brandname
        identifier = self.aq_parent.store_identifier
        if identifier:
            params['CUSTOM'] = identifier
        results = self._nvp('SetExpressCheckout', params)
        if results.has_key('TOKEN'):
            return results['TOKEN']
        raise ValueError, (params, results)

    def DoExpressCheckoutPayment(self, token, payerid, amount, custom=''):
        """
        we set the custom field so that ipn can find the ticket ...
        """
        params = {'CURRENCYCODE': amount.currency(), 'AMT': amount.amount(), 
           'CUSTOM': custom, 
           'NOTIFYURL': '%s/ipn' % self.absolute_url(), 
           'TOKEN': token, 
           'PAYERID': payerid, 
           'PAYMENTACTION': 'Sale'}
        results = self._nvp('DoExpressCheckoutPayment', params)
        if results['ACK'] == 'Failure':
            raise ValueError, (params, results)
        return results

    def GetExpressCheckoutDetails(self, token):
        """
        """
        params = {'TOKEN': token}
        try:
            results = self._nvp('GetExpressCheckoutDetails', params)
        except ProcessingFailure as e:
            return e[1]

        return results

    def GetTransactionDetails(self, tid):
        """
        """
        params = {'TRANSACTIONID': tid}
        results = self._nvp('GetTransactionDetails', params)
        return results

    def RefundTransaction(self, tid, amount, refund_type='Full'):
        """
        refund_type is Full, Partial, Other
        """
        params = {'TRANSACTIONID': tid, 'CURRENCY': amount.currency(), 
           'REFUNDTYPE': refund_type}
        if refund_type != 'Full':
            params['AMOUNT'] = amount.amount()
        results = self._nvp('RefundTransaction', params)
        return results

    def _nvp(self, methodname, args={}):
        """
        do a PayPal NVP gateway API call
        """
        params = {'METHOD': methodname, 'VERSION': '52.0'}
        if self.aq_parent.mode == 'live':
            url = 'https://api-3t.paypal.com/nvp'
            params.update({'USER': self.account, 'PWD': self.password, 
               'SIGNATURE': self.signature})
        else:
            url = 'https://api-3t.sandbox.paypal.com/nvp'
            params.update({'USER': self.test_account, 'PWD': self.test_password, 
               'SIGNATURE': self.test_signature})
        if args:
            params.update(args)
        logger.debug('_nvp(%s) %s' % (methodname, str(params)))
        transport = Transport(url)
        response, data = transport(urlencode(params))
        if response.status >= 400:
            msg = '%s: %i - %s\n%s' % (url, response.status, response.reason, data)
            logger.error('_nvp() %s' % msg)
            raise IOError, msg
        results = {}
        for k, v in map(lambda x: x.split('='), data.split('&')):
            results[k] = unquote(v)

        logger.debug('_nvp(%s) %s' % (methodname, str(results)))
        if results['ACK'] == 'Failure':
            raise ProcessingFailure, (args, results)
        return results

    def formAction(self, REQUEST={}, force=False):
        """
        determine what kind of processing should be done on the form - and we cheat and
        use this to kick off DoExpressCheckoutPayment to complete the payment on PayPal.

        if force is set, we do a complete catalog-scan
        """
        if REQUEST.has_key('token'):
            token = REQUEST['token']
            if REQUEST.has_key('PayerID'):
                now = DateTime()
                if force:
                    pmts = filter(lambda x: x.getRemoteRef() == token, self.aq_parent.paymentResults({'status': ('pending', 'rejected')}))
                else:
                    pmts = filter(lambda x: x.getRemoteRef() == token, self.aq_parent.paymentResults({'status': 'pending', 'submitted': {'query': (now, now - TENMINUTES), 'range': 'minmax'}}))
                if pmts:
                    self._doExpressCheckout(token, REQUEST['PayerID'], pmts[0])
                return 'thank'
            return 'rejected'
        return 'capture'

    def formHidden(self, amount, url, REQUEST={}):
        """
        return a dict of necessary hidden fields
        """
        return {'token': self.SetExpressCheckout(amount, url)}

    def getTransaction(self, pmt):
        """
        returns PayPal's transaction info on the payment.  If we've got far enough
        to get a TRANSACTIONID, we get the details on this, otherwise we get the
        Express Checkout details based on the TOKEN
        """
        tid = self._getTransactionId(pmt)
        if tid:
            return self.GetTransactionDetails(tid)
        token = pmt.getRemoteRef()
        return self.GetExpressCheckoutDetails(token)

    def _getTransactionId(self, pmt):
        """
        trawl through the returncodes looking for TRANSACTIONID's ...
        """
        tid = ''
        codes = list(pmt.returncodes.objectValues())
        codes.reverse()
        for rc in codes:
            match = TRANSACTION_ID_RE.search(rc.response)
            if match:
                return match.groups()[0]

        return ''


AccessControl.class_init.InitializeClass(ZPayPal)
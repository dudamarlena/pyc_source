# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-x86_64/egg/mercury/common/mercury_id.py
# Compiled at: 2018-01-08 12:01:55
# Size of source mod 2**32: 4404 bytes
"""Functions for grabbing a MercuryID

MercuryID or mercury_id meta and hash value

[meta] - 00 = hash generated by interface mac addresses
         01 = hash generated by asset tag and serial number
"""
import hashlib, logging
from mercury.common.exceptions import MercuryIdException
LOG = logging.getLogger(__name__)
META_TYPE_MAC = '00'
META_TYPE_PRODUCT_UUID = '01'
META_TYPE_CHASSIS_ASSET_SERIAL = '02'
META_TYPE_BOARD_ASSET_SERIAL = '03'

def _build_hash(target, meta_type):
    """Builds hash from target data and meta_type"""
    digest = hashlib.sha1(target.encode('ascii')).hexdigest()
    return meta_type + digest


def _get_embedded(inspected_interfaces):
    """Gets embedded interfaces from inspected interfaces."""
    embedded_interfaces = []
    for interface in inspected_interfaces:
        _biosdevname = interface['predictable_names'].get('biosdevname', '')
        if _biosdevname and 'em' in _biosdevname:
            embedded_interfaces.append(interface)

    return embedded_interfaces


DMI_DISQUALIFIED_STRING = 'To Be Filled By O.E.M.'

def _dmi_methods(dmi):
    """Builds a mercury ID for DMI information if possible.

    :param dmi: A dictionary of DMI information from a system.
    :returns: A string if the right DMI is present, None otherwise.
    """
    product_uuid = dmi.get('product_uuid')
    chassis_asset_tag = dmi.get('chassis_asset_tag')
    chassis_serial = dmi.get('chassis_serial')
    board_asset_tag = dmi.get('board_asset_tag')
    board_serial = dmi.get('board_serial')
    if product_uuid:
        LOG.debug('Generating mercury ID using product_uuid: %s' % product_uuid)
        return _build_hash(product_uuid, META_TYPE_PRODUCT_UUID)
    if DMI_DISQUALIFIED_STRING in [chassis_asset_tag, chassis_serial,
     board_asset_tag, board_serial]:
        LOG.debug("Junk in DMI tables: '%s'" % DMI_DISQUALIFIED_STRING)
        return
    if chassis_asset_tag:
        if chassis_serial:
            LOG.debug('Generating mercury ID using chassis asset information: tag=%s, asset=%s' % (
             chassis_asset_tag, chassis_serial))
            return _build_hash(chassis_asset_tag + chassis_serial, META_TYPE_CHASSIS_ASSET_SERIAL)
    if board_asset_tag:
        if board_serial:
            LOG.debug('Generating mercury ID using board asset information: tag=%s, asset=%s' % (
             board_asset_tag, board_serial))
            return _build_hash(board_asset_tag + board_serial, META_TYPE_BOARD_ASSET_SERIAL)


def generate_mercury_id(inspected_dmi, inspected_interfaces):
    """Generates a mercury ID based on gathered system information.

    :param inspected_dmi: A dictionary containing DMI information about
        the system in question.
    :param inspected_interfaces: A dictionary containing information about
        interfaces present in the system.
    :returns: A string representing the mercury ID.
    :raises MercuryIdException: If not enough information is present to
        generate an ID.
    """
    mercury_id = _dmi_methods(inspected_dmi)
    if mercury_id:
        return mercury_id
    else:
        meta_type = META_TYPE_MAC
        embedded = _get_embedded(inspected_interfaces)
        if embedded:
            LOG.debug('Generating mercury ID using embedded interfaces ')
            inspected_interfaces = embedded
        else:
            LOG.debug('Generating mercury ID using all interfaces')
    target = ''
    for interface in inspected_interfaces:
        address = interface.get('address')
        if address:
            target += address

    if not target:
        raise MercuryIdException('Could not generate MercuryId')
    return _build_hash(target, meta_type)
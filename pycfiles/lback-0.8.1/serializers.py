# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /home/mdipierro/make_web2py/web2py/gluon/serializers.py
# Compiled at: 2013-10-14 11:16:25
"""
This file is part of the web2py Web Framework
Copyrighted by Massimo Di Pierro <mdipierro@cs.depaul.edu>
License: LGPLv3 (http://www.gnu.org/licenses/lgpl.html)
"""
import datetime, decimal
from gluon.storage import Storage
from gluon.html import TAG, XmlComponent, xmlescape
from gluon.languages import lazyT
import gluon.contrib.rss2 as rss2
try:
    import simplejson as json_parser
except ImportError:
    try:
        import json as json_parser
    except:
        import gluon.contrib.simplejson as json_parser

have_yaml = True
try:
    import yaml as yamlib
except ImportError:
    have_yaml = False

def cast_keys(o, cast=str, encoding='utf-8'):
    """ Builds a new object with <cast> type keys

    Arguments:
        o is the object input
        cast (defaults to str) is an object type or function
              which supports conversion such as:

              >>> converted = cast(o)

        encoding (defaults to utf-8) is the encoding for unicode
                 keys. This is not used for custom cast functions

    Use this funcion if you are in Python < 2.6.5
    This avoids syntax errors when unpacking dictionary arguments.
    """
    if isinstance(o, (dict, Storage)):
        if isinstance(o, dict):
            newobj = dict()
        else:
            newobj = Storage()
        for k, v in o.items():
            if cast == str and isinstance(k, unicode):
                key = k.encode(encoding)
            else:
                key = cast(k)
            newobj[key] = cast_keys(v, cast=cast, encoding=encoding)

    elif isinstance(o, (tuple, set, list)):
        newobj = []
        for item in o:
            newobj.append(cast_keys(item, cast=cast, encoding=encoding))

        if isinstance(o, tuple):
            newobj = tuple(newobj)
        elif isinstance(o, set):
            newobj = set(newobj)
    else:
        newobj = o
    return newobj


def loads_json(o, unicode_keys=True, **kwargs):
    result = json_parser.loads(o, **kwargs)
    if not unicode_keys:
        result = cast_keys(result, encoding=kwargs.get('encoding', 'utf-8'))
    return result


def custom_json(o):
    if hasattr(o, 'custom_json') and callable(o.custom_json):
        return o.custom_json()
    if isinstance(o, (datetime.date,
     datetime.datetime,
     datetime.time)):
        return o.isoformat()[:19].replace('T', ' ')
    if isinstance(o, (int, long)):
        return int(o)
    if isinstance(o, decimal.Decimal):
        return str(o)
    if isinstance(o, lazyT):
        return str(o)
    if isinstance(o, XmlComponent):
        return str(o)
    if hasattr(o, 'as_list') and callable(o.as_list):
        return o.as_list()
    if hasattr(o, 'as_dict') and callable(o.as_dict):
        return o.as_dict()
    raise TypeError(repr(o) + ' is not JSON serializable')


def xml_rec(value, key, quote=True):
    if hasattr(value, 'custom_xml') and callable(value.custom_xml):
        return value.custom_xml()
    else:
        if isinstance(value, (dict, Storage)):
            return TAG[key](*[ TAG[k](xml_rec(v, '', quote)) for k, v in value.items()
                             ])
        if isinstance(value, list):
            return TAG[key](*[ TAG.item(xml_rec(item, '', quote)) for item in value ])
        if hasattr(value, 'as_list') and callable(value.as_list):
            return str(xml_rec(value.as_list(), '', quote))
        if hasattr(value, 'as_dict') and callable(value.as_dict):
            return str(xml_rec(value.as_dict(), '', quote))
        return xmlescape(value, quote)


def xml(value, encoding='UTF-8', key='document', quote=True):
    return '<?xml version="1.0" encoding="%s"?>' % encoding + str(xml_rec(value, key, quote))


def json(value, default=custom_json):
    return json_parser.dumps(value, default=default).replace('\u2028', '\\u2028').replace('\\2029', '\\u2029')


def csv(value):
    return ''


def ics(events, title=None, link=None, timeshift=0, calname=True, **ignored):
    import datetime
    title = title or '(unknown)'
    if link and not callable(link):
        link = lambda item, prefix=link: prefix.replace('[id]', str(item['id']))
    s = 'BEGIN:VCALENDAR'
    s += '\nVERSION:2.0'
    if calname is not False:
        s += '\nX-WR-CALNAME:%s' % (calname or title)
    s += '\nSUMMARY:%s' % title
    s += '\nPRODID:Generated by web2py'
    s += '\nCALSCALE:GREGORIAN'
    s += '\nMETHOD:PUBLISH'
    for item in events:
        s += '\nBEGIN:VEVENT'
        s += '\nUID:%s' % item['id']
        if link:
            s += '\nURL:%s' % link(item)
        shift = datetime.timedelta(seconds=3600 * timeshift)
        start = item['start_datetime'] + shift
        stop = item['stop_datetime'] + shift
        s += '\nDTSTART:%s' % start.strftime('%Y%m%dT%H%M%S')
        s += '\nDTEND:%s' % stop.strftime('%Y%m%dT%H%M%S')
        s += '\nSUMMARY:%s' % item['title']
        s += '\nEND:VEVENT'

    s += '\nEND:VCALENDAR'
    return s


def rss(feed):
    if 'entries' not in feed and 'items' in feed:
        feed['entries'] = feed['items']
    now = datetime.datetime.now()
    rss = rss2.RSS2(title=str(feed.get('title', '(notitle)').encode('utf-8', 'replace')), link=str(feed.get('link', None).encode('utf-8', 'replace')), description=str(feed.get('description', '').encode('utf-8', 'replace')), lastBuildDate=feed.get('created_on', now), items=[ rss2.RSSItem(title=str(entry.get('title', '(notitle)').encode('utf-8', 'replace')), link=str(entry.get('link', None).encode('utf-8', 'replace')), description=str(entry.get('description', '').encode('utf-8', 'replace')), pubDate=entry.get('created_on', now)) for entry in feed.get('entries', [])
                                                                                                                                                                                                                                                                                 ])
    return rss.to_xml(encoding='utf-8')


def yaml(data):
    if have_yaml:
        return yamlib.dump(data)
    raise ImportError('No YAML serializer available')


def loads_yaml(data):
    if have_yaml:
        return yamlib.load(data)
    raise ImportError('No YAML serializer available')
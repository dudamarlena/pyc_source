# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/workstation/robot/robot.py
# Compiled at: 2019-09-25 06:01:13
# Size of source mod 2**32: 16679 bytes
import copy, os
from threading import Event
from workstation import drivers
from workstation.util import trace
from workstation.util.vector import Vector
from workstation.util.log import get_logger
from workstation.util.trace import traceable
log = get_logger(__name__)

class InstrumentMotor(object):
    __doc__ = "\n    Provides access to Robot's head motor.\n    "

    def __init__(self, this_robot, axis):
        self.robot = this_robot
        self.axis = axis

    def move(self, value, mode='absolute'):
        """
        Move plunger motor.

        Parameters
        ----------
        value : int
            A one-dimensional coordinate to move to.
        mode : {'absolute', 'relative'}
        """
        kwargs = {self.axis: value}
        (self.robot._driver.move_plunger)(mode=mode, **kwargs)

    def home(self):
        """
        Home plunger motor.
        """
        self.robot._driver.home(self.axis)

    def wait(self, seconds):
        """
        Wait.

        Parameters
        ----------
        seconds : int
            Number of seconds to pause for.
        """
        self.robot._driver.wait(seconds)

    def speed(self, rate):
        """
        Set motor speed.

        Parameters
        ----------
        rate : int
        """
        self.robot._driver.set_plunger_speed(rate, self.axis)
        return self


class Robot(object):
    __doc__ = "\n    This class is the main interface to the robot.\n\n    Through this class you can can:\n        * define your :class:`workstation.Deck`\n        * :meth:`connect` to workstation physical robot\n        * :meth:`home` axis, move head (:meth:`move_to`)\n        * :meth:`pause` and :func:`resume` the protocol run\n        * set the :meth:`head_speed` of the robot\n\n    Each workstation protocol is a Python script. When evaluated the script\n    creates an execution plan which is stored as a list of commands in\n    Robot's command queue.\n\n    Here are the typical steps of writing the protocol:\n        * Using a Python script and the workstation API load your\n          containers and define instruments\n          (see :class:`~workstation.instruments.pipette.Pipette`).\n        * Call :meth:`reset` to reset the robot's state and clear commands.\n        * Write your instructions which will get converted\n          into an execution plan.\n        * Review the list of commands generated by a protocol\n          :meth:`commands`.\n        * :meth:`connect` to the robot and call :func:`run` it on a real robot.\n\n    See :class:`Pipette` for the list of supported instructions.\n\n    Examples\n    --------\n    >>> from workstation import robot, instruments, containers\n    >>> robot.reset() # doctest: +ELLIPSIS\n    <workstation.robot.robot.Robot object at ...>\n    >>> plate = containers.load('96-flat', 'A1', 'plate')\n    >>> p200 = instruments.Pipette(axis='b', max_volume=200)\n    >>> p200.aspirate(200, plate[0]) # doctest: +ELLIPSIS\n    <workstation.instruments.pipette.Pipette object at ...>\n    >>> robot.commands()\n    ['Aspirating 200 at <Deck><Slot A1><Container plate><Well A1>']\n    "

    def __init__(self):
        """
        Initializes a robot instance.

        Notes
        -----
        This class is a singleton. That means every time you call
        :func:`__init__` the same instance will be returned. There's
        only once instance of a robot.
        """
        self._commands = None
        self.INSTRUMENT_DRIVERS_CACHE = {}
        self.can_pop_command = Event()
        self.can_pop_command.set()
        self.mode = None
        self.smoothie_drivers = {'live':None, 
         'simulate':drivers.get_virtual_driver(options={'limit_switches': False}), 
         'simulate_switches':drivers.get_virtual_driver(options={'limit_switches': True})}
        null_driver = drivers.get_virtual_driver()

        def _null(*args, **kwargs):
            pass

        null_driver.move = _null
        null_driver.home = _null
        self.smoothie_drivers['null'] = null_driver
        self._driver = drivers.get_virtual_driver()
        self.disconnect()
        self.arc_height = 5
        self.cmds_total = None
        self.set_connection('simulate')
        self.reset()

    def reset(self):
        """
        Resets the state of the robot and clears:
            * Deck
            * Instruments
            * Command queue
            * Runtime warnings

        """
        self._commands = []
        self._runtime_warnings = []
        self.axis_homed = {'x':False, 
         'y':False,  'z':False,  'a':False,  'b':False}
        return self

    def add_warning(self, warning_msg):
        """
        Internal. Add a runtime warning to the queue.
        """
        self._runtime_warnings.append(warning_msg)

    def get_warnings(self):
        """
        Get current runtime warnings.

        Returns
        -------

        Runtime warnings accumulated since the last :func:`run`
        or :func:`simulate`.
        """
        return list(self._runtime_warnings)

    def get_mosfet(self, mosfet_index):
        """
        Get MOSFET for a MagBead (URL).

        Parameters
        ----------
        mosfet_index : int
            Number of a MOSFET on MagBead.

        Returns
        -------
        Instance of :class:`InstrumentMosfet`.
        """
        instr_type = 'mosfet'
        key = (instr_type, mosfet_index)
        motor_obj = self.INSTRUMENT_DRIVERS_CACHE.get(key)
        if not motor_obj:
            motor_obj = InstrumentMosfet(self, mosfet_index)
            self.INSTRUMENT_DRIVERS_CACHE[key] = motor_obj
        return motor_obj

    def get_motor(self, axis):
        """
        Get robot's head motor.

        Parameters
        ----------
        axis : {'a', 'b'}
            Axis name. Please check stickers on robot's gantry for the name.
        """
        instr_type = 'instrument'
        key = (instr_type, axis)
        motor_obj = self.INSTRUMENT_DRIVERS_CACHE.get(key)
        if not motor_obj:
            motor_obj = InstrumentMotor(self, axis)
            self.INSTRUMENT_DRIVERS_CACHE[key] = motor_obj
        return motor_obj

    def connect(self, port=None, options=None):
        """
        Connects the robot to a serial port.

        Parameters
        ----------
        port : str
            OS-specific port name or ``'Virtual Smoothie'``
        options : dict
            if :attr:`port` is set to ``'Virtual Smoothie'``, provide
            the list of options to be passed to :func:`get_virtual_device`

        Returns
        -------
        ``True`` for success, ``False`` for failure.
        """
        device = None
        if port == 'Virtual Smoothie':
            port = 'edge-1c222d9NOMSD'
        else:
            port = port or 'edge-1c222d9NOMSD'
            if port in drivers.VIRTUAL_SMOOTHIE_PORTS:
                device = drivers.get_virtual_driver(options=options, port=port)
            else:
                device = drivers.get_serial_driver(port)
        self._driver = device
        self.smoothie_drivers['live'] = device
        ot_v = device.ot_version
        self.smoothie_drivers['simulate'].ot_version = ot_v
        self.smoothie_drivers['simulate_switches'].ot_version = ot_v
        self.smoothie_drivers['null'].ot_version = ot_v

    def _update_axis_homed(self, *args):
        for a in args:
            for letter in a:
                if letter.lower() in self.axis_homed:
                    self.axis_homed[letter.lower()] = True

    def home(self, *args, **kwargs):
        """
        Home robot's head and plunger motors.

        Parameters
        ----------
        *args :
            A string with axes to home. For example ``'xyz'`` or ``'ab'``.

            If no arguments provided home Z-axis then X, Y, B, A

        Notes
        -----
        Sometimes while executing a long protocol,
        a robot might accumulate precision
        error and it is recommended to home it. In this scenario, add
        ``robot.home('xyzab')`` into your script.

        Examples
        --------
        >>> from workstation import Robot
        >>> robot.connect()
        >>> robot.home()
        """
        self._driver.calm_down()
        if args:
            (self._update_axis_homed)(*args)
            (self._driver.home)(*args)
        else:
            self._update_axis_homed('xyzab')
            self._driver.home('z')
            self._driver.home('x', 'y', 'b', 'a')

    def add_command(self, command):
        if self.mode == 'live':
            cmd_run_event = {'caller': 'ui'}
            cmd_run_event['mode'] = 'live'
            cmd_run_event['name'] = 'command-run'
            cmd_run_event.update({'command_description':command, 
             'command_index':len(self._commands), 
             'commands_total':self.cmds_total})
            trace.EventBroker.get_instance().notify(cmd_run_event)
        self._commands.append(command)

    def move_head(self, *args, **kwargs):
        (self._driver.move_head)(*args, **kwargs)

    def move_plunger(self, *args, **kwargs):
        (self._driver.move_plunger)(*args, **kwargs)

    def head_speed(self, *args, **kwargs):
        """
        Set the XY axis speeds of the robot, set in millimeters per minute

        Parameters
        ----------
        rate : int
            An integer setting the mm/minute rate of the X and Y axis.
            Speeds too fast (around 6000 and higher) will cause the robot
            to skip step, be careful when using this method

        Examples
        --------
        >>> from workstation import robot
        >>> robot.connect()
        >>> robot.home()
        >>> robot.head_speed(4500)
        >>> robot.move_head(x=200, y=200)
        """
        (self._driver.set_speed)(*args, **kwargs)

    @traceable('move-to')
    def move_to(self, location, instrument=None, strategy='arc', **kwargs):
        """
        Move an instrument to a coordinate, container or a coordinate within
        a container.

        Parameters
        ----------
        location : one of the following:
            1. :class:`Placeable` (i.e. Container, Deck, Slot, Well) —\xa0will
            move to the origin of a container.
            2. :class:`Vector` move to the given coordinate in Deck coordinate
            system.
            3. (:class:`Placeable`, :class:`Vector`) move to a given coordinate
            within object's coordinate system.

        instrument :
            Instrument to move relative to. If ``None``, move relative to the
            center of a gantry.

        strategy : {'arc', 'direct'}
            ``arc`` : move to the point using arc trajectory
            avoiding obstacles.

            ``direct`` : move to the point in a straight line.

        Examples
        --------
        >>> from workstation import Robot
        >>> robot.reset() # doctest: +ELLIPSIS
        <workstation.robot.robot.Robot object at ...>
        >>> robot.connect()
        >>> robot.home()
        >>> plate = robot.add_container('96-flat', 'A1', 'plate')
        >>> robot.move_to(plate[0])
        >>> robot.move_to(plate[0].top())
        """
        placeable, coordinates = containers.unpack_location(location)
        if instrument:
            coordinates = instrument.calibrator.convert(placeable, coordinates)
        else:
            coordinates += placeable.coordinates(placeable.get_deck())
        if strategy == 'arc':
            arc_coords = self._create_arc(coordinates, placeable, instrument)
            for coord in arc_coords:
                (self._driver.move_head)(**coord)

        else:
            if strategy == 'direct':
                self._driver.move_head(x=(coordinates[0]),
                  y=(coordinates[1]),
                  z=(coordinates[2]))
            else:
                raise RuntimeError('Unknown move strategy: {}'.format(strategy))

    @property
    def actions(self):
        """
        Return a copy of a raw list of commands in the Robot's queue.
        """
        return copy.deepcopy(self._commands)

    def prepare_for_run(self):
        """
        Internal. Prepare for a Robot's run.
        """
        if not self._driver.is_connected():
            raise RuntimeWarning('Please connect to the robot')
        else:
            self._runtime_warnings = []
            if not self._instruments:
                self.add_warning('No instruments added to robot')
            self._commands or self.add_warning('No commands added to robot')
        for instrument in self._instruments.values():
            instrument.reset()

    def set_connection(self, mode):
        self.mode = mode
        if mode not in self.smoothie_drivers:
            raise ValueError('mode expected to be "live", "simulate_switches", "null" or "simulate", {} provided'.format(mode))
        d = self.smoothie_drivers[mode]
        if d:
            if d.is_simulating():
                if self._driver:
                    if self._driver.is_connected():
                        d.connection.serial_port.set_position_from_arguments({ax.upper():val for ax, val in self._driver.get_current_position().items()})
        self._driver = d
        if self._driver:
            if not self._driver.is_connected():
                self._driver.toggle_port()

    def disconnect(self):
        """
        Disconnects from the robot.
        """
        if self._driver:
            self._driver.disconnect()
        self.axis_homed = {'x':False, 
         'y':False,  'z':False,  'a':False,  'b':False}

    def clear_commands(self):
        """
        Clear Robot's command queue.
        """
        self._previous_container = None
        self._commands = []

    def pause(self):
        """
        Pauses execution of the protocol. Use :meth:`resume` to resume
        """
        self.can_pop_command.clear()
        self._driver.pause()

    def stop(self):
        """
        Stops execution of the protocol.
        """
        self._driver.stop()
        self.can_pop_command.set()

    def resume(self):
        """
        Resume execution of the protocol after :meth:`pause`
        """
        self.can_pop_command.set()
        self._driver.resume()

    def halt(self):
        """
        Stops execution of both the protocol and the Smoothie board immediately
        """
        self._driver.halt()
        self.can_pop_command.set()

    def get_serial_ports_list(self):
        ports = []
        if os.environ.get('ENABLE_VIRTUAL_SMOOTHIE', '').lower() == 'true':
            ports.extend(drivers.VIRTUAL_SMOOTHIE_PORTS)
        ports.extend(drivers.get_serial_ports_list())
        return ports

    def is_connected(self):
        if not self._driver:
            return False
        return self._driver.is_connected()

    def is_simulating(self):
        if not self._driver:
            return False
        return self._driver.is_simulating()

    def get_connected_port(self):
        return self._driver.get_connected_port()

    def diagnostics(self):
        """
        Access diagnostics information for the robot.

        Returns
        -------
        Dictionary with the following keys:
            * ``axis_homed`` — axis that are currently in home position.
            * ``switches`` — end stop switches currently hit.
            * ``steps_per_mm`` —\xa0steps per millimeter calibration
            values for ``x`` and ``y`` axis.
        """
        return {'axis_homed':self.axis_homed, 
         'switches':self._driver.get_endstop_switches(), 
         'steps_per_mm':{'x':self._driver.get_steps_per_mm('x'), 
          'y':self._driver.get_steps_per_mm('y')}}

    def commands(self):
        """
        Access the human-readable list of commands in the robot's queue.

        Returns
        -------
        A list of string values for each command in the queue, for example:

        ``'Aspirating 200uL at <Deck>/<Slot A1>/<Container plate>/<Well A1>'``
        """
        return self._commands

    def comment(self, msg):
        self.add_command(msg)
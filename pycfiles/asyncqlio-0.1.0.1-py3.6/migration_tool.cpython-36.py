# uncompyle6 version 3.7.4
# Python bytecode 3.6 (3379)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-x86_64/egg/asyncqlio/orm/ddl/migration_tool.py
# Compiled at: 2017-11-29 06:02:28
# Size of source mod 2**32: 11829 bytes
"""
AsyncQLio migration tool.

This tool contains utilities to perform migrations on database schemas.
"""
import asyncio, functools, logging, os, re, string, sys, typing
from pathlib import Path
import click, tqdm
from asyncqlio.db import DatabaseInterface
from asyncqlio.orm.session import Session

class DummyTqdmFile(object):
    __doc__ = '\n    Dummy file-like that will write to tqdm\n    '

    def __init__(self, file):
        self.file = file

    def __getattr__(self, item):
        return getattr(self.file, item)

    def isatty(self) -> bool:
        try:
            return self.file.isatty()
        except AttributeError:
            return False

    def fileno(self):
        return self.file.fileno()

    def write(self, x: typing.Union[(bytes, str)]) -> None:
        if isinstance(x, bytes):
            data = x.decode()
        else:
            data = x
        if len(data.rstrip()) > 0:
            if data[(-1)] == '\n':
                end = ''
            else:
                end = '\n'
            tqdm.tqdm.write(data, file=(self.file), end=end)

    def flush(self) -> None:
        self.file.flush()


sys.stdout = DummyTqdmFile(sys.__stdout__)

class TqdmLoggingHandler(logging.Handler):

    def __init__(self, level=logging.NOTSET):
        super(self.__class__, self).__init__(level)

    def emit(self, record):
        try:
            msg = self.format(record)
            tqdm.tqdm.write(msg)
            self.flush()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)


handler = TqdmLoggingHandler(level=(logging.DEBUG))
formatter = logging.Formatter('[%(levelname)s] %(name)s -> %(message)s')
handler.setFormatter(formatter)
logging.basicConfig(handlers=[handler], level=(logging.DEBUG))
logger = logging.getLogger('asyncqlio.migrations')
env_file = '"""\nExample environment file for asql-migrate.\n"""\nimport typing\n\nfrom asyncqlio.db import DatabaseInterface\nfrom asyncqlio.orm.session import Session\n\n# If you need to import your own tables, do so here.\n# import sys, os\n# sys.path.insert(0, os.path.abspath("."))\n# import my_package.Table\n\n# The DSN to connect to the server with.\n# You probably want to change this.\ndsn = {dsn}\n\nasync def create_database_interface() -> DatabaseInterface:\n    """\n    Creates the database interface used by the migrations.\n    """\n    # If you wish to override how the database interface is created, do so here.\n    # This includes importing your Table object, and binding tables.\n    if dsn is None:\n        raise RuntimeError("No DSN provided! Either edit it in env.py, or provide it on the "\n                           "command line.")\n\n    db = DatabaseInterface(dsn=dsn)\n    await db.connect()\n    return db\n\n\nsig = typing.Callable[[Session], None]\n\n\nasync def run_migration_online(sess: Session, upgrade: sig):\n    """\n    Runs a migration file "online". This will acquire a session, call the upgrade function,\n    and then commit the session.\n    """\n    await upgrade(sess)\n\n\nasync def run_migration_offline(sess: Session, upgrade: sig):\n    """\n    Runs a migration file "offline".\n    """\n'
migration_template = '"""\nAutogenerated migration file.\n\nRevision: {revision}\nMessage: {message}\n"""\nfrom asyncqlio import Session\n\n\nrevision = "{revision}"\nmessage = "{message}"\n\nasync def upgrade(session: Session):\n    """\n    Performs an upgrade. Put your upgrading SQL here.\n    """\n\n\nasync def downgrade(session: Session):\n    """\n    Performs a downgrade. Put your downgrading SQL here.\n    """\n\n'
migrations_dir = Path('migrations')

@functools.lru_cache()
def eval_env() -> dict:
    """
    Evals the env.py script.
    """
    global migrations_dir
    p = migrations_dir / 'env.py'
    d = {}
    with p.open(mode='r') as (f):
        content = f.read()
    exec(content, d, d)
    return d


def get_revision(revision: str, current_revision: int) -> int:
    """
    Gets the absolute revision to upgrade/downgrade to.
    """
    if revision.lower() == 'head':
        return 999999999999
    else:
        if revision.startswith('+'):
            return current_revision + int(revision[1:])
        if revision.startswith('-'):
            return current_revision - int(revision[1:])
        try:
            return int(revision)
        except ValueError:
            raise RuntimeError('Revision {} could not be parsed as absolute or relative'.format(revision))


async def get_current_version(iface: DatabaseInterface) -> int:
    """
    Gets the current version of the database.

    This will create the asql_version table if it doesn't already exist.
    """
    async with iface.get_session() as sess:
        await sess.execute('CREATE TABLE IF NOT EXISTS asql_version (version INTEGER)')
        row = await (await sess.cursor('SELECT version from asql_version')).fetch_row()
        if row is None:
            await sess.execute('INSERT INTO asql_version VALUES (0)')
            return 0
        else:
            return row['version']


def coro(func):
    """
    A decorator that runs a command inside asyncio.
    """

    @functools.wraps(func)
    def coro_wrapper(*args, **kwargs):
        loop = asyncio.get_event_loop()
        fut = asyncio.ensure_future(func(*args, **kwargs), loop=loop)
        result = loop.run_until_complete(fut)
        return result

    return coro_wrapper


@click.group()
@click.option('-m', '--migration-dir', help='The directory migrations will be stored', default='migrations')
def cli(migration_dir: str):
    global migrations_dir
    migrations_dir = Path(migration_dir)


@cli.command()
@click.argument('directory', default='migrations')
@click.option('-d', '--dsn', required=False, default=None)
def init(directory: str, dsn: str):
    """
    Initializes a migrations directory.
    """
    try:
        os.makedirs(directory)
    except FileExistsError:
        click.secho('Unable to make directory (it exists)!', fg='red')

    if dsn is not None:
        dsn = '"{}"'.format(dsn)
    click.secho('Writing env.py...', fg='cyan')
    (Path(directory) / 'env.py').write_text(env_file.format(dsn=dsn))
    click.secho('Making versions directory...', fg='cyan')
    (Path(directory) / 'versions').mkdir(mode=493)
    (Path(directory) / 'README').write_text('Basic asql-migrate setup.')
    click.secho('Done!', fg='green')


@cli.command()
@click.argument('revision', default='head')
@coro
async def migrate(revision: str='head'):
    """
    Upgrades the database to the specified revision.
    """
    env = eval_env()
    interface = await env['create_database_interface']()
    async with interface:
        current_revision = await get_current_version(interface)
        if current_revision < 0:
            click.secho('Database is in bad shape: revision {} < 0'.format(current_revision))
            return
        next_revision = get_revision(revision, current_revision)
        if next_revision == current_revision:
            click.secho('Nothing to do. ', fg='cyan')
            return
        if next_revision < 0:
            click.secho(('Cannot downgrade past revision 0. (attempted to downgrade to {})'.format(next_revision)),
              fg='magenta')
            return
        await _do_migrate(interface, current_revision, next_revision)


@cli.command()
@click.argument('message', nargs=(-1), required=True)
@coro
async def new(message: str):
    """
    Creates a new migration file.
    """
    files = _get_files()
    next_num = len(files) + 1
    f_message = list(' '.join(message)[:32].lower().replace(' ', '_'))
    filename_message = ''.join(filter(lambda c: c in string.ascii_lowercase + '_', f_message))
    f_name = '{:03d}_{}.py'.format(next_num, filename_message)
    formatted_file = migration_template.format(revision=next_num, message=(' '.join(message)))
    p = migrations_dir / 'versions' / f_name
    p.write_text(formatted_file)
    click.secho('Created new migration file {}.'.format(f_name))


def _get_files() -> typing.List[Path]:
    """
    Gets the migration files.
    """
    files = [x for x in (migrations_dir / 'versions').iterdir() if re.match('[0-9]+.*\\.py', x.name)]
    f = sorted(files, key=(lambda path: path.name))
    for n, path in enumerate(f):
        number = re.match('([0-9]+)', path.name)
        if not number:
            raise RuntimeError('Unable to match {}'.format(path.name))
        if int(number.groups()[0]) != n + 1:
            raise RuntimeError('Migration versions are missing entry {}'.format(n + 1))

    return f


async def _do_migrate(interface: DatabaseInterface, current_revision: int, revision: int):
    """
    Does a migration.
    """
    try:
        files = _get_files()
    except RuntimeError as e:
        click.secho(('Aborting upgrade: {}'.format(e.args[0])), fg='magenta')
        return

    if revision > current_revision:
        mode = 'upgrade'
        slice = files[current_revision:revision]
    else:
        mode = 'downgrade'
        if revision <= 0:
            slice = files[current_revision::-1]
        else:
            slice = files[current_revision:revision - 1:-1]
    if not slice:
        click.secho(('No migrations found to upgrade to revision {}.'.format(revision)), fg='magenta')
        return
    executed_revision = current_revision
    for migration in tqdm.tqdm(iterable=slice, desc='Migrating', unit='migrations'):
        data = migration.read_text()
        loc = {}
        exec(data, loc, loc)
        env = eval_env()
        upgrade_func = env['run_migration_online']
        try:
            migration_func = loc[mode]
        except KeyError:
            click.secho(("No function '{}' found in migration file {}!".format(mode, migration.name)),
              fg='magenta')
            return
        else:
            logger.info('Using migration file {}'.format(migration.name))
            logger.info('Calling migration function {}'.format(migration_func))
            async with interface.get_session() as sess:
                await upgrade_func(sess, migration_func)
                if mode == 'upgrade':
                    executed_revision += 1
                else:
                    executed_revision -= 1
                await sess.execute('UPDATE asql_version SET version = {val}', {'val': executed_revision})


if __name__ == '__main__':
    cli()
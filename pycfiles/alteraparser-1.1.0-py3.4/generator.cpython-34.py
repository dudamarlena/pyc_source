# uncompyle6 version 3.7.4
# Python bytecode 3.4 (3310)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-x86_64/egg/alteraparser/codegen/generator.py
# Compiled at: 2015-12-30 07:17:30
# Size of source mod 2**32: 12019 bytes
from alteraparser.parser import Parser
from alteraparser.bnf.grammar import bnf_grammar
from alteraparser.io.output import BufferedOutput
import re

class Generator(object):

    def __init__(self, output):
        self._Generator__bnf_parser = Parser(bnf_grammar)
        self._Generator__output = output
        self._Generator__indent_level = 0
        self._Generator__indent_size = 4
        self._Generator__fn_id_creator = FnIdCreator()
        self._Generator__functions = {}
        self._Generator__edit_section_start = re.compile('\\s*#--beginedit\\s+(\\S+)\\s*$')
        self._Generator__edit_section_end = re.compile('\\s*#--endedit\\s*$')
        self._Generator__options = {'case_sensitive': True}

    def generate_parser(self, grammar_input_stream, edit_sections={}):
        self._Generator__generate_header()
        self._Generator__writeln('from alteraparser import *')
        self._Generator__writeln('from alteraparser.ast import AST')
        self._Generator__writeln('from alteraparser.parser import Parser')
        self._Generator__writeln()
        self._Generator__writeln()
        ast = self._Generator__bnf_parser.parse(grammar_input_stream)
        grammar_name = self._Generator__find_grammar_name(ast)
        self._Generator__find_options(ast)
        self._Generator__writeln('def create_{}_parser():'.format(grammar_name))
        self._Generator__indent()
        self._Generator__writeln('return Parser({}())'.format(grammar_name))
        self._Generator__dedent()
        self._Generator__writeln()
        self._Generator__writeln()
        for node in ast.ast_children:
            if node.name == 'rule':
                self._Generator__generate_rule(node, edit_sections)
            elif node.name == 'grammar':
                self._Generator__generate_grammar(node, edit_sections)
                continue

        self._Generator__generate_internal_functions()

    def __find_grammar_name(self, ast):
        for rule in ast.ast_children:
            if rule.name == 'grammar':
                return rule.ast_children[0].text

        return ''

    def __find_options(self, ast):
        options = ast['option']
        for option in options:
            name = option['name'][0].text
            value = option['value'][0].text
            if name == 'case_sensitive':
                self._Generator__options[name] = value == 'on'
                continue

    def __generate_header(self):
        self._Generator__writeln('# This file has been generated by the alteraparser parser generator')
        self._Generator__writeln('# See http://www.tbollmeier.de/alteraparser for details')
        self._Generator__writeln('# ----- ATTENTION -----')
        self._Generator__writeln('# All manual changes that have not been made within editable sections will be overwritten!')
        self._Generator__writeln()

    def __generate_grammar(self, grammar, edit_sections):
        name = grammar.ast_children[0].text.lower()
        self._Generator__writeln('def _{}_trnsf(ast):'.format(name))
        self._Generator__indent()
        self._Generator__generate_edit_section(name, edit_sections)
        self._Generator__dedent()
        self._Generator__writeln()
        self._Generator__writeln()
        self._Generator__writeln('def {}():'.format(name))
        node = grammar.ast_children[1]
        branches = []
        if node.name == 'branches':
            for it in node.ast_children:
                branches.append(it)

        else:
            branches.append(node)
        self._Generator__indent()
        self._Generator__writeln('branches = []')
        for branch in branches:
            call = self._Generator__create_call(branch)
            self._Generator__writeln('branches.append({})'.format(call))

        line = "return grammar('{0}', branches, _{0}_trnsf)".format(name)
        self._Generator__writeln(line)
        self._Generator__dedent()
        self._Generator__writeln()
        self._Generator__writeln()

    def __generate_edit_section(self, section_name, edit_sections):
        self._Generator__writeln('#--beginedit {}'.format(section_name))
        if section_name in edit_sections:
            lines = edit_sections[section_name]
            for line in lines:
                self._Generator__output.writeln(line)

        else:
            self._Generator__writeln('return ast')
        self._Generator__writeln('#--endedit')

    def __generate_rule(self, rule, edit_sections):
        rule_name = rule.ast_children[0].text.lower()
        unique = rule.ast_children[2].text == 'true'
        self._Generator__writeln('def _{}_trnsf(ast):'.format(rule_name))
        self._Generator__indent()
        self._Generator__generate_edit_section(rule_name, edit_sections)
        self._Generator__dedent()
        self._Generator__writeln()
        self._Generator__writeln()
        line = "@group(name='{0}', is_unique={1}, transform_ast_fn=_{0}_trnsf)".format(rule_name, unique)
        self._Generator__writeln(line)
        line = 'def _{}(self, start, end):'.format(rule_name)
        self._Generator__writeln(line)
        self._Generator__indent()
        self._Generator__generate_fn_body(rule.ast_children[1])
        self._Generator__dedent()
        self._Generator__writeln()
        self._Generator__writeln()

    def __generate_fn_body(self, ast):
        body = self._Generator__create_fn_body(ast)
        for line in body:
            self._Generator__output.writeln(line)

    def __create_fn_body(self, ast):
        saved_output = self._Generator__output
        buf_output = BufferedOutput()
        self._Generator__output = buf_output
        if ast.name == 'branches':
            self._Generator__generate_branches_body(ast)
        else:
            if ast.name == 'branch':
                self._Generator__generate_branch_body(ast)
            else:
                if ast.name == 'comp':
                    self._Generator__generate_comp_body(ast)
                else:
                    self._Generator__output.writeln('pass')
        self._Generator__output = saved_output
        return buf_output.get_lines()

    def __create_call(self, ast):
        name = ast.name
        if name in ('branches', 'branch', 'comp'):
            call = '{}()'.format(self._Generator__create_fn(ast))
        else:
            if name == 'term':
                case_sensitive = self._Generator__options['case_sensitive']
                call = "keyword('{0}', case_sensitive={1})".format(ast.text, case_sensitive)
            else:
                if name == 'rule-name':
                    call = '_{}()'.format(ast.own_text.lower())
                else:
                    if name == 'WHITESPACE':
                        call = '_whitespace()'
                    else:
                        if name == 'range':
                            ch_from = ast['from'][0].text
                            ch_to = ast['to'][0].text
                            call = "char_range('{}', '{}')".format(ch_from, ch_to)
                        else:
                            if name == 'charset':
                                negate = ast['negate']
                                if not negate:
                                    char_nodes = ast.ast_children
                                else:
                                    char_nodes = ast.ast_children[1:]
                                chars = ''
                                prev_cname = ''
                                relevant_items = ['char', 'space', 'tab', 'newline']
                                for char_node in char_nodes:
                                    cname = char_node.name
                                    if chars:
                                        if prev_cname in relevant_items and cname in relevant_items:
                                            chars += ', '
                                    if cname == 'char':
                                        chars += "'{}'".format(char_node.text)
                                    elif cname in ('space', 'tab', 'newline'):
                                        chars += "'{}'".format({'space': ' ', 
                                         'tab': '\\t', 
                                         'newline': '\\n'}[cname])
                                    prev_cname = cname

                                call = 'characters({})'.format(chars)
                                if negate:
                                    call += '.negate()'
                            else:
                                if name in ('space', 'tab', 'newline'):
                                    call = "single_char('{}')".format({'space': ' ', 
                                     'tab': '\\t', 
                                     'newline': '\\n'}[name])
                                else:
                                    raise GeneratorError("Unsupported grammar element '{}'".format(name))
        id_nodes = ast['id']
        if id_nodes:
            id_node = id_nodes[0]
            call = self._Generator__add_id(call, id_node)
        card = ast['cardinality']
        if card:
            call = self._Generator__add_cardinality(call, card[0])
        return call

    def __add_cardinality(self, call, card):
        use_whitespace = len(card.ast_children) == 1
        mult = card.ast_children[0]
        if use_whitespace:
            ws = 'one_to_many(_whitespace())'
            if mult.name == 'zero-to-one':
                res = 'optional({})'.format(call)
            else:
                if mult.name == 'one-to-many':
                    res = 'fork([{0}, many(fork([{1}, {0}]))])'.format(call, ws)
                else:
                    if mult.name == 'many':
                        res = 'optional(fork([{0},'.format(call)
                        res += ' many(fork([{0}, {1}]))]))'.format(ws, call)
                    else:
                        raise GeneratorError()
            return res
        else:
            fn_name = {'zero-to-one': 'optional', 
             'one-to-many': 'one_to_many', 
             'many': 'many'}[mult.name]
            return '{}({})'.format(fn_name, call)

    def __add_id(self, call, id_node):
        return "{}.set_id('{}')".format(call, id_node.text)

    def __generate_branches_body(self, branches):
        for branch in branches.ast_children:
            call = self._Generator__create_call(branch)
            self._Generator__writeln('start > {} > end'.format(call))

    def __generate_branch_body(self, branch):
        self._Generator__writeln('curr = start')
        prev_item = None
        for item in branch.ast_children:
            if item.name == 'no-ws':
                pass
            else:
                if item.name == 'optional-ws':
                    self._Generator__writeln('curr = curr > many(_whitespace())')
                else:
                    if prev_item:
                        if prev_item.name not in ('no-ws', 'optional-ws'):
                            self._Generator__writeln('curr = curr > one_to_many(_whitespace())')
                    call = self._Generator__create_call(item)
                    self._Generator__writeln('curr = curr > {}'.format(call))
                prev_item = item

        self._Generator__writeln('curr > end')

    def __generate_comp_body(self, comp):
        call = self._Generator__create_call(comp.ast_children[0])
        self._Generator__writeln('start > {} > end'.format(call))

    def __generate_internal_functions(self):
        fn_ids = list(self._Generator__functions.keys())
        fn_ids.sort()
        for fn_id in fn_ids:
            self._Generator__writeln('@group()')
            self._Generator__writeln('def {}(self, start, end):'.format(fn_id))
            self._Generator__indent()
            body = self._Generator__functions[fn_id]
            for line in body:
                self._Generator__output.writeln(line)

            self._Generator__dedent()
            self._Generator__writeln()
            self._Generator__writeln()

    def __create_fn(self, ast):
        fn_id = self._Generator__fn_id_creator.create_id(ast.name)
        self._Generator__functions[fn_id] = self._Generator__create_fn_body(ast)
        return fn_id

    def __indent(self):
        self._Generator__indent_level += 1

    def __dedent(self):
        self._Generator__indent_level -= 1

    def __writeln(self, text=''):
        text = self._Generator__indent_level * self._Generator__indent_size * ' ' + text
        self._Generator__output.writeln(text)

    def scan_for_edit_sections(self, stream):
        edit_sections = {}
        section_name = ''
        lines = []
        line = ''
        while stream.has_next_char():
            ch = stream.get_next_char()
            if ch != '\n':
                line += ch
            else:
                if not section_name:
                    match = self._Generator__edit_section_start.match(line)
                    if match:
                        section_name = match.group(1)
                        lines = []
                else:
                    match = self._Generator__edit_section_end.match(line)
                    if match:
                        edit_sections[section_name] = lines
                        section_name = ''
                        lines = []
                    else:
                        lines.append(line)
                line = ''

        return edit_sections


class FnIdCreator(object):

    def __init__(self):
        self._FnIdCreator__ids = {}

    def create_id(self, prefix):
        if prefix in self._FnIdCreator__ids:
            id_ = self._FnIdCreator__ids[prefix] + 1
        else:
            id_ = 1
        self._FnIdCreator__ids[prefix] = id_
        return '_{}_{}'.format(prefix, id_)


class GeneratorError(Exception):
    pass
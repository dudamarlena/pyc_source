# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /Users/dunfield/snappy/build/lib.macosx-10.6-intel-2.7/snappy/verify/squareExtensions.py
# Compiled at: 2019-07-15 23:56:54
"""
The squareExtensions module provides
two special classes to give exact representations of the values
involved when computing a cusp cross section.

The method find_shapes_as_complex_sqrt_lin_combinations returns a list of
shapes as ComplexSqrtLinCombination's. This can be used as input to
CuspCrossSection. The outputs of CuspCrossSection, including the tilts, will
then be of type SqrtLinCombination.

Consider the real number field N generated by the real and imaginary part of
the shapes. The edge lengths and the factors used to normalize the cusp areas
will be square roots in N and thus the tilts will be N-linear combinations of
square roots in N. To avoid computing in a massive tower of square extensions
of N, we implement SqrtLinCombination here that provides a special
implementation of the == operator.
"""
import operator
from functools import reduce
from ..sage_helper import _within_sage, sage_method, SageNotAvailable
__all__ = [
 'find_shapes_as_complex_sqrt_lin_combinations',
 'SqrtLinCombination',
 'ComplexSqrtLinCombination']
if _within_sage:
    from sage.rings.complex_interval_field import ComplexIntervalField
    from sage.rings.real_mpfi import RealIntervalField
    from sage.rings.integer import Integer
    from sage.rings.rational import Rational
    from sage.rings.number_field.number_field_element import NumberFieldElement
    from sage.rings.complex_number import create_ComplexNumber
    from sage.functions.other import sqrt
    _Zero = Integer(0)
    _One = Integer(1)
    from ..snap import find_field
from .realAlgebra import field_containing_real_and_imaginary_part_of_number_field

def eval_number_field_elt(elt, root):
    if elt.is_zero():
        return _Zero
    poly = elt.lift()
    R = poly.base_ring()
    coeffs = poly.coefficients()
    exps = poly.exponents()
    powers = [R(1)]
    for i in range(max(exps)):
        powers.append(powers[(-1)] * root)

    return sum(c * powers[e] for c, e in zip(coeffs, exps))


@sage_method
def find_shapes_as_complex_sqrt_lin_combinations(M, prec, degree):
    """
    Given a manifold M, use snap (which uses LLL-algorithm) with the given
    decimal precision and maximal degree to find exact values for the shapes'
    real and imaginary part. Return the shapes as list of
    ComplexSqrtLinCombination's. Return None on failure.

    Example::

       sage: from snappy import Manifold
       sage: M=Manifold("m412")
       sage: find_shapes_as_complex_sqrt_lin_combinations(M, 200, 10)
       [ComplexSqrtLinCombination((1/2) * sqrt(1), (x - 1/2) * sqrt(1)), ComplexSqrtLinCombination((1/2) * sqrt(1), (x - 1/2) * sqrt(1)), ComplexSqrtLinCombination((1/2) * sqrt(1), (x - 1/2) * sqrt(1)), ComplexSqrtLinCombination((1/2) * sqrt(1), (x - 1/2) * sqrt(1)), ComplexSqrtLinCombination((1/2) * sqrt(1), (x - 1/2) * sqrt(1))]
    """
    complex_data = M.tetrahedra_field_gens().find_field(prec, degree)
    if not complex_data:
        return None
    else:
        complex_number_field, complex_root, exact_complex_shapes = complex_data
        real_result = field_containing_real_and_imaginary_part_of_number_field(complex_number_field)
        if not real_result:
            return None
        real_number_field, real_part, imag_part = real_result
        embed_cache = {}
        exact_complex_root = ComplexSqrtLinCombination(real_part, imag_part, embed_cache=embed_cache)
        return [ eval_number_field_elt(exact_complex_shape, exact_complex_root) for exact_complex_shape in exact_complex_shapes
               ]


class SqrtLinCombination(object):
    """
    A class representing a linear combination

        c_1 * sqrt(r_1) + c_2 * sqrt(r_2) + ... + c_n * sqrt(r_n)

    where c_i and r_i have to be of type Integer, Rational or elements
    of the same Sage NumberField with a real embedding (Caution: this is
    assumed but not checked!) such that all r_i are positive (Caution: this is
    not checked during construction!).

    It implements +, -, * where one of the operators is allowed to be an
    integer or rational.

    / is only implemented when the denominator has only one term c_1 * sqrt(1).
    sqrt is only implemented for c_1 * sqrt(1) and it is not checked that
    c_1 is positive.

    == is implemented, but the other comparison operators are not: casting to
    a RealIntervalField is implemented instead and the user can compare the
    intervals.

    The == operator is implemented by first reducing A == B to D == 0 and then
    converting to a different data type (_FactorizedSqrtLinCombination) that can
    represent linear combinations::

      D =     c_1 * sqrt(r_{1,1}) * sqrt(r_{1,2}) * ... * sqrt(r_{1,k_1})
            + c_2 * sqrt(r_{2,1}) * sqrt(r_{2,2}) * ... * sqrt(r_{2,k_2})
            + ...
            + c_n * sqrt(r_{n,1}) * sqrt(r_{n,2}) * ... * sqrt(r_{n,k_n})

    by just trivially setting
       k_i = 0                       when r_i = 1 and
       r_{i,1} = r_i and k_1 = 1     otherwise.

    For this data type, multiplying two sqrt(r_{i,j}) with equal r_{i,j} will
    cancel the two sqrt's and apply the common r_{i,j} to the c_i of the result
    instead. Thus, the following procedure for determining whether D == 0 will
    eventually terminate:
    
    - if the number of terms n is 0, return True
    - if the number of terms n is 1, return c_1 == 0
    - if there is a r_{i,j} common to each summand, factor it out
    - pick one of the r_{i,j}, split the sum into two parts "left",
      respectively, "right" of all the terms containing sqrt(r_{i,j}),
      respectively, not containing sqrt(r_{i,j}).
    - If left^2 - right^2 == 0 is False, return False.
      (sqrt(r_{i,j})^2 simplifies to r_{i,j} and disappears, so the resulting
      expression is easier and this recursion terminates eventually.)
    - If left == 0 (some comment applies), return True
    - Use interval arithmetic of increasing precision until it is high enough
      to determine the signs of left and right.
      Return True if and only if the signs differ, otherwise False.

    Examples::

        sage: from sage.rings.number_field.number_field import NumberField
        sage: from sage.rings.integer import Integer
        sage: from sage.rings.rational import Rational
        sage: from sage.rings.real_mpfr import RealLiteral, RealField
        sage: from sage.rings.real_mpfi import RealIntervalField
        sage: from sage.calculus.var import var
        sage: from sage.functions.other import sqrt
        sage: x = var('x')
        sage: poly = x ** 6 + Rational((3,2))*x**4 + Rational((9,16))*x**2 - Rational((23,64))
        sage: nf = NumberField(poly, 'z', embedding = RealField()(0.56227951206))
        sage: z = nf.gen()

        sage: A = SqrtLinCombination(z)
        sage: B = SqrtLinCombination(Rational((8,9))*z**4 + Rational((10,9))*z**2 + Rational((2,9)))
        sage: C = SqrtLinCombination(3)
        sage: D = SqrtLinCombination(Integer(5))
        sage: E = SqrtLinCombination(Rational((6,7)))

        sage: A + B
        (8/9*z^4 + 10/9*z^2 + z + 2/9) * sqrt(1)
        sage: B - E
        (8/9*z^4 + 10/9*z^2 - 40/63) * sqrt(1)
        sage: A + sqrt(B) * sqrt(B)
        (8/9*z^4 + 10/9*z^2 + z + 2/9) * sqrt(1)
        sage: A + sqrt(B) * sqrt(B) + C == A + B + C
        True
        sage: A / E
        (7/6*z) * sqrt(1)
        sage: B / A.sqrt()
        (128/207*z^5 + 376/207*z^3 + 302/207*z) * sqrt(z)
        sage: B / (D * A.sqrt())
        (128/1035*z^5 + 376/1035*z^3 + 302/1035*z) * sqrt(z)
        sage: RIF = RealIntervalField(100)
        sage: RIF(B.sqrt() + E.sqrt())
        1.73967449622339881238507307209?
        sage: A - B == 0
        False
        sage: (A + B).sqrt()
        (1) * sqrt(8/9*z^4 + 10/9*z^2 + z + 2/9)
        sage: 3 * A.sqrt() + (4 * B).sqrt() + C + 8 == (9 * A).sqrt() + 2 * B.sqrt() + (C * C).sqrt() + 11 - 3
        True

    """

    def __init__(self, value=None, d={}, embed_cache=None):
        if value is not None:
            if d:
                raise TypeError('SqrtLinCombination has both value and dictionary.')
            self._dict = _filter_zero({_One: _convert_to_allowed_type(value)})
        else:
            self._dict = _filter_zero(d)
        self._embed_cache = embed_cache
        return

    def __add__(self, other):
        if not isinstance(other, SqrtLinCombination):
            return self + SqrtLinCombination(other, embed_cache=_get_embed_cache(self, other))
        d = {}
        for k, v in self._dict.items():
            d[k] = d.get(k, 0) + v

        for k, v in other._dict.items():
            d[k] = d.get(k, 0) + v

        return SqrtLinCombination(d=d, embed_cache=_get_embed_cache(self, other))

    def __neg__(self):
        return SqrtLinCombination(d=dict((k, -v) for k, v in self._dict.items()), embed_cache=self._embed_cache)

    def __sub__(self, other):
        return self + -other

    def __mul__(self, other):
        if not isinstance(other, SqrtLinCombination):
            return self * SqrtLinCombination(other, embed_cache=_get_embed_cache(self, other))
        d = {}
        for k1, v1 in self._dict.items():
            for k2, v2 in other._dict.items():
                p = v1 * v2
                if k1 == k2:
                    d[_One] = d.get(_One, 0) + k1 * p
                else:
                    m = k1 * k2
                    d[m] = d.get(m, 0) + p

        return SqrtLinCombination(d=d, embed_cache=_get_embed_cache(self, other))

    def inverse(self):
        l = len(self._dict)
        if not l == 1:
            if l == 0:
                raise ZeroDivisionError('SqrtLinCombination division by zero')
            raise TypeError('SqrtLinCombination division not fully implemented')
        for k, v in self._dict.items():
            return SqrtLinCombination(d={k: 1 / (v * k)}, embed_cache=self._embed_cache)

    def __div__(self, other):
        if not isinstance(other, SqrtLinCombination):
            return self / SqrtLinCombination(other, embed_cache=_get_embed_cache(self, other))
        return self * other.inverse()

    def __truediv__(self, other):
        return self.__div__(other)

    def __radd__(self, other):
        return self + other

    def __rsub__(self, other):
        return -self + other

    def __rmul__(self, other):
        return self * other

    def __rdiv__(self, other):
        return self.inverse() * other

    def __rtruediv__(self, other):
        return self.__rdiv__(other)

    def sqrt(self):
        l = len(self._dict)
        if l == 0:
            return SqrtLinCombination(embed_cache=self._embed_cache)
        if l == 1:
            for k, v in self._dict.items():
                if not k == 1:
                    raise TypeError('SqrtLinCombination sqrt not fully implemented')
                return SqrtLinCombination(d={v: _One}, embed_cache=self._embed_cache)

        raise TypeError('SqrtLinCombination sqrt not fully implemented')

    def __repr__(self):
        if self._dict:
            return ('+').join([ '(%r) * sqrt(%r)' % (v, k) for k, v in self._dict.items() ])
        return '0'

    def __eq__(self, other):
        """
        Implements the == operator as described above.
        """
        diff = self - other
        f = _FactorizedSqrtLinCombination.from_sqrt_lin_combination(diff)
        return f.is_zero()

    def __lt__(self, other):
        raise Exception('Not implemented')

    def __le__(self, other):
        raise Exception('Not implemented')

    def __gt__(self, other):
        raise Exception('Not implemented')

    def __ge__(self, other):
        raise Exception('Not implemented')

    def _real_mpfi_(self, RIF):
        """
        Convert to interval in given RealIntervalField instance.
        """

        def eval_term(k, v):
            s = _to_RIF(k, RIF, self._embed_cache)
            if not s > 0:
                raise _SqrtException()
            return _to_RIF(v, RIF, self._embed_cache) * s.sqrt()

        return sum([ eval_term(k, v) for k, v in self._dict.items() ], RIF(0))

    def _sign_numerical(self, prec):
        """
        Use interval arithmetics with precision prec to try to determine the
        sign. If we could not certify the sign, return None.
        The result is a pair (sign, interval).
        """
        RIF = RealIntervalField(prec)
        try:
            interval_val = RIF(self)
        except _SqrtException:
            return (None, None)

        if interval_val > 0:
            return (+1, interval_val)
        else:
            if interval_val < 0:
                return (-1, interval_val)
            return (None, interval_val)

    def sign_with_interval(self):
        """
        Similar to sign, but for the non-zero case, also return the interval
        certifying the sign - useful for debugging.
        """
        prec = 106
        numerical_sign, interval_val = self._sign_numerical(prec)
        if numerical_sign is not None:
            return (
             numerical_sign, interval_val)
        else:
            if self == 0:
                return (0, 0)
            while True:
                prec *= 2
                numerical_sign, interval_val = self._sign_numerical(prec)
                if numerical_sign is not None:
                    return (numerical_sign, interval_val)

            return

    def sign(self):
        """
        Returns the +1, 0, -1 depending on whether the value is positive,
        zero or negative. For the zero case, exact artihmetic is used to
        certify. Otherwise, interval arithmetic is used.
        
        """
        return self.sign_with_interval()[0]


class ComplexSqrtLinCombination(object):
    """
    A pair (real, imag) of SqrtLinCombinations representing the complex number
    real + imag * I. Supports ``real()``, ``imag()``, ``+``, ``-``, ``*``, ``/``,
    ``abs``, ``conjugate()`` and ``==``.
    """

    def __init__(self, real, imag=0, embed_cache=None):
        if isinstance(real, SqrtLinCombination):
            self._real = real
        else:
            self._real = SqrtLinCombination(real, embed_cache=embed_cache)
        if isinstance(imag, SqrtLinCombination):
            self._imag = imag
        else:
            self._imag = SqrtLinCombination(imag, embed_cache=embed_cache)

    def __repr__(self):
        return 'ComplexSqrtLinCombination(%r, %r)' % (self._real, self._imag)

    def real(self):
        """
        Real part.
        """
        return self._real

    def imag(self):
        """
        Imaginary part.
        """
        return self._imag

    def __abs__(self):
        """
        Absolute value.
        """
        return sqrt(self._real * self._real + self._imag * self._imag)

    def __add__(self, other):
        if not isinstance(other, ComplexSqrtLinCombination):
            return self + ComplexSqrtLinCombination(other)
        return ComplexSqrtLinCombination(self._real + other._real, self._imag + other._imag)

    def __neg__(self):
        return ComplexSqrtLinCombination(-self._real, -self._imag)

    def __sub__(self, other):
        return self + -other

    def __mul__(self, other):
        if not isinstance(other, ComplexSqrtLinCombination):
            return self * ComplexSqrtLinCombination(other)
        return ComplexSqrtLinCombination(self._real * other._real - self._imag * other._imag, self._real * other._imag + self._imag * other._real)

    def __div__(self, other):
        if not isinstance(other, ComplexSqrtLinCombination):
            return self / ComplexSqrtLinCombination(other)
        num = 1 / (other._real * other._real + other._imag * other._imag)
        return ComplexSqrtLinCombination((self._real * other._real + self._imag * other._imag) * num, (other._real * self._imag - self._real * other._imag) * num)

    def __truediv__(self, other):
        return self.__div__(other)

    def conjugate(self):
        return ComplexSqrtLinCombination(self._real, -self._imag)

    def __radd__(self, other):
        return self + other

    def __rsub__(self, other):
        return -self + other

    def __rmul__(self, other):
        return self * other

    def __rdiv__(self, other):
        return ComplexSqrtLinCombination(other) / self

    def __rtruediv__(self, other):
        return self.__rdiv__(other)

    def __eq__(self, other):
        if not isinstance(other, ComplexSqrtLinCombination):
            return self == ComplexSqrtLinCombination(other)
        return self._real == other._real and self._imag == other._imag

    def __ne__(self, other):
        return not self == other

    def __lt__(self, other):
        raise TypeError('No order on complex numbers.')

    def __le__(self, other):
        raise TypeError('No order on complex numbers.')

    def __gt__(self, other):
        raise TypeError('No order on complex numbers.')

    def __ge__(self, other):
        raise TypeError('No order on complex numbers.')

    def _complex_mpfi_(self, CIF):
        """
        Convert to complex interval in given ComplexIntervalField instance.
        """
        RIF = CIF(0).real().parent()
        return CIF(RIF(self._real), RIF(self._imag))


class _SqrtException(Exception):
    pass


class _FactorizedSqrtLinCombination(object):

    def __init__(self, d={}, embed_cache=None):
        self._dict = _filter_zero(d)
        self._embed_cache = embed_cache

    def _real_mpfi_(self, RIF):

        def eval_term(k, v):
            prod = reduce(operator.mul, [ _to_RIF(t, RIF, self._embed_cache) for t in k ], RIF(1))
            if not prod > 0:
                raise _SqrtException()
            return prod.sqrt() * _to_RIF(v, RIF, self._embed_cache)

        return sum([ eval_term(k, v) for k, v in self._dict.items() ], RIF(0))

    def __repr__(self):
        if not self._dict:
            return '0'

        def term(item):
            k, v = item
            b = '(%r)' % v
            for s in k:
                b += ' * sqrt(%r)' % s

            return b

        return ('+').join([ term(item) for item in self._dict.items() ])

    @staticmethod
    def from_sqrt_lin_combination(l):
        """
        Construct from a SqrtLinCombination.
        """

        def to_set(k):
            if k == _One:
                return frozenset()
            else:
                return frozenset([k])

        return _FactorizedSqrtLinCombination(dict((to_set(k), v) for k, v in l._dict.items()), embed_cache=l._embed_cache)

    def __add__(self, other):
        d = {}
        for k, v in self._dict.items():
            d[k] = d.get(k, 0) + v

        for k, v in other._dict.items():
            d[k] = d.get(k, 0) + v

        return _FactorizedSqrtLinCombination(d, embed_cache=_get_embed_cache(self, other))

    def __neg__(self):
        return _FactorizedSqrtLinCombination(dict((k, -v) for k, v in self._dict.items()), embed_cache=self._embed_cache)

    def __sub__(self, other):
        return self + -other

    def __mul__(self, other):
        d = {}
        for k1, v1 in self._dict.items():
            for k2, v2 in other._dict.items():
                k = k1 ^ k2
                v = v1 * v2 * _prod(k1 & k2)
                d[k] = d.get(k, 0) + v

        return _FactorizedSqrtLinCombination(d, embed_cache=_get_embed_cache(self, other))

    def is_zero(self):
        """
        Returns True if it is zero, False otherwise.
        """
        if not self._dict:
            return True
        else:
            if len(self._dict) == 1:
                return _first(self._dict.values()) == 0
            common_terms = reduce(operator.and_, self._dict.keys())
            d = dict((k - common_terms, v) for k, v in self._dict.items())
            term = _firstfirst(d.keys())
            left = _FactorizedSqrtLinCombination(dict((k, v) for k, v in d.items() if term in k), embed_cache=self._embed_cache)
            right = _FactorizedSqrtLinCombination(dict((k, v) for k, v in d.items() if term not in k), embed_cache=self._embed_cache)
            if not (left * left - right * right).is_zero():
                return False
            if left.is_zero():
                return True
            prec = 53
            while True:
                opposite_signs = _opposite_signs(left, right, prec)
                if opposite_signs is not None:
                    return opposite_signs
                prec *= 2

            return


def _opposite_signs(left, right, prec):
    """
    Given two objects left and right that can be coerced to real interval of
    the given precision, try to certify their signs. If succeed, return True
    if the signs are opposite and False otherwise. If failed, return None.
    """
    RIF = RealIntervalField(prec)
    try:
        left_interval = RIF(left)
        right_interval = RIF(right)
    except _SqrtException:
        return

    left_negative = bool(left_interval < 0)
    left_positive = bool(left_interval > 0)
    left_determined = left_negative or left_positive
    right_negative = bool(right_interval < 0)
    right_positive = bool(right_interval > 0)
    right_determined = right_negative or right_positive
    if left_determined and right_determined:
        return left_positive ^ right_positive
    else:
        return


def _first(iterable):
    """
    Return first element of iterable.
    """
    for i in iterable:
        return i


def _firstfirst(iterable):
    """
    Given a nested iterable, i.e., list of lists, return the first element
    of the first non-empty element.
    """
    for i in iterable:
        for j in i:
            return j


def _prod(s):
    """
    The product of the elements in s. Returns Sage Integer(1)
    when s is empty.
    """
    return reduce(operator.mul, s, _One)


def _filter_zero(d):
    """
    Given a dict, filter out all items where the value is 0.
    """
    return dict((k, v) for k, v in d.items() if not v == 0)


def _convert_to_allowed_type(number):
    """
    When given a Python int, convert to Sage Integer (so that
    division of two integers gives a Rational). Otherwise,
    check that the type is allowed.
    """
    if isinstance(number, int):
        return Integer(number)
    if isinstance(number, Integer):
        return number
    if isinstance(number, Rational):
        return number
    if isinstance(number, NumberFieldElement):
        return number
    raise Exception('Not an allowed type')


def _get_embed_cache(l1, l2):
    """
    Given objects of type SqrtLinCombination or _FactorizedSqrtLinCombination
    return the first _embed_cache that is not None.
    For example, one SqrtLinCombination might be instantiated from an
    Integer and the other from an element in the number field that we are
    currently working in. Then only the latter one has an _embed_cache. Thus,
    the need for this function when adding, multiplying, ... those two
    instances.
    """
    for l in [l1, l2]:
        if (isinstance(l, SqrtLinCombination) or isinstance(l, _FactorizedSqrtLinCombination)) and l._embed_cache is not None:
            return l._embed_cache

    return


def _get_interval_embedding_from_cache(nf, RIF, cache):
    """
    Evaluate RIF(nf.gen_embedding()) where RIF is a RealIntervalField with
    some precision. This is a real interval that is guarenteed to contain the
    prefered root of the defining polynomial of the number field.

    To avoid re-evaluation, use cache which is (a reference) to a python
    dictionary.

    The idea is that while working over one number field, all instances of
    (_Factorized)SqrtLinCombination have a reference to the same (shared) python
    dictionary and fill it in as needed.

    Unfortunately, the reference to the cache needs to passed down along a lot
    of places. There might be a nicer mechanism for doing this.
    """
    if cache is not None and 'gen_embedding' in cache:
        gen_embedding = cache['gen_embedding']
    else:
        gen_embedding = nf.gen_embedding()
        if cache is not None:
            cache['gen_embedding'] = gen_embedding
    prec = RIF.prec()
    if cache is not None and prec in cache:
        return cache[prec]
    else:
        interval = RIF(gen_embedding)
        if cache is not None:
            cache[prec] = interval
        return interval


def _to_RIF(x, RIF, embed_cache=None):
    """
    Given a Sage Integer, Rational or an element x in a
    Sage NumberField with a real embedding and an instance
    of a RealIntervalField to specify the desired precision,
    return a real interval containing the true value of x.

    Warning: one can actually call RIF(x) and get an interval, but I have
    found examples where that interval does not contain the true value!
    Seems a bug in Sage. CIF(x) doesn't work, so maybe there is just some
    sequence of casts going on to convert x to an interval that wasn't
    anticipated.
    """
    if isinstance(x, Integer) or isinstance(x, Rational):
        return RIF(x)
    nf = x.parent()
    root = _get_interval_embedding_from_cache(nf, RIF, embed_cache)
    if not nf.defining_polynomial()(root).contains_zero():
        raise Exception('Root failed test.')
    return x.lift()(root)


if __name__ == '__main__':
    import doctest
    doctest.testmod()
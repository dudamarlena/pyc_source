# uncompyle6 version 3.6.7
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: /home/bill/py3/.virtualenvs/pytest/lib/python2.7/site-packages/Csys/Parsebraces.py
# Compiled at: 2009-11-24 21:22:40
__doc__ = 'Celestial Software\'s configuration file processing.\n\nThis package parses an input file returning an object hash with\narray references to an array of the highest level elements\nparsed.  It assumes that logical elements are surrounded by\ncurley braces or parenthesis.\n\n=head1 USAGE\n\nimport Csys.Parsebraces;\n\n    config = Csys.Parsebraces("filename")\n    rlines = obj.lines # lines\n    rargs = obj.args;   # string arguments\n\n=head1 EXAMPLES\n\nThis might be used to parse the DNS configuration files:\n\n    import Csys.Parsebraces\n    config = Csys.Parsebraces.Config("/etc/named.conf")\n    To parse the lines, a general routine might be\n\n    options = {}\n    zones   = {}\n\n    for line in config.get_lines(): #{\n        args = line.split()\n        keyword = args.pop(0)\n        if(keyword == \'options\'): #{{\n            # process global options;\n            options[keyword] = \' \'.join(args)\n        #}\n        elif(keyword == \'zone\'): #{\n            name = args.pop(0)\n            zones[name] = Zone(config, name, args)\n        #}}\n    #}\n    class Zone: #{\n        def __init__(self, config, name, args): #{\n            ndx = args.pop() # last argument\n            my $index = pop(@args); # get last argument\n            self.name = name\n            for line in config.get_text_array(ndx): #{\n                args1 = line.split()\n                keyword = args1.pop(0)\n                if(keyword in (\'type\', \'file\'): #{{ # simple arguments\n                    self.__dict__[keyword] = args[-1]\n                #}\n                # these require further parsing of elements in braces.\n                elif(keyword == \'masters\'):# {\n                    self.masters = Master(args1);\n                #}\n                elsf(keyword == \'transfer-allowed\'): #{\n                    self.transfer_allowed = Transfer(args1);\n                #}}\n                ...\n            #}}\n        #} __init__\n    #} class Zone\n\n$Id: Parsebraces.py,v 1.3 2009/11/25 02:22:40 csoftmgr Exp $'
__version__ = '$Revision: 1.3 $'[11:-2]
import Csys, os, sys, re
_patBraces = re.compile('[{(]([^{}()]*)[)}]')
_patIndex = re.compile('^(.*)\\s+(\\d+);*$')

class Config(Csys.CSClass):
    """Configuration parsed from file"""
    _attributes = {'lines': [], 'args': []}

    def __init__(self, input):
        """Parse configuration file"""
        Csys.CSClass.__init__(self)
        self.lines = Csys.rmComments(input, C=True, Cplusplus=True, wantarray=True, pattern='.')
        input = ('\n').join(self.lines)
        while True:
            reg = _patBraces.search(input)
            if not reg:
                break
            n = len(self.args)
            self.args.append(reg.group(1))
            input = _patBraces.sub('%d' % n, input, 1)

        self.lines = [ line.rstrip() for line in input.split('\n') if line.rstrip() ]

    def get_text_array(self, idx):
        """get array by splitting the line from arg_strings"""
        if isinstance(idx, basestring):
            idx = int(idx.rstrip(';'))
        val = self.args[idx]
        lines = []
        for line in val.splitlines():
            if line:
                lines.append(line)

        return lines

    def split_line(self, ndx):
        """Break line into key, options, and index"""
        parts = self.lines[ndx].rstrip(';').split()
        return (
         parts[0], parts[1:-1], int(parts[(-1)]))

    def get_line_parts(self):
        """return key, options, index from line"""
        output = []
        for line in self.lines:
            parts = line.rstrip(';').split()
            output.append((parts[0], parts[1:-1], int(parts[(-1)])))

        return output

    def get_lines(self):
        return self.lines

    def dumpall(self):
        """Hopefully dump out original without comments"""
        outlines = []
        for line in self.lines:
            r = _patIndex.search(line)
            if r:
                pre, idx = r.group(1), int(r.group(2))
                outlines.append(pre)
                outlines += ['{', self.get_text_array(idx), '}']
            else:
                outlines.append(line)

        return outlines


if __name__ == '__main__':
    print 'OK'
    testinput = '\n// generated by named-bootconf.pl\n\noptions {\n\tdirectory "/usr/local/lib/named";\n\tcheck-names master warn;\n\tcheck-names slave warn;\n\tpid-file "/etc/named.pid";\n\t/*\n\t * If there is a firewall between you and nameservers you want\n\t * to talk to, you might need to uncomment the query-source\n\t * directive below.  Previous versions of BIND always asked\n\t * questions using port 53, but BIND 8.1 uses an unprivileged\n\t * port by default.\n\t */\n\t// query-source address * port 53;\n};\n\n// \n// Celestial Software nameserver boot file\n// \n// type\t\tdomain\t\t\t\tsource file or host\nzone "." {\n\ttype hint;\n\tfile "named.ca";\n};\n\nzone "0.0.127.in-addr.arpa" {\n\ttype master;\n\tfile "primary/0.0.127.in-addr.arpa";\n};\nzone "111.136.192.in-addr.arpa" {\n\ttype slave;\n\tfile "secondary/111.136.192.in-addr.arpa";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tmasters {\n\t\t192.136.111.40;\n\t};\n};\nzone "254.168.192.in-addr.arpa" {\n\ttype slave;\n\tfile "secondary/254.168.192.in-addr.arpa";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tallow-query {\n\t\t127.0.0.1;\n\t\t192.136.111.0/24;\n\t\t192.168.254.0/24;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t192.136.111.0/24;\n\t\t192.168.254.0/24;\n\t};\n\tmasters {\n\t\t192.136.111.40;\n\t};\n};\nzone "celestial.com" {\n\ttype slave;\n\tfile "secondary/celestial.com";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tmasters {\n\t\t192.136.111.3;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t204.57.191.163;\n\t\t204.57.191.242;\n\t};\n};\nzone "mi.celestial.com" {\n\ttype slave;\n\tfile "secondary/mi.celestial.com";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tallow-query {\n\t\t127.0.0.1;\n\t\t192.168.254.0/24;\n\t\t192.136.111.0/24;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t192.168.254.0/24;\n\t\t192.136.111.0/24;\n\t};\n\tmasters {\n\t\t192.136.111.3;\n\t};\n};\nzone "celestial.net" {\n\ttype slave;\n\tfile "secondary/celestial.net";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.7;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t192.136.111.0/24;\n\t\t192.168.254.0/24;\n\t\t204.57.191.1;\n\t};\n\tmasters {\n\t\t192.136.111.40;\n\t};\n};\nzone "rbl.celestial.net" {\n\ttype slave;\n\tfile "secondary/rbl.celestial.net";\n\tallow-update {\n\t\t127.0.0.1;\n\t\t192.136.111.1;\n\t\t192.136.111.3;\n\t\t192.136.111.40;\n\t\t192.136.111.59;\n\t\t192.168.254.0/24;\n\t};\n\tallow-transfer {\n\t\t127.0.0.1;\n\t\t192.168.254.0/24;\n\t\t192.136.111.0/24;\n\t};\n\tmasters {\n\t\t192.136.111.40;\n\t};\n};\n'
    fhout = open('/tmp/named.conf', 'w')
    fhout.write(testinput)
    fhout.close()
    t = Config(open('/tmp/named.conf'))
    for line in t.lines:
        print line
        args = line.split()
        idx = int(args[(len(args) - 1)][:-1])
        txta = t.get_text_array(idx)
        print txta

    print t.dumpall()
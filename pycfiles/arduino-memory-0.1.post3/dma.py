# uncompyle6 version 3.6.7
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: c:\users\christian\documents\github\arduino_helpers\arduino_helpers\hardware\teensy\dma.py
# Compiled at: 2015-11-11 17:01:34
import io, pandas as pd
TCD_DESCRIPTIONS_TSV = ('\nfull_name\tshort_description\tdescription\tpage\nSADDR\tSource Address\tMemory address pointing to the source data.\t21.3.17/415\nSOFF\tSource Address Signed offset\tSign-extended offset applied to the current source address to form the next-state value as each source read is completed.\t21.3.18/415\nATTR.SMOD\tSource Address Modulo.\t0: Source address modulo feature is disabled, Not 0: This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed or the original register value. The setting of this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.\t21.3.19/416\nATTR.SSIZE\tSource data transfer size\t000: 8-bit, 001: 16-bit, 010: 32-bit, 100: 16-byte\t21.3.19/416\nATTR.DMOD\tDestination Address Modulo\t0: Destination address modulo feature is disabled, Not 0: This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed or the original register value. The setting of this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.\t21.3.19/416\nATTR.DSIZE\tDestination data transfer size\t000: 8-bit, 001: 16-bit, 010: 32-bit, 100: 16-byte\t21.3.19/416\nNBYTES_MLNO\tMinor Byte Transfer Count\tNumber of bytes to be transferred in each service request of the channel. As a channel activates, the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes perform until the minor byte transfer count has transferred. This is an indivisible operation and cannot be halted. (Although, it may be stalled by using the bandwidth control field, or via preemption.) After the minor count is exhausted, the SADDR and DADDR values are written back into the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the major iteration count is completed, additional processing is performed. NOTE: An NBYTES value of 0x0000_0000 is interpreted as a 4 GB transfer.\t21.3.20/417\nNBYTES_MLOFFNO.SMLOE\tSource Minor Loop Offset Enable\tSelects whether the minor loop offset is applied to the source address upon minor loop completion. 0: The minor loop offset is not applied to the SADDR, 1: The minor loop offset is applied to the SADDR\t21.3.21/417\nNBYTES_MLOFFNO.DMLOE\tDestination Minor Loop Offset enable\tSelects whether the minor loop offset is applied to the destination address upon minor loop completion. 0: The minor loop offset is not applied to the DADDR, 1: The minor loop offset is applied to the DADDR\t21.3.21/417\nNBYTES_MLOFFNO.NBYTES\tMinor Byte Transfer Count\tNumber of bytes to be transferred in each service request of the channel. As a channel activates, the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes perform until the minor byte transfer count has transferred. This is an indivisible operation and cannot be halted; although, it may be stalled by using the bandwidth control field, or via preemption. After the minor count is exhausted, the SADDR and DADDR values are written back into the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the major iteration count is completed, additional processing is performed.\t21.3.21/417\nNBYTES_MLOFFYES.SMLOE\tSource Minor Loop Offset Enable\tSelects whether the minor loop offset is applied to the source address upon minor loop completion. 0: The minor loop offset is not applied to the SADDR, 1: The minor loop offset is applied to the SADDR\t21.3.22/418\nNBYTES_MLOFFYES.DMLOE\tDestination Minor Loop Offset enable\tSelects whether the minor loop offset is applied to the destination address upon minor loop completion. 0: The minor loop offset is not applied to the DADDR, 1: The minor loop offset is applied to the DADDR\t21.3.22/418\nNBYTES_MLOFFYES.MLOFF\tMinor Loop Offset\tIf SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.\t21.3.22/418\nNBYTES_MLOFFYES.NBYTES\tMinor Byte Transfer Count\tNumber of bytes to be transferred in each service request of the channel. As a channel activates, the appropriate TCD contents load into the eDMA engine, and the appropriate reads and writes perform until the minor byte transfer count has transferred. This is an indivisible operation and cannot be halted; although, it may be stalled by using the bandwidth control field, or via preemption. After the minor count is exhausted, the SADDR and DADDR values are written back into the TCD memory, the major iteration count is decremented and restored to the TCD memory. If the major iteration count is completed, additional processing is performed.\t21.3.22/418\nSLAST\tLast source Address Adjustment\tAdjustment value added to the source address at the completion of the major iteration count. This value can be applied to restore the source address to the initial value, or adjust the address to reference the next data structure.\t21.3.23/420\nDADDR\tDestination Address\tMemory address pointing to the destination data.\t21.3.24/420\nDOFF\tDestination Address Signed offset\tSign-extended offset applied to the current destination address to form the next-state value as each destination write is completed.\t21.3.25/421\nCITER_ELINKYES.ELINK\tEnable channel-to-channel linking on minor-loop complete\tAs the channel completes the minor loop, this flag enables linking to another channel, defined by the LINKCH field. The link target channel initiates a channel service request via an internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. NOTE: This bit must be equal to the BITER[ELINK] bit. Otherwise, a configuration error is reported. 0: The channel-to-channel linking is disabled, 1: The channel-to-channel linking is enabled\t21.3.26/421\nCITER_ELINKYES.LINKCH\tLink Channel Number\tIf channel-to-channel linking is enabled (ELINK = 1), then after the minor loop is exhausted, the eDMA engine initiates a channel service request to the channel defined by these four bits by setting that channelâ€™s TCDn_CSR[START] bit.\t21.3.26/421\nCITER_ELINKYES.ITER\tCurrent Major Iteration Count\tThis 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for the channel. It is decremented each time the minor loop is completed and updated in the transfer control descriptor memory. After the major iteration count is exhausted, the channel performs a number of operations (e.g., final source and destination address calculations), optionally generating an interrupt to signal channel completion before reloading the CITER field from the beginning iteration count (BITER) field. NOTE: When the CITER field is initially loaded by software, it must be set to the same value as that contained in the BITER field. NOTE: If the channel is configured to execute a single service request, the initial values of BITER and CITER should be 0x0001.\t21.3.26/421\nCITER_ELINKNO.ELINK\tEnable channel-to-channel linking on minor-loop complete\tAs the channel completes the minor loop, this flag enables linking to another channel, defined by the LINKCH field. The link target channel initiates a channel service request via an internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. If channel linking is disabled, the CITER value is extended to 15 bits in place of a link channel number. If the major loop is exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel linking. NOTE: This bit must be equal to the BITER[ELINK] bit. Otherwise, a configuration error is reported. 0: The channel-to-channel linking is disabled, 1: The channel-to-channel linking is enabled\t21.3.27/422\nCITER_ELINKNO.ITER\tCurrent Major Iteration Count\tThis 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current major loop count for the channel. It is decremented each time the minor loop is completed and updated in the transfer control descriptor memory. After the major iteration count is exhausted, the channel performs a number of operations (e.g., final source and destination address calculations), optionally generating an interrupt to signal channel completion before reloading the CITER field from the beginning iteration count (BITER) field. NOTE: When the CITER field is initially loaded by software, it must be set to the same value as that contained in the BITER field. NOTE: If the channel is configured to execute a single service request, the initial values of BITER and CITER should be 0x0001.E87\t21.3.27/422\nDLASTSGA\tDestination last address adjustment or the memory address for the next transfer control descriptor to be loaded into this channel (scatter/gather).\tIf (TCDn_CSR[ESG] = 0) then adjustment value added to the destination address at the completion of the major iteration count. This value can apply to restore the destination address to the initial value or adjust the address to reference the next data structure. Otherwise, this address points to the beginning of a 0-modulo-32-byte region containing the next transfer control descriptor to be loaded into this channel. This channel reload is performed as the major iteration count completes. The scatter/gather address must be 0-modulo-32-byte, else a configuration error is reported.eference the next data structure.\t21.3.28/423\nCSR.BWC\tBandwidth Control\tThrottles the amount of bus bandwidth consumed by the eDMA. In general, as the eDMA processes the minor loop, it continuously generates read/write sequences until the minor count is exhausted. This field forces the eDMA to stall after the completion of each read/write access to control the bus request bandwidth seen by the crossbar switch. NOTE: If the source and destination sizes are equal, this field is ignored between the first and second transfers and after the last write of each minor loop. This behavior is a side effect of reducing start-up latency. 00: No eDMA engine stalls, 01: Reserved, 10: eDMA engine stalls for 4 cycles after each r/w, 11: eDMA engine stalls for 8 cycles after each r/w\t21.3.29/424\nCSR.MAJORLINKCH\tLink Channel Number\tIf (MAJORELINK = 0) then no channel-to-channel linking (or chaining) is performed after the major loop counter is exhausted. Otherwise, after the major loop counter is exhausted, the eDMA engine initiates a channel service request at the channel defined by these six bits by setting that channelâ€™s TCDn_CSR[START] bit.\t21.3.29/424\nCSR.DONE\tChannel Done\tThis flag indicates the eDMA has completed the major loop. The eDMA engine sets it as the CITER count reaches zero; The software clears it, or the hardware when the channel is activated. NOTE: This bit must be cleared to write the MAJORELINK or ESG bits.\t21.3.29/424\nCSR.ACTIVE\tChannel Active\tThis flag signals the channel is currently in execution. It is set when channel service begins, and the eDMA clears it as the minor loop completes or if any error condition is detected. This bit resets to zero.\t21.3.29/424\nCSR.MAJORELINK\tEnable channel-to-channel linking on major loop complete\tAs the channel completes the major loop, this flag enables the linking to another channel, defined by MAJORLINKCH. The link target channel initiates a channel service request via an internal mechanism that sets the TCDn_CSR[START] bit of the specified channel. NOTE: To support the dynamic linking coherency model, this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set. 0: The channel-to-channel linking is disabled, 1: The channel-to-channel linking is enabled\t21.3.29/424\nCSR.ESG\tEnable Scatter/Gather Processing\tAs the channel completes the major loop, this flag enables scatter/gather processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a memory pointer to a 0-modulo-32 address containing a 32-byte data structure loaded as the transfer control descriptor into the local memory. NOTE: To support the dynamic scatter/gather coherency model, this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set. 0: The current channelâ€™s TCD is normal format., 1: The current channelâ€™s TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.\t21.3.29/424\nCSR.DREQ\tDisable Request\tIf this flag is set, the eDMA hardware automatically clears the corresponding ERQ bit when the current major iteration count reaches zero. 0: The channelâ€™s ERQ bit is not affected, 1: The channelâ€™s ERQ bit is cleared when the major loop is complete\t21.3.29/424\nCSR.INTHALF\tEnable an interrupt when major counter is half complete.\tIf this flag is set, the channel generates an interrupt request by setting the appropriate bit in the INT register when the current major iteration count reaches the halfway point. Specifically, the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This halfway point interrupt request is provided to support double-buffered (aka ping-pong) schemes or other types of data movement where the processor needs an early indication of the transferâ€™s progress. If BITER is set, do not use INTHALF. Use INTMAJOR instead. 0: The half-point interrupt is disabled, 1: The half-point interrupt is enabled\t21.3.29/424\nCSR.INTMAJOR\tEnable an interrupt when major iteration count completes\tIf this flag is set, the channel generates an interrupt request by setting the appropriate bit in the INT when the current major iteration count reaches zero. 0: The end-of-major loop interrupt is disabled, 1: The end-of-major loop interrupt is enabled,\t21.3.29/424\nCSR.START\tChannel Start\tIf this flag is set, the channel is requesting service. The eDMA hardware automatically clears this flag after the channel begins execution. 0: The channel is not explicitly started, 1: The channel is explicitly started via a software initiated service request,\t21.3.29/424\nBITER_ELINKYES.ELINK\tEnable channel-to-channel linking on minor-loop complete\tSee CITER_ELINKYES[ELINK].\t21.3.30/426\nBITER_ELINKYES.LINKCH\tLink Channel Number\tSee CITER_ELINKYES[LINKCH].\t21.3.30/426\nBITER_ELINKYES.ITER\tCurrent Major Iteration Count\tSee CITER_ELINKYES[CITER].\t21.3.30/426\nBITER_ELINKNO.ELINK\tEnable channel-to-channel linking on minor-loop complete\tSee CITER_ELINKNO[ELINK].\t21.3.31/427\nBITER_ELINKNO.ITER\tBeginning Major Iteration Count\tSee CITER_ELINKNO[CITER].\t21.3.31/427\n').strip()
TCD_DESCRIPTIONS = pd.read_csv(io.BytesIO(TCD_DESCRIPTIONS_TSV), sep='\t').set_index('full_name')
TCD_DESCRIPTIONS.loc[(TCD_DESCRIPTIONS.description.isnull(), 'description')] = ''
REGISTERS_DESCRIPTIONS_TSV = ('\nfull_name\tshort_description\tdescription\tpage\nCR.CX\tCancel Transfer\t0: Normal operation, 1: Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The\t21.3.1/391\nCR.ECX\tError Cancel Transfer\t0: Normal operation, 1: Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the ES register and generating an optional error interrupt.\t21.3.1/391\nCR.EMLM\tEnable Minor Loop Mapping\t0: Disabled. TCDn.word2 is defined as a 32-bit NBYTES field, 1: Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.\t21.3.1/391\nCR.CLM\tContinuous Link Mode\t0: A minor loop channel link made to itself goes through channel arbitration before being activated again, 1: A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.\t21.3.1/391\nCR.HALT\tHalt DMA Operations\t0: Normal operation, 1: Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.\t21.3.1/391\nCR.HOE\tHalt On Error\t0: Normal operation, 1: Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit\t21.3.1/391\nCR.ERCA\tEnable Round Robin Channel Arbitration\t0: Fixed priority arbitration is used for channel selection, 1: Round robin arbitration is used for channel selection .\t21.3.1/391\nCR.EDBG\tEnable Debug\t0: When in debug mode, the DMA continues to operate, 1: When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to complete. Channel execution resumes when the system exits debug mode or the EDBG bit is cleared.\t21.3.1/391\nES.VLD\tLogical OR of all ERR status bits\t0: No ERR bits are set, 1: At least one ERR bit is set indicating a valid error exists that has not been cleared\t21.3.2/392\nES.ECX\tTransfer Cancelled\t0: No cancelled transfers, 1: The last recorded entry was a cancelled transfer by the error cancel transfer input\t21.3.2/392\nES.CPE\tChannel Priority Error\t0: No channel priority error, 1: The last recorded error was a configuration error in the channel priorities . Channel priorities are not unique.\t21.3.2/392\nES.ERRCHN\tError Channel Number or Cancelled Channel Number\tThe channel number of the last recorded error (excluding CPE errors) or last recorded error cancelled transfer .\t21.3.2/392\nES.SAE\tSource Address Error\t0: No source address configuration error., 1: The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].\t21.3.2/392\nES.SOE\tSource Offset Error\t0: No source offset configuration error, 1: The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].\t21.3.2/392\nES.DAE\tDestination Address Error\t0: No destination address configuration error, 1: The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].\t21.3.2/392\nES.DOE\tDestination Offset Error\t0: No destination offset configuration error, 1: The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].\t21.3.2/392\nES.NCE\tNBYTES/CITER Configuration Error\t0: No NBYTES/CITER configuration error, 1: The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields.  One of: 1) TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or 2) TCDn_CITER[CITER] is equal to zero, or 3) TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]\t21.3.2/392\nES.SGE\tScatter/Gather Configuration Error\t0: No scatter/gather configuration error, 1: The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.\t21.3.2/392\nES.SBE\tSource Bus Error\t0: No source bus error, 1: The last recorded error was a bus error on a source read\t21.3.2/392\nES.DBE\tDestination Bus Error\t0: No destination bus error, 1: The last recorded error was a bus error on a destination write\t21.3.2/392\nERQ\tEnable Request Register\t\t21.3.3/394\nEEI\tEnable Error Interrupt Register\t\t21.3.4/397\nINT\tInterrupt Request Register\t\t21.3.13/406\nERR\tError Register\t\t21.3.14/409\nHRS\tHardware Request Status Register\t\t21.3.15/411\n').strip()
REGISTERS_DESCRIPTIONS = pd.read_csv(io.BytesIO(REGISTERS_DESCRIPTIONS_TSV), sep='\t').set_index('full_name')
REGISTERS_DESCRIPTIONS.loc[(REGISTERS_DESCRIPTIONS.description.isnull(), 'description')] = ''
DCHPRI_DESCRIPTIONS_TSV = ('\nfull_name\tshort_description\tdescription\tpage\nECP\tEnable Channel Preemption\t0: Channel n cannot be suspended by a higher priority channelâ€™s service request, 1: Channel n can be temporarily suspended by the service request of a higher priority channel\t21.3.16/414\nDPA\tDisable Preempt Ability\t0: Channel n can suspend a lower priority channel, 1: Channel n cannot suspend any channel, regardless of channel priority\t21.3.16/414\nCHPRI\tChannel n Arbitration Priority\tChannel priority when fixed-priority arbitration is enabled.  NOTE: Reset value for the channel priority fields, CHPRI, is equal to the corresponding channel number for each priority register, i.e., DCHPRI15[CHPRI] equals 0b1111.\t21.3.16/414\n').strip()
DCHPRI_DESCRIPTIONS = pd.read_csv(io.BytesIO(DCHPRI_DESCRIPTIONS_TSV), sep='\t').set_index('full_name')
DCHPRI_DESCRIPTIONS.loc[(DCHPRI_DESCRIPTIONS.description.isnull(), 'description')] = ''
MUX_CHCFG_DESCRIPTIONS_TSV = ("\nfull_name\tshort_description\tdescription\tpage\nENBL\tDMA Channel Enable\tEnables the DMA channel. 0: DMA channel is disabled. This mode is primarily used during configuration of the DMA Mux. The DMA has separate channel enables/disables, which should be used to disable or re-configure a DMA channel. 1: DMA channel is enabled\t20.3.1/366\nTRIG\tDMA Channel Trigger Enable\tEnables the periodic trigger capability for the triggered DMA channel. 0: Triggering is disabled. If triggering is disabled, and the ENBL bit is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode) 1: Triggering is enabled. If triggering is enabled, and the ENBL bit is set, the DMAMUX is in Periodic Trigger mode.\t20.3.1/366\nSOURCE\tDMA Channel Source (Slot)\tSpecifies which DMA source, if any, is routed to a particular DMA channel. See your device's chip configuration details for further details about the peripherals and their slot numbers.\t20.3.1/366\n").strip()
MUX_CHCFG_DESCRIPTIONS = pd.read_csv(io.BytesIO(MUX_CHCFG_DESCRIPTIONS_TSV), sep='\t').set_index('full_name')
MUX_CHCFG_DESCRIPTIONS.loc[(MUX_CHCFG_DESCRIPTIONS.description.isnull(), 'description')] = ''
DMAMUX_SOURCE_ADC0 = 40
DMAMUX_SOURCE_ADC1 = 41
DMAMUX_SOURCE_PDB = 48
HW_TCDS_ADDR = 1073778688
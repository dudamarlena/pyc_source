# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-x86_64/egg/insights/parsr/examples/tests/test_corosync.py
# Compiled at: 2019-11-14 13:57:46
from insights.parsr.examples.corosync_conf import loads
DATA = ('\n# Please read the corosync.conf.5 manual page\ntotem {\n    version: 2\n\n    # crypto_cipher and crypto_hash: Used for mutual node authentication.\n    # If you choose to enable this, then do remember to create a shared\n    # secret with "corosync-keygen".\n    # enabling crypto_cipher, requires also enabling of crypto_hash.\n    crypto_cipher: none\n    crypto_hash: none\n\n    # interface: define at least one interface to communicate\n    # over. If you define more than one interface stanza, you must\n    # also set rrp_mode.\n    interface {\n                # Rings must be consecutively numbered, starting at 0.\n        ringnumber: 0\n        # This is normally the *network* address of the\n        # interface to bind to. This ensures that you can use\n        # identical instances of this configuration file\n        # across all your cluster nodes, without having to\n        # modify this option.\n        bindnetaddr: 192.168.1.0\n        # However, if you have multiple physical network\n        # interfaces configured for the same subnet, then the\n        # network address alone is not sufficient to identify\n        # the interface Corosync should bind to. In that case,\n        # configure the *host* address of the interface\n        # instead:\n        # bindnetaddr: 192.168.1.1\n        # When selecting a multicast address, consider RFC\n        # 2365 (which, among other things, specifies that\n        # 239.255.x.x addresses are left to the discretion of\n        # the network administrator). Do not reuse multicast\n        # addresses across multiple Corosync clusters sharing\n        # the same network.\n        mcastaddr: 239.255.1.1\n        # Corosync uses the port you specify here for UDP\n        # messaging, and also the immediately preceding\n        # port. Thus if you set this to 5405, Corosync sends\n        # messages over UDP ports 5405 and 5404.\n        mcastport: 5405\n        # Time-to-live for cluster communication packets. The\n        # number of hops (routers) that this ring will allow\n        # itself to pass. Note that multicast routing must be\n        # specifically enabled on most network routers.\n        ttl: 1\n    }\n}\n\nlogging {\n    # Log the source file and line where messages are being\n    # generated. When in doubt, leave off. Potentially useful for\n    # debugging.\n    fileline: off\n    # Log to standard error. When in doubt, set to no. Useful when\n    # running in the foreground (when invoking "corosync -f")\n    to_stderr: no\n    # Log to a log file. When set to "no", the "logfile" option\n    # must not be set.\n    to_logfile: yes\n    logfile: /var/log/cluster/corosync.log\n    # Log to the system log daemon. When in doubt, set to yes.\n    to_syslog: yes\n    # Log debug messages (very verbose). When in doubt, leave off.\n    debug: off\n    # Log messages with time stamps. When in doubt, set to on\n    # (unless you are only logging to syslog, where double\n    # timestamps can be annoying).\n    timestamp: on\n    logger_subsys {\n        subsys: QUORUM\n        debug: off\n    }\n}\n\nquorum {\n    # Enable and configure quorum subsystem (default: off)\n    # see also corosync.conf.5 and votequorum.5\n    #provider: corosync_votequorum\n}\n').strip()
COROSYNC_CONF = ('\ntotem {\n    version: 2\n    secauth: off\n    cluster_name: tripleo_cluster\n    transport: udpu\n    token: 10000\n}\n\nnodelist {\n    node {\n        ring0_addr: overcloud-controller-0\n        nodeid: 1\n    }\n\n    node {\n        ring0_addr: overcloud-controller-1\n        nodeid: 2\n    }\n\n    node {\n        ring0_addr: overcloud-controller-2\n        nodeid: 3\n    }\n}\n\nquorum {\n    provider: corosync_votequorum\n}\n\nlogging {\n    to_logfile: yes\n    logfile: /var/log/cluster/corosync.log\n    to_syslog: yes\n}\n').strip()

def test_corosync_data():
    res = loads(DATA)
    assert res['totem']['version'].value == 2
    assert res['totem']['interface']['bindnetaddr'].value == '192.168.1.0'
    assert len(res['quorum']) == 1


def test_corosync_conf():
    conf = loads(COROSYNC_CONF)
    assert conf['totem']['token'][0].value == 10000
    assert conf['quorum']['provider'][0].value == 'corosync_votequorum'
    assert conf['nodelist']['node']['nodeid'][(-1)].value == 3
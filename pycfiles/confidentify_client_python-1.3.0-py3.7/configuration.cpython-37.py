# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build\bdist.win-amd64\egg\confidentify_client\configuration.py
# Compiled at: 2020-04-21 15:15:02
# Size of source mod 2**32: 14521 bytes
"""
    Confidentify API

    Services that let you build confidence and identify matches in customer data. ## Features overview * Contact data processing services (tagged with `process`) which offer   validation and enrichment backed by inference and knowledge on complex   data types such as names, email addresses, phone numbers.  * Data matching and searching services (tagged with `matching`) that    allow you to identify duplicated data or matches against third party   contact data list.  * Dataset management services (tagged with `dataset`) that allow record storage and retrieval. ## Integrator notes: * Use the `/auth` endpoint to get an access token. Access tokens are temporary, so design the client the be capable of renewing it. * The APIs are rate-limited, so design the client to be capable of retrying with some delay upon HTTP 429 responses.   # noqa: E501

    The version of the OpenAPI document: 1.1.0
    Generated by: https://openapi-generator.tech
"""
from __future__ import absolute_import
import logging, multiprocessing, sys, urllib3, six
import six.moves as httplib

class Configuration(object):
    __doc__ = "NOTE: This class is auto generated by OpenAPI Generator\n\n    Ref: https://openapi-generator.tech\n    Do not edit the class manually.\n\n    :param host: Base url\n    :param api_key: Dict to store API key(s).\n      Each entry in the dict specifies an API key.\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is the API key secret.\n    :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is an API key prefix when generating the auth data.\n    :param username: Username for HTTP basic authentication\n    :param password: Password for HTTP basic authentication\n    :param signing_info: Configuration parameters for HTTP signature.\n        Must be an instance of confidentify_client.signing.HttpSigningConfiguration\n\n    :Example:\n\n    Given the following security scheme in the OpenAPI specification:\n      components:\n        securitySchemes:\n          cookieAuth:         # name for the security scheme\n            type: apiKey\n            in: cookie\n            name: JSESSIONID  # cookie name\n\n    You can programmatically set the cookie:\n      conf = confidentify_client.Configuration(\n        api_key={'cookieAuth': 'abc123'}\n        api_key_prefix={'cookieAuth': 'JSESSIONID'}\n      )\n    The following cookie will be added to the HTTP request:\n       Cookie: JSESSIONID abc123\n\n    Configure API client with HTTP basic authentication:\n      conf = confidentify_client.Configuration(\n          username='the-user',\n          password='the-password',\n      )\n\n    Configure API client with HTTP signature authentication. Use the 'hs2019' signature scheme,\n    sign the HTTP requests with the RSA-SSA-PSS signature algorithm, and set the expiration time\n    of the signature to 5 minutes after the signature has been created.\n    Note you can use the constants defined in the confidentify_client.signing module, and you can\n    also specify arbitrary HTTP headers to be included in the HTTP signature, except for the\n    'Authorization' header, which is used to carry the signature.\n\n    One may be tempted to sign all headers by default, but in practice it rarely works.\n    This is beccause explicit proxies, transparent proxies, TLS termination endpoints or\n    load balancers may add/modify/remove headers. Include the HTTP headers that you know\n    are not going to be modified in transit.\n\n      conf = confidentify_client.Configuration(\n        signing_info = confidentify_client.signing.HttpSigningConfiguration(\n            key_id =                 'my-key-id',\n            private_key_path =       'rsa.pem',\n            signing_scheme =         signing.SCHEME_HS2019,\n            signing_algorithm =      signing.ALGORITHM_RSASSA_PSS,\n            signed_headers =         [signing.HEADER_REQUEST_TARGET,\n                                      signing.HEADER_CREATED,\n                                      signing.HEADER_EXPIRES,\n                                      signing.HEADER_HOST,\n                                      signing.HEADER_DATE,\n                                      signing.HEADER_DIGEST,\n                                      'Content-Type',\n                                      'Content-Length',\n                                      'User-Agent'\n                                     ],\n            signature_max_validity = datetime.timedelta(minutes=5)\n        )\n      )\n    "

    def __init__(self, host='https://api.confidentify.com', api_key=None, api_key_prefix=None, username=None, password=None, signing_info=None):
        """Constructor
        """
        self.host = host
        self.temp_folder_path = None
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        self.refresh_api_key_hook = None
        self.username = username
        self.password = password
        if signing_info is not None:
            signing_info.host = host
        self.signing_info = signing_info
        self.access_token = ''
        self.logger = {}
        self.logger['package_logger'] = logging.getLogger('confidentify_client')
        self.logger['urllib3_logger'] = logging.getLogger('urllib3')
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        self.logger_stream_handler = None
        self.logger_file_handler = None
        self.logger_file = None
        self.debug = False
        self.verify_ssl = True
        self.ssl_ca_cert = None
        self.cert_file = None
        self.key_file = None
        self.assert_hostname = None
        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
        self.proxy = None
        self.proxy_headers = None
        self.safe_chars_for_path_param = ''
        self.retries = None
        self.client_side_validation = True

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self._Configuration__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self._Configuration__logger_file = value
        if self._Configuration__logger_file:
            self.logger_file_handler = logging.FileHandler(self._Configuration__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in six.iteritems(self.logger):
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self._Configuration__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self._Configuration__debug = value
        if self._Configuration__debug:
            for _, logger in six.iteritems(self.logger):
                logger.setLevel(logging.DEBUG)

            httplib.HTTPConnection.debuglevel = 1
        else:
            for _, logger in six.iteritems(self.logger):
                logger.setLevel(logging.WARNING)

            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self._Configuration__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self._Configuration__logger_format = value
        self.logger_formatter = logging.Formatter(self._Configuration__logger_format)

    def get_api_key_with_prefix(self, identifier):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return '%s %s' % (prefix, key)
            return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ''
        if self.username is not None:
            username = self.username
        password = ''
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(basic_auth=(username + ':' + password)).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        if self.access_token is not None:
            auth['bearerAuth'] = {'type':'bearer',  'in':'header', 
             'format':'JWT', 
             'key':'Authorization', 
             'value':'Bearer ' + self.access_token}
        if self.access_token is not None:
            auth['oAuth2ClientCredentials'] = {'type':'oauth2',  'in':'header', 
             'key':'Authorization', 
             'value':'Bearer ' + self.access_token}
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return 'Python SDK Debug Report:\nOS: {env}\nPython Version: {pyversion}\nVersion of the API: 1.1.0\nSDK Package Version: 1.0.0'.format(env=(sys.platform),
          pyversion=(sys.version))

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
         {'url':'https://api.confidentify.com', 
          'description':'No description provided'}]

    def get_host_from_settings(self, index, variables=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :return: URL based on host settings
        """
        variables = {} if variables is None else variables
        servers = self.get_host_settings()
        try:
            server = servers[index]
        except IndexError:
            raise ValueError('Invalid index {0} when selecting the host settings. Must be less than {1}'.format(index, len(servers)))

        url = server['url']
        for variable_name, variable in server['variables'].items():
            used_value = variables.get(variable_name, variable['default_value'])
            if 'enum_values' in variable:
                if used_value not in variable['enum_values']:
                    raise ValueError('The variable `{0}` in the host URL has invalid value {1}. Must be {2}.'.format(variable_name, variables[variable_name], variable['enum_values']))
            url = url.replace('{' + variable_name + '}', used_value)

        return url
# uncompyle6 version 3.6.7
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: /usr/lib/python3.7/site-packages/aprt/srcinfo.py
# Compiled at: 2019-08-02 08:01:39
# Size of source mod 2**32: 4593 bytes
import os, os.path
from .package import Package

class SrcInfo:
    """SrcInfo"""

    def __init__(self, directory):
        self.pkgbase = None
        self.pkgnames = []
        self.directory = directory

    def packages(self):
        """
                Get a list of packages described by this SRCINFO.
                The returned  packages are generated by merging pkgbase data with each pkgname.
                """
        for pkgname in self.pkgnames:
            package = Package(pkgname.name)
            for key, values in self.pkgbase.data.items():
                package.add_values(key, values)

            for key, values in pkgname.data.items():
                package.add_values(key, values)

            yield package
            if package.hasOption('debug') and package.hasOption('strip'):
                yield package.split_debug_package()

    @classmethod
    def parse(cls, blob, directory):
        """
                Parse a blob of text as SRCINFO file.
                The results are returned as a SrcInfo object,
                """
        result = cls(directory)
        current = None
        for line in blob.splitlines():
            if not len(line) == 0:
                if line[0] == '#':
                    continue
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                if key == 'pkgbase':
                    current = Package(value)
                    result.pkgbase = current
                elif key == 'pkgname':
                    current = Package(value)
                    result.pkgnames.append(current)
                elif current == None:
                    raise ValueError('SRCINFO value encountered but no pkgbase or pkgname has been started.')
                else:
                    current.add_value(key, value)

        return result

    @classmethod
    def parse_file(cls, filename):
        with open(filename, 'r') as (file):
            return cls.parse(file.read(), os.path.dirname(filename))

    @classmethod
    def parse_packages(cls, blob, directory):
        return cls.parse(blob, directory).packages()

    @classmethod
    def parse_packages_file(cls, filename):
        return cls.parse_file(filename).packages()

    @classmethod
    def __find_srcinfo_dirs(cls, root):
        children = os.listdir(root)
        for child in children:
            path = os.path.join(root, child)
            if child == '.SRCINFO':
                yield root
            if os.path.isdir(path):
                yield from cls._SrcInfo__find_srcinfo_dirs(path)

    @classmethod
    def load_db(cls, root):
        directories = cls._SrcInfo__find_srcinfo_dirs(root)
        result = {}
        for directory in directories:
            srcinfo = cls.parse_file(os.path.join(directory, '.SRCINFO'))
            srcinfo.directory = directory
            result[directory] = srcinfo

        return result

    @classmethod
    def index_by_pkgname(cls, srcinfo_db):
        result = {}
        for srcinfo in srcinfo_db.values():
            for package in srcinfo.packages():
                if package.name in result:
                    raise RuntimeError('Multiple .SRCINFO files build the same package: {} is built by {} and {}.'.format(package, srcinfo.directory, result[package.name].directory))
                result[package.name] = srcinfo

        return result

    @classmethod
    def load_db_indexed_by_pkgname(cls, root):
        return cls.index_by_pkgname(cls.load_db(root))
# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /home/hanzz/releases/odcs/server/odcs/server/cache.py
# Compiled at: 2019-05-16 01:06:20
# Size of source mod 2**32: 7305 bytes
import time, os, shutil
from datetime import timedelta
from flufl.lock import Lock
from odcs.common.types import PungiSourceType, COMPOSE_STATES
from odcs.server import conf, log
from odcs.server.utils import makedirs

class KojiTagCache(object):
    __doc__ = '\n    Class caching old composes of KOJI_TAG source_type generated by Pungi.\n\n    The goal of this caching is to let Pungi reuse old repodata when running\n    createrepo_c and make composes faster.\n    Cached composes are stored in the "conf.targetdir/koji_tag_cache" in\n    directories named according to Koji tag from which the compose is\n    generated, compose flags, sigkeys and arches. These are basically all the\n    ODCS compose attributes which influences the repodata.\n    '

    def __init__(self):
        self.cache_dir = os.path.join(conf.target_dir, 'koji_tag_cache')
        makedirs(self.cache_dir)

    def remove_old_koji_tag_cache_data(self):
        """
        Removes the old unused Koji tag cache directories which has not been
        used for more than `conf.koji_tag_cache_cleanup_timeout` days.
        """
        older_than_seconds = conf.koji_tag_cache_cleanup_timeout * 24 * 3600
        threshold = time.time() - older_than_seconds
        for cached_dir in os.listdir(self.cache_dir):
            path = os.path.join(self.cache_dir, cached_dir)
            try:
                mtime = os.path.getmtime(path)
            except OSError:
                log.exception('Old koji tag cache directory %s removed while checking Koji cache.' % path)
                continue

            if mtime > threshold:
                continue
            log.info('Removing old Koji tag cache data in %s.' % path)
            shutil.rmtree(path)

    def cached_compose_dir(self, compose):
        """
        Returns the full path to caching directory belonging to `compose`.
        The returned full path is based on Koji tag, flags, sigkeys and arches
        attributes of `compose`.

        :param models.Compose compose: Compose to generate the cache path from.
        :rtype: str
        :return: Full path to caching directory belonging to compose.
        """
        koji_tag = compose.source
        flags = str(compose.flags)
        if compose.sigkeys:
            sigkeys = '-'.join(sorted(compose.sigkeys.split(' ')))
        else:
            sigkeys = ''
        if compose.arches:
            arches = '-'.join(sorted(compose.arches.split(' ')))
        else:
            arches = ''
        dir_name = '-'.join([koji_tag, flags, sigkeys, arches])
        return os.path.join(self.cache_dir, dir_name)

    def is_cached(self, compose):
        """
        Returns True if there is old compose generated from the same Koji tag
        which can be reused when generating this `compose`.

        :param models.Compose compose: Compose to check.
        :rtype: bool
        :return: Returns True when there exists cached compose for input
            compose.
        """
        if compose.source_type != PungiSourceType.KOJI_TAG:
            return False
        return os.path.exists(self.cached_compose_dir(compose))

    def reuse_cached(self, compose):
        """
        Configures the Cache directory so the Pungi will find the old compose
        defined by KojiTagCache.cached_compose_dir when building the `compose`.

        :param models.Compose compose: Compose which will reuse the older
            cached compose.
        """
        cached_compose_dir = self.cached_compose_dir(compose)
        log.info('Reusing repodata from old cached compose %s', cached_compose_dir)
        lock = Lock(cached_compose_dir + '.lock')
        lock.lifetime = timedelta(minutes=3)
        try:
            lock.lock()
            compose_dir_name = 'odcs-%d-1-19700101.n.0' % compose.id
            compose_dir = os.path.join(self.cache_dir, compose_dir_name)
            if os.path.exists(compose_dir):
                shutil.rmtree(compose_dir)
            shutil.copytree(cached_compose_dir, compose_dir, symlinks=True)
        finally:
            if lock.is_locked:
                lock.unlock()

    def cleanup_reused(self, compose):
        """
        Cleans-up the configuration done by `reuse_cached`. Should be called
        once the image depending on cached image is built.
        """
        compose_dir_name = 'odcs-%d-1-19700101.n.0' % compose.id
        compose_dir = os.path.join(self.cache_dir, compose_dir_name)
        if os.path.exists(compose_dir):
            log.info('Removing cached reused compose %s' % compose_dir)
            shutil.rmtree(compose_dir)

    def update_cache(self, compose):
        """
        Updates the cache with newly built version of `compose`.

        :param models.Compose compose: Compose to update the cache from.
        """
        if compose.source_type != PungiSourceType.KOJI_TAG or compose.state != COMPOSE_STATES['done']:
            log.info('Not caching the compose %s.', compose)
            return
        log.info('Caching the compose %s', compose)
        cached_compose_dir = self.cached_compose_dir(compose)
        compose_dir = os.path.realpath(compose.toplevel_dir)
        lock = Lock(cached_compose_dir + '.lock')
        lock.lifetime = timedelta(minutes=3)
        try:
            lock.lock()
            if os.path.exists(cached_compose_dir):
                shutil.rmtree(cached_compose_dir)
            shutil.copytree(compose_dir, cached_compose_dir, symlinks=True)
        finally:
            if lock.is_locked:
                lock.unlock()
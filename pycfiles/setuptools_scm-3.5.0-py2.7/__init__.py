# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-x86_64/egg/setuptools_scm/__init__.py
# Compiled at: 2020-02-13 15:05:29
"""
:copyright: 2010-2015 by Ronny Pfannschmidt
:license: MIT
"""
import os, warnings
from .config import Configuration, DEFAULT_VERSION_SCHEME, DEFAULT_LOCAL_SCHEME, DEFAULT_TAG_REGEX
from .utils import function_has_arg, string_types
from .version import format_version, meta
from .discover import iter_matching_entrypoints
PRETEND_KEY = 'SETUPTOOLS_SCM_PRETEND_VERSION'
TEMPLATES = {'.py': "# coding: utf-8\n# file generated by setuptools_scm\n# don't change, don't track in version control\nversion = {version!r}\n", 
   '.txt': '{version}'}

def version_from_scm(root):
    warnings.warn('version_from_scm is deprecated please use get_version', category=DeprecationWarning)
    config = Configuration()
    config.root = root
    return _version_from_entrypoints(config)


def _call_entrypoint_fn(root, config, fn):
    if function_has_arg(fn, 'config'):
        return fn(root, config=config)
    else:
        warnings.warn("parse functions are required to provide a named argument 'config' in the future.", category=PendingDeprecationWarning, stacklevel=2)
        return fn(root)


def _version_from_entrypoints(config, fallback=False):
    if fallback:
        entrypoint = 'setuptools_scm.parse_scm_fallback'
        root = config.fallback_root
    else:
        entrypoint = 'setuptools_scm.parse_scm'
        root = config.absolute_root
    for ep in iter_matching_entrypoints(root, entrypoint):
        version = _call_entrypoint_fn(root, config, ep.load())
        if version:
            return version


def dump_version(root, version, write_to, template=None):
    if not isinstance(version, string_types):
        raise AssertionError
        return write_to or None
    else:
        target = os.path.normpath(os.path.join(root, write_to))
        ext = os.path.splitext(target)[1]
        template = template or TEMPLATES.get(ext)
        if template is None:
            raise ValueError(("bad file format: '{}' (of {}) \nonly *.txt and *.py are supported").format(os.path.splitext(target)[1], target))
        with open(target, 'w') as (fp):
            fp.write(template.format(version=version))
        return


def _do_parse(config):
    pretended = os.environ.get(PRETEND_KEY)
    if pretended:
        return meta(tag=pretended, preformatted=True, config=config)
    if config.parse:
        parse_result = _call_entrypoint_fn(config.absolute_root, config, config.parse)
        if isinstance(parse_result, string_types):
            raise TypeError('version parse result was a string\nplease return a parsed version')
        version = parse_result or _version_from_entrypoints(config, fallback=True)
    else:
        version = _version_from_entrypoints(config) or _version_from_entrypoints(config, fallback=True)
    if version:
        return version
    raise LookupError("setuptools-scm was unable to detect version for %r.\n\nMake sure you're either building from a fully intact git repository or PyPI tarballs. Most other sources (such as GitHub's tarballs, a git checkout without the .git folder) don't contain the necessary metadata and will not work.\n\nFor example, if you're using pip, instead of https://github.com/user/proj/archive/master.zip use git+https://github.com/user/proj.git#egg=proj" % config.absolute_root)


def get_version(root='.', version_scheme=DEFAULT_VERSION_SCHEME, local_scheme=DEFAULT_LOCAL_SCHEME, write_to=None, write_to_template=None, relative_to=None, tag_regex=DEFAULT_TAG_REGEX, fallback_version=None, fallback_root='.', parse=None, git_describe_command=None):
    """
    If supplied, relative_to should be a file from which root may
    be resolved. Typically called by a script or module that is not
    in the root of the repository to direct setuptools_scm to the
    root of the repository by supplying ``__file__``.
    """
    config = Configuration(**locals())
    return _get_version(config)


def _get_version(config):
    parsed_version = _do_parse(config)
    if parsed_version:
        version_string = format_version(parsed_version, version_scheme=config.version_scheme, local_scheme=config.local_scheme)
        dump_version(root=config.root, version=version_string, write_to=config.write_to, template=config.write_to_template)
        return version_string
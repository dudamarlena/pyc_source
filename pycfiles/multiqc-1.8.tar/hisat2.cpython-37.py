# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /Users/philewels/GitHub/MultiQC/multiqc/modules/hisat2/hisat2.py
# Compiled at: 2019-11-13 05:22:42
# Size of source mod 2**32: 6973 bytes
""" MultiQC module to parse output from HISAT2 """
from __future__ import print_function
from collections import OrderedDict
import logging, re
from multiqc.plots import bargraph
from multiqc.modules.base_module import BaseMultiqcModule
log = logging.getLogger(__name__)

class MultiqcModule(BaseMultiqcModule):
    __doc__ = ' HISAT2 module, parses stderr logs. '

    def __init__(self):
        super(MultiqcModule, self).__init__(name='HISAT2', anchor='hisat2', href='https://ccb.jhu.edu/software/hisat2/',
          info='is a fast and sensitive alignment program for mapping NGS reads (both DNA and RNA) against a reference genome or population of reference genomes.')
        self.hisat2_data = dict()
        for f in self.find_log_files('hisat2', filehandles=True):
            self.parse_hisat2_logs(f)

        self.hisat2_data = self.ignore_samples(self.hisat2_data)
        if len(self.hisat2_data) == 0:
            raise UserWarning
        log.info('Found {} reports'.format(len(self.hisat2_data)))
        self.write_data_file(self.hisat2_data, 'multiqc_hisat2')
        self.hisat2_general_stats_table()
        self.hisat2_alignment_plot()

    def parse_hisat2_logs(self, f):
        """
        Parse statistics generated by HISAT2 >= v2.1.0 that has been run
        with the --new-summary option. Older versions or logs from runs without
        that option are identical to that from bowtie2 and will be parsed
        by that module.
        """
        regexes = {'unpaired_total':'Total(?: unpaired)? reads: (\\d+)', 
         'unpaired_aligned_none':'Aligned 0 times?: (\\d+) \\([\\d\\.]+%\\)', 
         'unpaired_aligned_one':'Aligned 1 time: (\\d+) \\([\\d\\.]+%\\)', 
         'unpaired_aligned_multi':'Aligned >1 times: (\\d+) \\([\\d\\.]+%\\)', 
         'paired_total':'Total pairs: (\\d+)', 
         'paired_aligned_none':'Aligned concordantly or discordantly 0 time: (\\d+) \\([\\d\\.]+%\\)', 
         'paired_aligned_one':'Aligned concordantly 1 time: (\\d+) \\([\\d\\.]+%\\)', 
         'paired_aligned_multi':'Aligned concordantly >1 times: (\\d+) \\([\\d\\.]+%\\)', 
         'paired_aligned_discord_one':'Aligned discordantly 1 time: (\\d+) \\([\\d\\.]+%\\)'}
        s_name = f['s_name']
        parsed_data = {}
        for l in f['f']:
            hscmd = re.search('hisat2 .+ -[1U] ([^\\s,]+)', l)
            if hscmd:
                s_name = self.clean_s_name(hscmd.group(1), f['root'])
                log.debug("Found a HISAT2 command, updating sample name to '{}'".format(s_name))
            for k, r in regexes.items():
                match = re.search(r, l)
                if match:
                    parsed_data[k] = int(match.group(1))

            overall = re.search('Overall alignment rate: ([\\d\\.]+)%', l)
            if overall:
                parsed_data['overall_alignment_rate'] = float(overall.group(1))
                if s_name in self.hisat2_data:
                    log.debug('Duplicate sample name found! Overwriting: {}'.format(s_name))
                self.add_data_source(f, s_name)
                self.hisat2_data[s_name] = parsed_data
                s_name = f['s_name']
                parsed_data = {}

    def hisat2_general_stats_table(self):
        """ Take the parsed stats from the HISAT2 report and add it to the
        basic stats table at the top of the report """
        headers = OrderedDict()
        headers['overall_alignment_rate'] = {'title':'% Aligned', 
         'description':'overall alignment rate', 
         'max':100, 
         'min':0, 
         'suffix':'%', 
         'scale':'YlGn'}
        self.general_stats_addcols(self.hisat2_data, headers)

    def hisat2_alignment_plot(self):
        """ Make the HighCharts HTML to plot the alignment rates """
        sedata = {}
        pedata = {}
        for s_name, data in self.hisat2_data.items():
            if 'paired_total' in data:
                m_keys = ['unpaired_total', 'unpaired_aligned_none', 'unpaired_aligned_one', 'unpaired_aligned_multi']
                for k in m_keys:
                    if k in data:
                        data[k] = float(data[k]) / 2.0

                pedata[s_name] = data
            else:
                sedata[s_name] = data

        if len(sedata) > 0:
            sekeys = OrderedDict()
            sekeys['unpaired_aligned_one'] = {'color':'#20568f',  'name':'SE mapped uniquely'}
            sekeys['unpaired_aligned_multi'] = {'color':'#f7a35c',  'name':'SE multimapped'}
            sekeys['unpaired_aligned_none'] = {'color':'#981919',  'name':'SE not aligned'}
            pconfig = {'id':'hisat2_se_plot', 
             'title':'HISAT2: SE Alignment Scores', 
             'ylab':'# Reads', 
             'cpswitch_counts_label':'Number of Reads'}
            self.add_section(plot=(bargraph.plot(sedata, sekeys, pconfig)))
        if len(pedata) > 0:
            pekeys = OrderedDict()
            pekeys['paired_aligned_one'] = {'color':'#20568f',  'name':'PE mapped uniquely'}
            pekeys['paired_aligned_discord_one'] = {'color':'#5c94ca',  'name':'PE mapped discordantly uniquely'}
            pekeys['unpaired_aligned_one'] = {'color':'#95ceff',  'name':'PE one mate mapped uniquely'}
            pekeys['paired_aligned_multi'] = {'color':'#f7a35c',  'name':'PE multimapped'}
            pekeys['unpaired_aligned_multi'] = {'color':'#ffeb75',  'name':'PE one mate multimapped'}
            pekeys['unpaired_aligned_none'] = {'color':'#981919',  'name':'PE neither mate aligned'}
            pconfig = {'id':'hisat2_pe_plot', 
             'title':'HISAT2: PE Alignment Scores', 
             'ylab':'# Reads', 
             'cpswitch_counts_label':'Number of Reads'}
            self.add_section(description='<em>Please note that single mate alignment counts are halved to tally with pair counts properly.</em>',
              plot=(bargraph.plot(pedata, pekeys, pconfig)))
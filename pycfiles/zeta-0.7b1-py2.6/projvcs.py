# uncompyle6 version 3.7.4
# Python bytecode 2.6 (62161)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-i686/egg/zeta/controllers/projvcs.py
# Compiled at: 2010-07-08 08:56:12
"""Controller module to manage project source control pages."""
import logging, datetime as dt, re, os
from os.path import basename, join, splitext
from pylons import request, response, session, tmpl_context as c
from pylons.controllers.util import abort
from pylons import config
import simplejson as json
from authkit.authorize import PermissionError, PermissionSetupError, NotAuthenticatedError, NotAuthorizedError, middleware
from zeta.lib.base import BaseController, render
from zeta.config.environment import beforecontrollers, aftercontrollers
from zeta.lib.view import viewcontext, viewuserpanes, viewprojectpanel, Anchor
import zeta.lib.helpers as h, zeta.lib.vcsadaptor as va
from zeta.lib.constants import *
from zeta.lib.error import ZetaFormError
from zeta.comp.project import ProjectComponent
from zeta.comp.license import LicenseComponent
from zeta.comp.vcs import VcsComponent
from zeta.comp.forms import VForm
from zeta.comp.timeline import TimelineComponent
log = logging.getLogger(__name__)
compmgr = None
vf = None
projcomp = None
vcscomp = None
tlcomp = None

def do_onetime():
    global compmgr
    global projcomp
    global tlcomp
    global vcscomp
    global vf
    if compmgr == None:
        compmgr = config['compmgr']
        projcomp = ProjectComponent(compmgr)
        vcscomp = VcsComponent(compmgr)
        tlcomp = TimelineComponent(compmgr)
        vf = VForm(compmgr)
    return


vcsperm = {}
vcsperm.update(dict([ (formname, h.HasPermname('VCS_CREATE')) for formname in [
 'createvcs', 'configvcs', 'deletevcs']
                    ]))

def _urlreviewfile(projectname, url, version):
    """urls to be stuffed into the pages generated by this controller"""
    h.url_reviewvfile = h.url_for(h.r_projrevwcreate, projectname=projectname, form='request', formname='createrev', rurl=url, ver=version)


def _urlreviewrev(projectname, vcsid, version):
    """urls to be stuffed into the pages generated by this controller"""
    h.url_reviewrev = h.url_for(h.r_projrevwcreate, projectname=projectname, form='request', formname='createrev', vcsid=vcsid, ver=version)


def _url(projectname='', id=''):
    """urls to be stuffed into the pages generated by this controller."""
    h.url_prj = h.url_for(h.r_projecthome, projectname=projectname)
    h.url_vcscreate = h.url_for(h.r_projvcscreate, projectname=projectname, form='request', formname='createvcs')
    if c.vrep:
        revno = c.vrep.linfo['l_revision']
        revno = revno - revno % 100 + 1
        h.url_revlist = h.url_for(h.r_projvcsrevlist, projectname=projectname, id=id, revno=revno) or ''
    h.url_vcsbrowse = c.vcs and h.url_for(h.r_projvcsbrowse, projectname=projectname, id=c.vcs.id) or ''
    if c.revno_p:
        h.url_browseprev = h.url_for(h.r_projvcsbrowse, projectname=projectname, id=c.vcs.id, revno=c.revno_p)
        h.url_revprev = h.url_for(h.r_projvcsrev, projectname=projectname, id=c.vcs.id, revno=c.revno_p)
    else:
        (h.url_browseprev, h.url_revprev) = ('', '')
    if c.revno_n:
        h.url_browsenext = h.url_for(h.r_projvcsbrowse, projectname=projectname, id=c.vcs.id, revno=c.revno_n)
        h.url_revnext = h.url_for(h.r_projvcsrev, projectname=projectname, id=c.vcs.id, revno=c.revno_n)
    else:
        (h.url_browsenext, h.url_revnext) = ('', '')
    if id:
        h.url_vcstimeline = h.url_for(h.r_projvcstline, projectname=projectname, id=id)
        h.url_rssfeed = h.url_for(h.r_projvcsfeed, projectname=projectname, id=id)
    else:
        h.url_vcstimeline = h.url_for(h.r_projvcstlines, projectname=projectname)
        h.url_rssfeed = h.url_for(h.r_projvcsfeeds, projectname=projectname)
    h.suburl_createvcs = h.url_for(h.r_projvcscreate, projectname=projectname, form='submit', formname='createvcs')
    h.suburl_configvcs = h.url_for(h.r_projvcs, projectname=projectname, form='submit', formname='configvcs', view='js')
    h.suburl_createmount_e = h.url_for(h.r_projmounts, projectname=projectname, form='submit', formname='createmount', view='js')
    h.suburl_deletemount_e = h.url_for(h.r_projmounts, projectname=projectname, form='submit', formname='deletemount', view='js')
    h.suburl_search = h.url_for(h.r_searchpage)
    h.url_vcslist = h.url_for(h.r_projvcs, projectname=projectname, jsonobj='vcslist', view='js')
    h.list_rootdir = c.vcs and h.url_for(h.r_projvcsbrowse, projectname=c.project.projectname, id=c.vcs.id, repopath=c.vcs.rooturl, revno=c.revno, jsonobj='dirlist', view='js') or ''


class ProjvcsController(BaseController):
    """Class to handle project page request"""

    def _optimized_fetch(self, controllername, projectname):
        """Fetch the project object and vcs object from the database in
        an optimized manner based on the action and json request"""
        c.project = projectname and projcomp.get_project(projectname, attrload=[
         'logofile'], attrload_all=[
         'vcslist.type'])

    def __before__(self, environ):
        """Called before calling any actions under this controller"""
        beforecontrollers(environ=environ)
        do_onetime()
        c.form = request.params.get('form', None)
        c.formname = request.params.get('formname', None)
        c.view = request.params.get('view', None)
        c.jsonobj = request.params.get('jsonobj', None)
        c.textobj = request.params.get('textobj', None)
        c.revno = request.params.get('revno', None)
        c.rev1 = request.params.get('rev1', None)
        c.rev2 = request.params.get('rev2', None)
        c.repopath = request.params.get('repopath', None)
        c.pathinfo = request.environ['PATH_INFO']
        routes_map = config['routes.map']
        (d, robj) = routes_map.routematch(c.pathinfo)
        projectname = d.get('projectname', None)
        c.vcs = None
        c.vcseditable = None
        if re.search('/s/+', c.pathinfo):
            vcs_id = d.get('id', None)
            c.vcs = vcs_id and vcscomp.get_vcs(int(vcs_id), attrload=[
             'type']) or None
        self._optimized_fetch(robj.name, projectname)
        c.prjlogo = c.project and c.project.logofile and h.url_forattach(c.project.logofile.id)
        c.revno = c.revno and int(c.revno) or None
        c.rev1 = c.rev1 and int(c.rev1) or None
        c.rev2 = c.rev2 and int(c.rev2) or None
        c.vcslist = [ [h.url_for(h.r_projvcsbrowse, projectname=projectname, id=v.id), v.name] for v in c.project.vcslist
                    ]
        c.vrep = None
        if c.vcs:
            c.vrep = va.open_repository(c.vcs)
            c.revno_l = c.vrep.linfo['l_revision']
            c.revno = c.revno or c.revno_l
            c.revno_p = c.revno - 1 >= 1 and c.revno - 1 or None
            c.revno_n = c.revno + 1 <= c.revno_l and c.revno + 1 or None
        return

    @h.authorize(h.HasPermname('VCS_VIEW'))
    def _json_vcslist(self):
        """JSON: { id   : 'id',
                   label: 'vcs_id',
                   items: [ { 'id'          : v.id,
                              'name'        : v.name,
                              'rooturl'     : v.rooturl,
                              'href'        : href,
                              'vcs_typename': v.type.vcs_typename },
                            ... ]
                 }"""

        def format_item(v):
            href = h.url_for(h.r_projvcsbrowse, projectname=c.project.projectname, id=str(v.id))
            d = {'id': v.id, 
               'name': v.name, 
               'rooturl': v.rooturl, 
               'href': href, 
               'vcs_typename': v.type.vcs_typename}
            return d

        return h.todojoreadstore(c.project.vcslist, format_item, id='id', label='vcs_id')

    @h.authorize(h.HasPermname('VCS_VIEW'))
    def _json_dirlist(self):
        """JSON : { id: 'dirlist',
                    label: 'dirlist',
                    items: [{ 'dirlist': '',
                              'dirs' : [ [ dirname, listurl, repos_path ], ... ],
                              'files': [ [ created_revision, mime_type, path,
                                           author, size, timestamp, repos_path,
                                           basename, url ],
                                         ... ]
                            }]"""
        c.vrep = va.open_repository(c.vcs)
        listing = {}
        [ listing.setdefault(f[1], []).append(f) for f in c.vrep.list(c.repopath, revno=c.revno)
        ]
        listing['text/directory'] = map(lambda f: [basename(f[2]),
         h.url_for(h.r_projvcsbrowse, projectname=c.project.projectname, id=c.vcs.id, repopath=f[2], revno=c.revno, jsonobj='dirlist', view='js'),
         f[6][2:] if f[6][:2] == './' else f[6].lstrip('/')], listing.get('text/directory', []))
        listing['text/file'] = map(lambda f: f + [
         basename(f[2]),
         h.url_for(h.r_projvcsfile, projectname=c.project.projectname, id=str(c.vcs.id), filepath=f[6].lstrip('/'), revno=c.revno)], listing.get('text/file', []))
        return h.todojoreadstore([
         {'dirlist': 0, 'dirs': listing['text/directory'], 
            'files': listing['text/file']}], lambda v: v, id='dirlist', label='dirlist')

    @h.authorize(h.HasPermname('VCS_VIEW'))
    def vcsindex(self, environ, projectname):
        """Project source control"""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname)
        if c.form == 'submit' and c.formname in vcsperm and not h.authorized(vcsperm[c.formname]):
            return 'Do not have %s permission !!' % vcsperm[c.formname]
        else:
            if c.form in ('submit', 'request'):
                try:
                    vf.process(request, c)
                except ZetaFormError, (errmsg,):
                    response.status_int = 400
                    return errmsg

            c.project = c.project or projcomp.get_project(projectname)
            c.vcs_typenames = vcscomp.vcstypenames
            c.vcseditable = h.authorized(h.HasPermname('VCS_CREATE'))
            c.title = '%s:source' % projectname
            html = ''
            if c.view == 'js' and c.jsonobj:
                func = getattr(self, '_json_' + c.jsonobj, None)
                if func:
                    html = func()
            elif c.view != 'js':
                html = render('/derived/projects/vcsindex.html')
            return html

    @h.authorize(h.HasPermname('VCS_CREATE'))
    def createvcs(self, environ, projectname):
        """Create / config / delete VCS entries"""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname)
        if c.form in ('submit', 'request'):
            if not h.authorized(h.HasPermname('VCS_CREATE')):
                return 'Do not have VCS_CREATE permission !!'
            try:
                vf.process(request, c, user=c.authuser)
            except ZetaFormError, (errmsg,):
                response.status_int = 400
                return errmsg

        c.project = c.project or projcomp.get_project(projectname)
        c.vcs_typenames = vcscomp.vcstypenames
        c.title = 'IntegrateSource'
        if c.form == 'submit':
            c.title = '-Skip-'
            h.redirect_to(h.r_projvcscreate, projectname=projectname, form='request', formname='createvcs')
        html = render('/derived/projects/vcscreate.html')
        return html

    @h.authorize(h.HasPermname('VCS_VIEW'))
    def vcs_browse(self, environ, projectname, id):
        """Browse repository"""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname, id=id)
        c.rootdir = basename(c.vcs.rooturl.rstrip('/'))
        c.project = c.project or projcomp.get_project(projectname)
        c.vcseditable = h.authorized(h.HasPermname('VCS_CREATE'))
        c.contents = vcscomp.mountcontents
        c.title = '%s:browse' % c.vcs.name
        html = ''
        if c.jsonobj and c.view == 'js':
            func = getattr(self, '_json_' + c.jsonobj, None)
            if func:
                html = func()
        else:
            c.pmounts = vcscomp.projmounts(c.project)
            c.mountdirs = [ [mnt[0], h.fix2repospath(mnt[3], [mnt[7]]).lstrip('/')] for mnt in c.pmounts
                          ]
            html = render('/derived/projects/vcsbrowse.html')
        return html

    @h.authorize(h.HasPermname('VCS_VIEW'))
    def vcs_file(self, environ, projectname, id, filepath):
        """Create / config / delete VCS entries"""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname, id=id)
        c.project = c.project or projcomp.get_project(projectname)
        fileurl = join(c.vcs.rooturl, filepath)
        c.fileerror = ''
        c.vfile = c.vrep.file(fileurl, revno=c.revno)
        try:
            c.fileinfo = c.vfile.info(revno=c.revno)
            c.filelines = c.vfile.cat(revno=c.revno, annotate=True)
            h.url_filedownl = h.url_for(h.r_projvcsfiledown, projectname=projectname, id=id, repopath=filepath, revno=c.revno)
        except:
            c.fileinfo = {}
            c.filelines = []
            c.fileerror = 'Unable to obtain file %s at revision %s' % (
             fileurl, c.revno)

        try:
            c.filelogs = c.vrep.logs(fileurl)
            c.filelogs = sorted(c.filelogs, key=lambda x: x[1], reverse=True)
            [ l.append(h.url_for(h.r_projvcsrev, projectname=projectname, id=id, revno=l[1])) for l in c.filelogs
            ]
            c.sel_frevs = [ [h.url_for(h.r_projvcsfile, projectname=projectname, id=id, filepath=filepath.lstrip('/'), revno=l[1]), str(l[1])] for l in c.filelogs
                          ]
        except:
            c.fileerror = ('Unable to obtain the history for file %s ' + 'at revision %s') % (fileurl, c.revno)
            c.sel_frevs = []
            c.filelogs = []

        _urlreviewfile(projectname, fileurl, c.vfile.revno)
        c.vcseditable = h.authorized(h.HasPermname('VCS_CREATE'))
        c.title = '%s:r%s' % (basename(filepath), c.revno)
        html = render('/derived/projects/vcsfile.html')
        return html

    @h.authorize(h.HasPermname('VCS_VIEW'))
    def vcs_revlist(self, environ, projectname, id):
        """Browse repository"""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname, id=id)
        c.project = c.project or projcomp.get_project(projectname)
        c.replogs = c.vrep.logs(c.vcs.rooturl, revstart=c.vrep.finfo['l_revision'], revend=c.vrep.linfo['l_revision'])
        c.revpages = [ [c.replogs[i][1], h.url_for(h.r_projvcsrevlist, projectname=projectname, id=id, revno=c.replogs[i][1])] for i in range(0, len(c.replogs), 100)
                     ]
        c.revpages.reverse()
        c.revlist = [ log + [h.url_for(h.r_projvcsrev, projectname=projectname, id=id, revno=log[1])] for log in c.replogs[c.revno - 1:c.revno + 99]
                    ]
        c.revlist.reverse()
        c.vcseditable = h.authorized(h.HasPermname('VCS_CREATE'))
        c.title = '%s:revlist' % c.vcs.name
        html = render('/derived/projects/vcsrevlist.html')
        return html

    @h.authorize(h.HasPermname('VCS_VIEW'))
    def vcs_revision(self, environ, projectname, id):
        """Browse repository"""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname, id=id)
        c.project = c.project or projcomp.get_project(projectname)
        c.revision = c.vrep.logs(c.vcs.rooturl, revstart=c.revno, revend=c.revno)
        c.revision = c.revision and c.revision[0] or ['', '', '', '']
        c.changedfiles = c.vrep.changedfiles(c.vcs.rooturl, revstart=c.revno - 1, revend=c.revno)
        c.revision.append(h.url_for(h.r_projvcsdiffdown, projectname=projectname, id=id, rev1=c.revno - 1, rev2=c.revno))
        for cf in c.changedfiles:
            cf['fileurl'] = h.url_for(h.r_projvcsfile, projectname=projectname, id=id, filepath=cf['repos_path'].lstrip('/'), revno=c.revno)
            if cf['changetype'] == 'modified':
                cf['diff'] = c.vrep.diff(join(c.vcs.rooturl, cf['repos_path']), c.revno_p and c.revno - 1, c.revno)
                cf['diffdownlurl'] = h.url_for(h.r_projvcsdiffdown, projectname=projectname, id=id, repopath=cf['repos_path'], rev1=c.revno - 1, rev2=c.revno)
            else:
                cf['diff'] = ''

        _urlreviewrev(projectname, c.vcs.id, c.revision[1])
        c.vcseditable = h.authorized(h.HasPermname('VCS_CREATE'))
        c.vcsrevision = True
        c.title = '%s:r%s' % (c.vcs.name, c.revno)
        html = render('/derived/projects/vcsrevision.html')
        return html

    @h.authorize(h.HasPermname(['VCS_VIEW']))
    def diffdownload(self, environ, projectname, id=''):
        """Provide downloadable diff for individual files between revisions or
        for the entire revision, the revision difference will be for rev2."""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname, id=id)
        c.project = c.project or projcomp.get_project(projectname)
        diff = ''
        if c.repopath and c.rev1 and c.rev2:
            diff = c.vrep.diff(join(c.vcs.rooturl, c.repopath), c.rev1, c.rev2)
            filename = '%s:%s-r%s' % (
             c.vcs.name, basename(c.repopath), c.rev2)
        elif c.rev1 and c.rev2:
            changedfiles = c.vrep.changedfiles(c.vcs.rooturl, revstart=c.rev1, revend=c.rev2)
            for cf in changedfiles:
                if cf['changetype'] == 'modified':
                    diff += c.vrep.diff(join(c.vcs.rooturl, cf['repos_path']), c.rev1, c.rev2) + '\n\n'

            filename = '%s-r%s' % (c.vcs.name, c.rev2)
        response.headers['Content-disposition'] = str('attachment; filename="%s.diff"' % filename)
        return diff

    @h.authorize(h.HasPermname(['VCS_VIEW']))
    def filedownload(self, environ, projectname, id=''):
        """Download entire file for the specified revision"""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname, id=id)
        c.project = c.project or projcomp.get_project(projectname)
        vfile = c.vrep.file(join(c.vcs.rooturl, c.repopath), revno=c.revno)
        file = ''
        if c.repopath and c.revno:
            file = ('\n').join([ ltup[1] for ltup in vfile.cat(revno=c.revno, annotate=False)
                               ])
            (fname, ext) = splitext(basename(c.repopath))
        filename = '%s.r%s%s' % (fname, c.revno, ext)
        response.headers['Content-disposition'] = str('attachment; filename="%s"' % filename)
        return file

    @h.authorize(h.HasPermname(['VCS_VIEW']))
    def timeline(self, environ, projectname, id=''):
        """Aggregate activities under project vcs or individual vcs"""
        logid = request.params.get('logid', None)
        dir = request.params.get('dir', None)
        fromoff = request.params.get('fromoff', 1)
        logid = logid and int(logid)
        fromoff = int(fromoff)
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=3)
        viewuserpanes(projectname=projectname)
        _url(projectname, id=id)
        c.project = c.project or projcomp.get_project(projectname)
        c.vcs = id and vcscomp.get_vcs(int(id)) or None
        routeargs = {'projectname': projectname}
        id and routeargs.update({'id': id})
        if id:
            h.tline_controller(c, h.r_projvcstline, routeargs, 'vcs', fromoff, logid, dir, c.vcs)
            c.title = '%s:timeline' % c.vcs.name
        else:
            h.tline_controller(c, h.r_projvcstlines, routeargs, [
             'vcs', 'project'], fromoff, logid, dir, c.project)
            c.title = 'Source:timeline'
        return render('/derived/projects/vcstline.html')

    def feed(self, environ, projectname, id=''):
        """Aggregate activities under project vcs or individual vcs"""
        host = environ['HTTP_HOST']
        script = environ['SCRIPT_NAME']
        c.project = c.project or projcomp.get_project(projectname)
        c.vcs = id and vcscomp.get_vcs(int(id)) or None
        routeargs = {'projectname': projectname}
        id and routeargs.update({'id': id})
        if id:
            h.tline_controller(c, h.r_projvcstline, routeargs, 'vcs', 1, None, None, c.vcs)
            title = '%s-vcs:%s' % (projectname, c.vcs.name)
            link = 'http://%s%s' % (host, script)
            descr = 'Timeline for vcs, %s in project %s' % (
             c.vcs.name, projectname)
        else:
            h.tline_controller(c, h.r_projvcstlines, routeargs, [
             'vcs', 'project'], 1, None, None, c.project)
            title = '%s:vcs' % projectname
            link = 'http://%s%s' % (host, script)
            descr = 'Timeline for vcs, in project %s' % projectname
        feed = h.FeedGen(title, link, descr)
        for l in c.logs:
            (summary, lnk, content) = h.log2feed(l)
            feed.add_item(summary, '%s%s' % (link, lnk), content, pubdate=l.created_on, unique_id=str(l.id), author_name=l.user.username)

        response.content_type = 'application/atom+xml'
        feedhtml = feed.writeString('utf-8')
        return feedhtml

    def __after__(self):
        """Called calling any actions under this controller"""
        aftercontrollers()
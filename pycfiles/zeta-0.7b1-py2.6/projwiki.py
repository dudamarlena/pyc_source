# uncompyle6 version 3.7.4
# Python bytecode 2.6 (62161)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-i686/egg/zeta/controllers/projwiki.py
# Compiled at: 2010-07-06 10:46:47
"""Controller module to manage project wiki pages."""
import logging, datetime as dt, re
from pylons import request, response, session, tmpl_context as c
from pylons.controllers.util import abort
from pylons import config
import simplejson as json
from authkit.authorize import PermissionError, PermissionSetupError, NotAuthenticatedError, NotAuthorizedError, middleware
from zeta.lib.base import BaseController, render
from zeta.config.environment import beforecontrollers, aftercontrollers
from zeta.lib.view import viewcontext, viewuserpanes, viewprojectpanel, Anchor
import zeta.lib.helpers as h, zeta.lib.analytics as ca
from zeta.lib.constants import *
from zeta.lib.error import ZetaFormError
from zeta.comp.project import ProjectComponent
from zeta.comp.vote import VoteComponent
from zeta.comp.wiki import WikiComponent
from zeta.comp.forms import VForm
from zeta.comp.timeline import TimelineComponent
log = logging.getLogger(__name__)
compmgr = None
projcomp = None
wikicomp = None
votcomp = None
vf = None

def do_onetime():
    global compmgr
    global projcomp
    global vf
    global votcomp
    global wikicomp
    if compmgr == None:
        compmgr = config['compmgr']
        vf = VForm(compmgr)
        projcomp = ProjectComponent(compmgr)
        wikicomp = WikiComponent(compmgr)
        votcomp = VoteComponent(compmgr)
    return


wikiperm = {}
wikiperm.update(dict([ (formname, h.HasPermname('WIKI_CREATE')) for formname in [
 'createwiki', 'configwiki', 'wikitype',
 'wikisummary', 'wikicont', 'rmwikicont',
 'addwikiattachs', 'delwikiattachs',
 'addwikitags', 'delwikitags']
                     ]))
wikiperm.update(dict([ (formname, h.HasPermname('WIKICOMMENT_CREATE')) for formname in [
 'createwcmt', 'updatewcmt', 'replywcmt']
                     ]))

def _urlreview(projectname, url, version):
    """urls to be stuffed into the pages generated by this controller"""
    h.url_reviewwiki = h.url_for(h.r_projrevwcreate, projectname=projectname, form='request', formname='createrev', rurl=url, ver=version)


def _url(projectname='', url=''):
    """urls to be stuffed into the pages generated by this controller"""
    h.url_prj = h.url_for(h.r_projecthome, projectname=projectname)
    h.url_wikipage = h.url_for(h.r_projwiki, projectname=projectname, url=url)
    h.url_wikiedit = h.url_for(h.r_projwiki, projectname=projectname, url=url, wikiedit='1')
    h.url_wtalkpage = h.url_for(h.r_projwiki, projectname=projectname, url=url, wikitalkpage='1')
    h.url_whistory = h.url_for(h.r_projwiki, projectname=projectname, url=url, wikihistory='1')
    h.url_wikidiff = h.url_for(h.r_projwiki, projectname=projectname, url=url, wikidiff='1')
    h.url_translatewiki = h.url_for(h.r_projwiki, projectname=projectname, url=url, translate=1)
    h.url_tagcloud = h.url_for(h.r_tags)
    if url:
        h.url_wikitimeline = h.url_for(h.r_projwikitline, projectname=projectname, url=url)
        h.url_rssfeed = h.url_for(h.r_projwikifeed, projectname=projectname, url=url)
    else:
        h.url_wikitimeline = h.url_for(h.r_projwikistline, projectname=projectname)
        h.url_rssfeed = h.url_for(h.r_projwikisfeed, projectname=projectname)
    h.url_wikidownastext = h.url_for(h.r_projwiki, projectname=projectname, url=url, downloadas='text')
    h.url_wikidownasps = h.url_for(h.r_projwiki, projectname=projectname, url=url, downloadas='ps')
    h.url_wikidownaspdf = h.url_for(h.r_projwiki, projectname=projectname, url=url, downloadas='pdf')
    h.url_wikititleindex = h.url_for(h.r_projwtindex, projectname=projectname)
    h.url_wikicharts = h.url_for(h.r_projwikicharts, projectname=projectname)
    h.url_wikiattachs = h.url_for(h.r_projwikiattachs, projectname=projectname)
    h.url_addattachment = h.url_for(h.r_addattchments)
    h.suburl_configwiki = h.url_for(h.r_projwikis, projectname=projectname, form='submit', formname='configwiki', view='js')
    h.suburl_addwikiattachs = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='addwikiattachs', view='js')
    h.suburl_delwikiattachs = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='delwikiattachs', view='js')
    h.suburl_addwikitags = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='addwikitags', view='js')
    h.suburl_delwikitags = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='delwikitags', view='js')
    h.suburl_wikiedit = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='wikicont', view='js')
    h.suburl_createwcmt = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='createwcmt', view='js')
    h.suburl_updatewcmt = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='updatewcmt', view='js')
    h.suburl_replywcmt = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='replywcmt', view='js')
    h.suburl_wikidiff = h.url_for(h.r_projwiki, projectname=projectname, url=url, wikidiff='1', form='submit', formname='wikidiff')
    h.suburl_wikifav = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='wikifav', view='js')
    h.suburl_votewiki = h.url_for(h.r_projwiki, projectname=projectname, url=url, form='submit', formname='votewiki', view='js')
    h.suburl_attachssummary = h.url_for(h.r_projwikiattachs, projectname=projectname, form='submit', formname='attachssummary', view='js')
    h.suburl_attachstags = h.url_for(h.r_projwikiattachs, projectname=projectname, form='submit', formname='attachstags', view='js')
    h.suburl_search = h.url_for(h.r_searchpage)
    h.url_wikilist = h.url_for(h.r_projwikis, projectname=projectname, jsonobj='wikilist', view='js')
    h.url_wikicomments = h.url_for(h.r_projwiki, projectname=projectname, url=url, jsonobj='wikicomments', view='js')
    h.url_wikircomments = h.url_for(h.r_projwiki, projectname=projectname, url=url, jsonobj='wikircomments', view='js')
    h.url_wikiattachments = h.url_for(h.r_projwiki, projectname=projectname, url=url, jsonobj='wikiattach', view='js')
    h.url_wikitags = h.url_for(h.r_projwiki, projectname=projectname, url=url, jsonobj='wikitag', view='js')
    h.url_wikipreview = h.url_for(h.r_projwiki, projectname=projectname, url=url, textobj='wikipreview', view='text')


class ProjwikiController(BaseController):
    """Class to handle project wiki page request"""

    def _optimized_fetch(self, controllername, projectname):
        """Fetch the project object and wiki object from the database in
        an optimized manner based on the action and json request"""
        if c.jsonobj == 'wikicomments':
            c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo))
        elif c.jsonobj == 'wikircomments':
            c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo))
        elif c.jsonobj == 'wikilist':
            c.project = c.project or projcomp.get_project(projectname, attrload=[
             'logofile', 'wikis', 'wikis.tablemap',
             'wikis.votes', 'wikis.type'])
        elif c.textobj == 'wikipreview':
            c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo))
        elif controllername == 'wiki' and c.wikiedit:
            c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo), attrload=[
             'tablemap'])
        elif controllername == 'wiki' and c.wtalkpage:
            c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo), attrload=[
             'tablemap'])
        elif controllername == 'wiki' and c.whistory:
            c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo), attrload=[
             'tablemap'])
        elif controllername == 'wiki' and c.wikidiff:
            c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo), attrload=[
             'tablemap'])
        elif controllername == 'wiki':
            c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo), attrload=[
             'type', 'attachments', 'tags', 'tablemap',
             'votes'])
        c.project = c.project or projcomp.get_project(projectname, attrload=[
         'logofile'])

    def __before__(self, environ):
        """Called before calling any actions under this controller"""
        beforecontrollers(environ=environ)
        do_onetime()
        c.form = request.params.get('form', None)
        c.formname = request.params.get('formname', None)
        c.view = request.params.get('view', None)
        c.jsonobj = request.params.get('jsonobj', None)
        c.textobj = request.params.get('textobj', None)
        c.wikipage = request.params.get('wikipage', None)
        c.wikipreview = request.params.get('wikipreview', None)
        c.wikiedit = request.params.get('wikiedit', None)
        c.wikidiff = request.params.get('wikidiff', None)
        c.wtalkpage = request.params.get('wikitalkpage', None)
        c.whistory = request.params.get('wikihistory', None)
        c.translate = request.params.get('translate', False) and True
        c.downloadas = request.params.get('downloadas', None)
        c.oldver = request.POST.get('oldver', None)
        c.newver = request.POST.get('newver', None)
        c.oldver = c.oldver and int(c.oldver)
        c.newver = c.newver and int(c.newver)
        c.pathinfo = request.environ['PATH_INFO'].rstrip('/')
        routes_map = config['routes.map']
        (d, robj) = routes_map.routematch(c.pathinfo)
        projectname = d.get('projectname', None)
        c.wikiurl = d.get('url', None)
        c.wiki = None
        self._optimized_fetch(robj.name, projectname)
        c.prjlogo = c.project and c.project.logofile and h.url_forattach(c.project.logofile.id)
        c.searchfaces = [
         (
          'project', projectname),
         ('wiki', '1')]
        return

    def _wikiattachs(self, wiki):
        """For JSON consumption.
        Massage the wiki attachments"""
        attachs = dict([ (a.id, [a.id, h.url_for(h.r_attachdownl, id=str(a.id)), a.filename, a.summary]) for a in wiki.attachments
                       ])
        return attachs

    def _wikitags(self, wiki):
        """For JSON consumption.
        Massage the wiki tags"""
        return dict([ (t.tagname, t.tagname) for t in wiki.tags ])

    @h.authorize(h.HasPermname('WIKI_VIEW'))
    def _json_wikilist(self):
        """JSON: { id   : 'id',
                   label: 'wiki_id',
                   items: [ { id             : wiki.id,
                              wikiurl        : wiki.wikiurl ,
                              pagename       : wurl,
                              summary        : wiki.summary ,
                              wiki_typename  : wiki.type.wiki_typename ,
                              latest_version : wiki.latest_version ,
                              last_modified  : wcnt.created_on ,
                              author         : wcnt.author,
                              upvotes        : upvotes ,
                              downvotes      : downvotes }
                            ... ]
                 }"""

        def format_item(w):
            routes_map = config['routes.map']
            (d, robj) = routes_map.routematch(w.wikiurl)
            wurl = d.get('url', None)
            wcnt = wikicomp.get_content(w)
            votes = wikicomp.countvotes(votes=w.votes)
            lastmod = wcnt and h.utc_2_usertz(wcnt.created_on, c.authuser.timezone).strftime('%d %b %Y, %r') or 'N/A'
            author = wcnt and wcnt.author or 'N/A'
            d = {'id': w.id, 
               'wikiurl': w.wikiurl, 
               'pagename': wurl, 
               'summary': w.summary, 
               'wiki_typename': w.type.wiki_typename, 
               'latest_version': str(w.latest_version), 
               'last_modified': lastmod, 
               'author': author, 
               'upvotes': votes.get('up', 0), 
               'downvotes': votes.get('down', 0)}
            return d

        return h.todojoreadstore(c.project.wikis, format_item, id='id', label='wiki_id')

    @h.authorize(h.HasPermname('WIKI_VIEW'))
    def _json_wikiattach(self):
        """JSON: { id : [ id, url, filename, summary ], ... } """
        return json.dumps(c.wiki and self._wikiattachs(c.wiki) or {})

    @h.authorize(h.HasPermname('WIKI_VIEW'))
    def _json_wikitag(self):
        """JSON: { tagname : tagname, ... } """
        return json.dumps(c.wiki and self._wikitags(c.wiki) or {})

    @h.authorize(h.HasPermname('WIKI_VIEW'))
    def _json_wikicomments(self):
        """JSON: { wiki_comment_id : 'wiki_comment_id',
                   wiki_comment_id : 'wiki_comment_id',
                   items: [ { wiki_comment_id : wcmt.id,
                              version_id      : wcmt.version_id,
                              commentby       : wcmt.commentby.username ,
                              text            : wcmt.text,
                              html            : wcmt.texthtml,
                              commentbyicon   : usericon,
                              commentbyurl    : userurl,
                              datestr         : wcmt.created_on },
                            ... ]
                 }"""

        def format_item(qres):
            d = {'wiki_comment_id': qres[0], 
               'version_id': qres[1], 
               'commentby': qres[5], 
               'text': qres[2], 
               'html': qres[3], 
               'commentbyicon': '', 
               'commentbyurl': h.url_foruser(qres[5]), 
               'datestr': h.utc_2_usertz(qres[4], c.authuser.timezone).strftime('%d %b %Y, %r')}
            return d

        return h.todojoreadstore(wikicomp.wikicomments(c.wiki.id), format_item, id='wiki_comment_id', label='wiki_comment_id')

    @h.authorize(h.HasPermname('WIKI_VIEW'))
    def _json_wikircomments(self):
        """JSON: { wiki_comment_id : 'wiki_comment_id',
                   wiki_comment_id : 'wiki_comment_id',
                   items: [ { wiki_comment_id : wcmt.id,
                              version_id      : wcmt.version_id,
                              commentby       : wcmt.commentby.username ,
                              text            : wcmt.text,
                              html            : wcmt.texthtml,
                              commentbyicon   : usericon,
                              commentbyurl    : userurl,
                              datestr         : wcmt.created_on },
                            ... ]
                 }"""

        def format_item(qres):
            d = {'wiki_comment_id': qres[0], 
               'version_id': qres[1], 
               'commentby': qres[5], 
               'text': qres[2], 
               'html': qres[3], 
               'commentbyicon': '', 
               'commentbyurl': h.url_foruser(qres[5]), 
               'datestr': h.utc_2_usertz(qres[4], c.authuser.timezone).strftime('%d %b %Y, %r')}
            return d

        wcomments = wikicomp.wikircomments(c.wiki.id)
        items = []
        while wcomments:
            wcomment = wcomments.pop(0)
            d_wcmt = format_item(wcomment)
            d_wcmt.setdefault('replies', [ format_item(rwcomment) for rwcomment in wcomment[(-1)] ])
            items.append(d_wcmt)

        return h.todojoreadstore(items, lambda v: v, id='wiki_comment_id', label='wiki_comment_id')

    @h.authorize(h.HasPermname('WIKI_CREATE'))
    def _text_wikipreview(self):
        """ TEXT : HTML content of wiki markup text"""
        o = h.Preview()
        setattr(o, 'text', request.POST.get('text', ''))
        o.translate = h.hitch(o, h.Preview, h.translate, cacheattr='text')
        return o.translate()

    @h.authorize(h.HasPermname('WIKI_VIEW'))
    def wikiindex(self, environ, projectname):
        """Project wiki pages."""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=1)
        viewuserpanes(projectname=projectname)
        _url(projectname, url='')
        if c.form in ('submit', 'request'):
            try:
                vf.process(request, c)
            except ZetaFormError, (errmsg,):
                response.status_int = 400
                return errmsg

        c.project = c.project or projcomp.get_project(projectname)
        if not c.jsonobj:
            c.wikitypenames = wikicomp.typenames
            c.wikipagenames = map(lambda wu: [wu, h.wiki_parseurl(wu)], wikicomp.wikiurls(c.project))
            c.wikipagename = None
            c.wikieditable = h.authorized(h.HasPermname('WIKI_CREATE'))
            c.title = '%s:wiki' % projectname
        html = ''
        if c.view == 'js' and c.jsonobj:
            func = getattr(self, '_json_' + c.jsonobj, None)
            if func:
                html = func()
        elif c.view != 'js':
            html = render('/derived/projects/wikiindex.html')
        return html

    @h.authorize(h.HasPermname('WIKI_VIEW'))
    def titleindex(self, environ, projectname):
        """Title index of all Project wiki pages."""
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=1)
        viewuserpanes(projectname=projectname)
        _url(projectname, url='')
        c.project = c.project or projcomp.get_project(projectname)
        c.wikipagenames = map(lambda wu: [wu, h.wiki_parseurl(wu)], wikicomp.wikiurls(c.project))
        c.wikipagename = None
        c.titlepages = sorted(map(lambda x: (x[1], ''), c.wikipagenames), key=lambda x: x[0])
        c.title = '%s:titleindex' % projectname
        html = render('/derived/projects/wikitindex.html')
        return html

    @h.authorize(h.HasPermname('WIKI_VIEW'))
    def wiki(self, environ, projectname, url=None):
        """Project wiki pages."""
        version = request.params.get('ver', None)
        url = url.rstrip('/')
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=1)
        viewuserpanes(projectname=projectname)
        _url(projectname, url)
        if c.form == 'submit' and c.formname in wikiperm and not h.authorized(wikiperm[c.formname]):
            return 'Do not have %s permission !!' % wikiperm[c.formname]
        else:
            if c.form in ('submit', 'request'):
                try:
                    vf.process(request, c, user=c.authuser)
                except ZetaFormError, (errmsg,):
                    response.status_int = 400
                    return errmsg

            if not c.jsonobj:
                c.project = c.project or projcomp.get_project(projectname)
                c.wikipagenames = map(lambda wu: [wu, h.wiki_parseurl(wu)], wikicomp.wikiurls(c.project))
                c.wikipagename = url
                c.wikieditable = h.authorized(h.HasPermname('WIKI_CREATE'))
                c.wiki = c.wiki or wikicomp.get_wiki(unicode(c.pathinfo))
            if not c.wiki and c.wikieditable:
                c.wiki = wikicomp.create_wiki(unicode(c.pathinfo), type=c.sysentries.get('def_wikitype', None), creator=c.authusername)
                c.project and wikicomp.config_wiki(c.wiki, project=c.project)
                c.wikiedit = '1'
            elif not c.wiki:
                raise NotAuthorizedError('Do not have permission to create wiki page, WIKI_CREATE')
            if not c.wiki.latest_version and c.wikieditable:
                h.flash(MESSAGE_FLASH + 'Empty page, write some text ...')
                c.wikiedit = '1'
            elif not c.wiki.latest_version:
                raise NotAuthorizedError('Do not have permission to create wiki page, WIKI_CREATE')
            if c.wiki:
                c.isuserfavorite = wikicomp.isfavorite(c.authuser.id, c.wiki.id)
            c.title = (len(url) > 9 and '...' or '') + url[-9:]
            html = ''
            if c.view == 'js' and c.formname in ('addwikiattachs', ):
                html = IFRAME_RET
            elif c.view == 'js' and c.jsonobj:
                func = getattr(self, '_json_' + c.jsonobj, None)
                if func:
                    html = func()
                    c.title = '-Skip-'
            elif c.view == 'text' and c.textobj:
                func = getattr(self, '_text_' + c.textobj, None)
                if func:
                    html = func()
                    c.title = '-Skip-'
            elif c.wikiedit:
                c.wcnt = wikicomp.get_content(c.wiki)
                html = render('/derived/projects/wiki.html')
                c.title += ':edit'
            elif c.wtalkpage:
                c.items_wikicomments = self._json_wikicomments()
                html = render('/derived/projects/wiki.html')
                c.title += ':talkpage'
            elif c.whistory:
                c.wikicontents = wikicomp.get_content(c.wiki, all=True)
                html = render('/derived/projects/wiki.html')
                c.title += ':history'
            elif c.wikidiff:
                c.wcnt_oldver = wikicomp.get_content(c.wiki, version=c.oldver or 1)
                c.wcnt_newver = wikicomp.get_content(c.wiki, version=c.newver)
                c.oldver = c.wcnt_oldver.id
                c.newver = c.wcnt_newver.id
                html = render('/derived/projects/wiki.html')
                c.title += ':diff'
            elif c.downloadas:
                c.wcnt = wikicomp.get_content(c.wiki)
                if c.wcnt.text and not c.wcnt.texthtml:
                    wikihtml = c.wcnt.translate()
                else:
                    wikihtml = c.wcnt.texthtml
                fmtobj = h.Html2Doc(wikihtml, format=c.downloadas)
                html = fmtobj.convert()
                c.title = '-Skip-'
                response.headers['Content-disposition'] = str('attachment; filename="%s.%s"' % (c.wiki.wikiurl, c.downloadas))
            elif c.view != 'js':
                c.attachs = self._wikiattachs(c.wiki)
                c.tags = self._wikitags(c.wiki)
                c.att_editable = c.wikieditable
                c.tag_editable = c.wikieditable
                c.wcnts = wikicomp.get_content(c.wiki, all=True)
                c.wikiauthors = h.computecount(c.wcnts, lambda x: x.author)
                c.wcnt = c.wcnts and (version and c.wcnts[(int(version) - 1)] or c.wcnts[(-1)]) or None
                if c.wcnt:
                    if c.wcnt.text and not c.wcnt.texthtml:
                        c.wikihtml = c.wcnt.translate()
                    elif c.translate:
                        c.wikihtml = c.wcnt.translate()
                    else:
                        c.wikihtml = c.wcnt.texthtml
                else:
                    c.wikihtml = ''
                lastver = c.wiki.latest_version
                c.wversions = [ [h.url_for(h.r_projwiki, projectname=projectname, url=url, ver=str(v)), str(v)] for v in range(1, lastver + 1)
                              ]
                c.wdownload = [[h.url_wikidownastext, 'as text'],
                 [
                  h.url_wikidownasps, 'as post-script'],
                 [
                  h.url_wikidownaspdf, 'as pdf']]
                uservote = votcomp.get_wikivote(c.authuser, c.wiki)
                votes = wikicomp.countvotes(votes=c.wiki.votes)
                c.upvotes = votes.get('up', 0)
                c.downvotes = votes.get('down', 0)
                c.currvote = uservote and uservote.votedas or ''
                _urlreview(projectname, c.wiki.wikiurl, c.wcnt.id)
                html = render('/derived/projects/wiki.html')
            return html

    @h.authorize(h.HasPermname(['WIKI_VIEW']))
    def timeline(self, environ, projectname, url=''):
        """Aggregate activities under project wiki or individual wiki"""
        logid = request.params.get('logid', None)
        dir = request.params.get('dir', None)
        fromoff = request.params.get('fromoff', 1)
        logid = logid and int(logid)
        fromoff = int(fromoff)
        viewcontext(projectname=projectname)
        viewprojectpanel(projectname=projectname, activetab=1)
        viewuserpanes(projectname=projectname)
        _url(projectname, url)
        c.project = c.project or projcomp.get_project(projectname)
        wikiurl = h.url_for(h.r_projwiki, projectname=projectname, url=url)
        c.wiki = url and wikicomp.get_wiki(unicode(wikiurl)) or None
        c.wikipagenames = map(lambda wu: [wu, h.wiki_parseurl(wu)], wikicomp.wikiurls(c.project))
        c.wikipagename = url
        routeargs = {'projectname': projectname}
        url and routeargs.update({'url': url})
        if url:
            h.tline_controller(c, h.r_projwikitline, routeargs, 'wiki', fromoff, logid, dir, c.wiki)
            c.title = (len(url) > 9 and '...' or '') + url[-9:]
            c.title = '%s:timeline' % c.title
        else:
            h.tline_controller(c, h.r_projwikistline, routeargs, [
             'wiki', 'project'], fromoff, logid, dir, c.project)
            c.title = 'Wiki:timeline'
        (c.datatline, c.startdt) = h.tlineplot(c.logs[:])
        return render('/derived/projects/wikitline.html')

    def feed(self, environ, projectname, url=''):
        """Aggregate activities under project wiki or individual wiki"""
        host = environ['HTTP_HOST']
        script = environ['SCRIPT_NAME']
        c.project = c.project or projcomp.get_project(projectname)
        wikiurl = h.url_for(h.r_projwiki, projectname=projectname, url=url)
        c.wiki = url and wikicomp.get_wiki(unicode(wikiurl)) or None
        routeargs = {'projectname': projectname}
        url and routeargs.update({'url': url})
        if url:
            h.tline_controller(c, h.r_projwikitline, routeargs, 'wiki', 1, None, None, c.wiki)
            title = '%s-wiki:%s' % (projectname, url)
            link = 'http://%s%s' % (host, script)
            descr = 'Timeline for wikipage, %s in project %s' % (
             url, projectname)
        else:
            h.tline_controller(c, h.r_projwikistline, routeargs, [
             'wiki', 'project'], 1, None, None, c.project)
            title = '%s:wikis' % projectname
            link = 'http://%s%s' % (host, script)
            descr = 'Timeline for wikipages, in project %s' % projectname
        feed = h.FeedGen(title, link, descr)
        for l in c.logs:
            (summary, lnk, content) = h.log2feed(l)
            feed.add_item(summary, '%s%s' % (link, lnk), content, pubdate=l.created_on, unique_id=str(l.id), author_name=l.user.username)

        response.content_type = 'application/atom+xml'
        feedhtml = feed.writeString('utf-8')
        return feedhtml

    @h.authorize(h.HasPermname(['WIKI_VIEW']))
    def charts(self, environ, projectname):
        """Charts and analytics for project wiki"""
        viewcontext(id=id)
        viewprojectpanel(projectname=projectname, activetab=1)
        viewuserpanes(id=id)
        _url(projectname=projectname)
        c.ta = ca.get_analyticobj('tags')
        c.wa = ca.get_analyticobj('wiki')
        c.chart20_data = getattr(c.ta, 'chart20_data', {}).get(c.project.id, [])
        c.chart20_tags = getattr(c.ta, 'chart20_tags', {}).get(c.project.id, [])
        c.chart16_data = getattr(c.wa, 'chart16_data', {}).get(c.project.id, [])
        c.chart16_wiki = getattr(c.wa, 'chart16_wiki', {}).get(c.project.id, [])
        c.chart17_data = getattr(c.wa, 'chart17_data', {}).get(c.project.id, [])
        c.chart18_data = getattr(c.wa, 'chart18_data', {}).get(c.project.id, [])
        c.chart18_usrs = getattr(c.wa, 'chart18_usrs', {}).get(c.project.id, [])
        c.chart19_data = getattr(c.wa, 'chart19_data', {}).get(c.project.id, [])
        c.chart19_usrs = getattr(c.wa, 'chart19_usrs', {}).get(c.project.id, [])
        c.title = 'WikiCharts'
        html = render('/derived/projects/wikicharts.html')
        return html

    @h.authorize(h.HasPermname(['WIKI_VIEW']))
    def attachs(self, environ, projectname):
        """Action to present attachment page for wiki pages under project 
        `projectname`"""
        viewcontext(id=id)
        viewprojectpanel(projectname=projectname, activetab=1)
        viewuserpanes(id=id)
        _url(projectname=projectname)
        if c.form in ('submit', 'request'):
            try:
                vf.process(request, c, user=c.authuser)
            except ZetaFormError, (errmsg,):
                response.status_int = 400
                return errmsg

        if c.view != 'js':
            attachments = wikicomp.attachments(c.project)
            c.attachments = {}
            c.wikipagenames = map(lambda wu: [wu, h.wiki_parseurl(wu)], wikicomp.wikiurls(c.project))
            for wkey in attachments:
                adict = attachments[wkey]
                attachs = [ [aid] + adict[aid][:-1] + [(', ').join(adict[aid][(-1)])] + [h.url_for(h.r_attachdownl, id=aid)] for aid in adict
                          ]
                wurl = h.wiki_parseurl(wkey[1])
                c.attachments[wurl] = attachs

            c.editable = h.authorized(h.HasPermname('WIKI_CREATE'))
            c.title = 'WikiAttachs'
            html = render('/derived/projects/wikiattachs.html')
        else:
            html = ''
        return html

    def __after__(self):
        """Called calling any actions under this controller"""
        aftercontrollers()
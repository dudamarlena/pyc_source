# uncompyle6 version 3.6.7
# Python bytecode 3.6 (3379)
# Decompiled from: Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: /home/okhin/git/orage.io/pygcrypt/env/lib/python3.6/site-packages/pygcrypt/build_gcrypt.py
# Compiled at: 2017-03-12 11:16:37
# Size of source mod 2**32: 59542 bytes
from ctypes.util import find_library
from cffi import FFI
from pygcrypt.build_gerror import gerror_ffi
gcrypt_ffi = FFI()
gcrypt_ffi.include(gerror_ffi)
gcrypt_ffi.set_source('pygcrypt._gcrypt', '\n        #include <gcrypt.h>\n        ',
  libraries=[
 'gcrypt'])
gcrypt_ffi.cdef('\n        /* Wrappers for the libgpg-error library.  */\n\n        typedef gpg_error_t gcry_error_t;\n        typedef gpg_err_code_t gcry_err_code_t;\n        typedef gpg_err_source_t gcry_err_source_t;\n\n        /* Return a pointer to a string containing a description of the error\n           code in the error value ERR.  */\n        const char *gcry_strerror (gcry_error_t err);\n\n        /* Return a pointer to a string containing a description of the error\n           source in the error value ERR.  */\n        const char *gcry_strsource (gcry_error_t err);\n\n        /* Retrieve the error code for the system error ERR.  This returns\n           GPG_ERR_UNKNOWN_ERRNO if the system error is not mapped (report\n           this).  */\n        gcry_err_code_t gcry_err_code_from_errno (int err);\n\n        /* Retrieve the system error for the error code CODE.  This returns 0\n           if CODE is not a system error code.  */\n        int gcry_err_code_to_errno (gcry_err_code_t code);\n\n        /* Return an error value with the error source SOURCE and the system\n           error ERR.  */\n        gcry_error_t gcry_err_make_from_errno (gcry_err_source_t source, int err);\n\n        /* Return an error value with the system error ERR.  */\n        gcry_err_code_t gcry_error_from_errno (int err);\n        ')
gcrypt_ffi.cdef('\n        /* A generic context object as used by some functions.  */\n        struct gcry_context;\n        typedef struct gcry_context *gcry_ctx_t;\n\n        /* The data objects used to hold multi precision integers.  */\n        struct gcry_mpi;\n        typedef struct gcry_mpi *gcry_mpi_t;\n        struct gcry_mpi_point;\n        typedef struct gcry_mpi_point *gcry_mpi_point_t;\n\n        /* A structure used for scatter gather hashing.  */\n        typedef struct\n        {\n          size_t size;  /* The allocated size of the buffer or 0.  */\n          size_t off;   /* Offset into the buffer.  */\n          size_t len;   /* The used length of the buffer.  */\n          void *data;   /* The buffer.  */\n        } gcry_buffer_t;\n        ')
gcrypt_ffi.cdef('\n        /* Check that the library fulfills the version requirement.  */\n        const char *gcry_check_version (const char *req_version);\n\n        /* Codes for function dispatchers.  */\n\n        /* Codes used with the gcry_control function. */\n        enum gcry_ctl_cmds\n          {\n            /* Note: 1 .. 2 are not anymore used. */\n            GCRYCTL_CFB_SYNC = 3,\n            GCRYCTL_RESET    = 4,   /* e.g. for MDs */\n            GCRYCTL_FINALIZE = 5,\n            GCRYCTL_GET_KEYLEN = 6,\n            GCRYCTL_GET_BLKLEN = 7,\n            GCRYCTL_TEST_ALGO = 8,\n            GCRYCTL_IS_SECURE = 9,\n            GCRYCTL_GET_ASNOID = 10,\n            GCRYCTL_ENABLE_ALGO = 11,\n            GCRYCTL_DISABLE_ALGO = 12,\n            GCRYCTL_DUMP_RANDOM_STATS = 13,\n            GCRYCTL_DUMP_SECMEM_STATS = 14,\n            GCRYCTL_GET_ALGO_NPKEY    = 15,\n            GCRYCTL_GET_ALGO_NSKEY    = 16,\n            GCRYCTL_GET_ALGO_NSIGN    = 17,\n            GCRYCTL_GET_ALGO_NENCR    = 18,\n            GCRYCTL_SET_VERBOSITY     = 19,\n            GCRYCTL_SET_DEBUG_FLAGS   = 20,\n            GCRYCTL_CLEAR_DEBUG_FLAGS = 21,\n            GCRYCTL_USE_SECURE_RNDPOOL= 22,\n            GCRYCTL_DUMP_MEMORY_STATS = 23,\n            GCRYCTL_INIT_SECMEM       = 24,\n            GCRYCTL_TERM_SECMEM       = 25,\n            GCRYCTL_DISABLE_SECMEM_WARN = 27,\n            GCRYCTL_SUSPEND_SECMEM_WARN = 28,\n            GCRYCTL_RESUME_SECMEM_WARN  = 29,\n            GCRYCTL_DROP_PRIVS          = 30,\n            GCRYCTL_ENABLE_M_GUARD      = 31,\n            GCRYCTL_START_DUMP          = 32,\n            GCRYCTL_STOP_DUMP           = 33,\n            GCRYCTL_GET_ALGO_USAGE      = 34,\n            GCRYCTL_IS_ALGO_ENABLED     = 35,\n            GCRYCTL_DISABLE_INTERNAL_LOCKING = 36,\n            GCRYCTL_DISABLE_SECMEM      = 37,\n            GCRYCTL_INITIALIZATION_FINISHED = 38,\n            GCRYCTL_INITIALIZATION_FINISHED_P = 39,\n            GCRYCTL_ANY_INITIALIZATION_P = 40,\n            GCRYCTL_SET_CBC_CTS = 41,\n            GCRYCTL_SET_CBC_MAC = 42,\n            /* Note: 43 is not anymore used. */\n            GCRYCTL_ENABLE_QUICK_RANDOM = 44,\n            GCRYCTL_SET_RANDOM_SEED_FILE = 45,\n            GCRYCTL_UPDATE_RANDOM_SEED_FILE = 46,\n            GCRYCTL_SET_THREAD_CBS = 47,\n            GCRYCTL_FAST_POLL = 48,\n            GCRYCTL_SET_RANDOM_DAEMON_SOCKET = 49,\n            GCRYCTL_USE_RANDOM_DAEMON = 50,\n            GCRYCTL_FAKED_RANDOM_P = 51,\n            GCRYCTL_SET_RNDEGD_SOCKET = 52,\n            GCRYCTL_PRINT_CONFIG = 53,\n            GCRYCTL_OPERATIONAL_P = 54,\n            GCRYCTL_FIPS_MODE_P = 55,\n            GCRYCTL_FORCE_FIPS_MODE = 56,\n            GCRYCTL_SELFTEST = 57,\n            /* Note: 58 .. 62 are used internally.  */\n            GCRYCTL_DISABLE_HWF = 63,\n            GCRYCTL_SET_ENFORCED_FIPS_FLAG = 64,\n            GCRYCTL_SET_PREFERRED_RNG_TYPE = 65,\n            GCRYCTL_GET_CURRENT_RNG_TYPE = 66,\n            GCRYCTL_DISABLE_LOCKED_SECMEM = 67,\n            GCRYCTL_DISABLE_PRIV_DROP = 68,\n            GCRYCTL_SET_CCM_LENGTHS = 69,\n            GCRYCTL_CLOSE_RANDOM_DEVICE = 70,\n            GCRYCTL_INACTIVATE_FIPS_FLAG = 71,\n            GCRYCTL_REACTIVATE_FIPS_FLAG = 72\n          };\n\n        /* Perform various operations defined by CMD. */\n        gcry_error_t gcry_control (enum gcry_ctl_cmds CMD, ...);\n        ')
gcrypt_ffi.cdef('\n        /* S-expression management. */\n\n        /* The object to represent an S-expression as used with the public key\n           functions.  */\n        struct gcry_sexp;\n        typedef struct gcry_sexp *gcry_sexp_t;\n\n        /* The possible values for the S-expression format. */\n        enum gcry_sexp_format\n          {\n            GCRYSEXP_FMT_DEFAULT   = 0,\n            GCRYSEXP_FMT_CANON     = 1,\n            GCRYSEXP_FMT_BASE64    = 2,\n            GCRYSEXP_FMT_ADVANCED  = 3\n          };\n\n        /* Create an new S-expression object from BUFFER of size LENGTH and\n           return it in RETSEXP.  With AUTODETECT set to 0 the data in BUFFER\n           is expected to be in canonized format.  */\n        gcry_error_t gcry_sexp_new (gcry_sexp_t *retsexp,\n                                    const void *buffer, size_t length,\n                                    int autodetect);\n\n         /* Same as gcry_sexp_new but allows to pass a FREEFNC which has the\n            effect to transfer ownership of BUFFER to the created object.  */\n        gcry_error_t gcry_sexp_create (gcry_sexp_t *retsexp,\n                                       void *buffer, size_t length,\n                                       int autodetect, void (*freefnc) (void *));\n\n        /* Scan BUFFER and return a new S-expression object in RETSEXP.  This\n           function expects a printf like string in BUFFER.  */\n        gcry_error_t gcry_sexp_sscan (gcry_sexp_t *retsexp, size_t *erroff,\n                                      const char *buffer, size_t length);\n\n        /* Same as gcry_sexp_sscan but expects a string in FORMAT and can thus\n           only be used for certain encodings.  */\n        gcry_error_t gcry_sexp_build (gcry_sexp_t *retsexp, size_t *erroff,\n                                      const char *format, ...);\n\n        /* Like gcry_sexp_build, but uses an array instead of variable\n           function arguments.  */\n        gcry_error_t gcry_sexp_build_array (gcry_sexp_t *retsexp, size_t *erroff,\n                                            const char *format, void **arg_list);\n\n        /* Release the S-expression object SEXP */\n        void gcry_sexp_release (gcry_sexp_t sexp);\n\n        /* Calculate the length of an canonized S-expresion in BUFFER and\n           check for a valid encoding. */\n        size_t gcry_sexp_canon_len (const unsigned char *buffer, size_t length,\n                                    size_t *erroff, gcry_error_t *errcode);\n\n        /* Copies the S-expression object SEXP into BUFFER using the format\n           specified in MODE.  */\n        size_t gcry_sexp_sprint (gcry_sexp_t sexp, int mode, void *buffer,\n                                 size_t maxlength);\n\n        /* Dumps the S-expression object A in a format suitable for debugging\n           to Libgcrypt\'s logging stream.  */\n        void gcry_sexp_dump (const gcry_sexp_t a);\n\n        gcry_sexp_t gcry_sexp_cons (const gcry_sexp_t a, const gcry_sexp_t b);\n        gcry_sexp_t gcry_sexp_alist (const gcry_sexp_t *array);\n        gcry_sexp_t gcry_sexp_vlist (const gcry_sexp_t a, ...);\n        gcry_sexp_t gcry_sexp_append (const gcry_sexp_t a, const gcry_sexp_t n);\n        gcry_sexp_t gcry_sexp_prepend (const gcry_sexp_t a, const gcry_sexp_t n);\n\n        /* Scan the S-expression for a sublist with a type (the car of the\n           list) matching the string TOKEN.  If TOKLEN is not 0, the token is\n           assumed to be raw memory of this length.  The function returns a\n           newly allocated S-expression consisting of the found sublist or\n           `NULL\' when not found.  */\n        gcry_sexp_t gcry_sexp_find_token (gcry_sexp_t list,\n                                        const char *tok, size_t toklen);\n        /* Return the length of the LIST.  For a valid S-expression this\n           should be at least 1.  */\n        int gcry_sexp_length (const gcry_sexp_t list);\n\n        /* Create and return a new S-expression from the element with index\n           NUMBER in LIST.  Note that the first element has the index 0.  If\n           there is no such element, `NULL\' is returned.  */\n        gcry_sexp_t gcry_sexp_nth (const gcry_sexp_t list, int number);\n\n        /* Create and return a new S-expression from the first element in\n           LIST; this called the "type" and should always exist and be a\n           string. `NULL\' is returned in case of a problem.  */\n        gcry_sexp_t gcry_sexp_car (const gcry_sexp_t list);\n\n        /* Create and return a new list form all elements except for the first\n           one.  Note, that this function may return an invalid S-expression\n           because it is not guaranteed, that the type exists and is a string.\n           However, for parsing a complex S-expression it might be useful for\n           intermediate lists.  Returns `NULL\' on error.  */\n        gcry_sexp_t gcry_sexp_cdr (const gcry_sexp_t list);\n\n        gcry_sexp_t gcry_sexp_cadr (const gcry_sexp_t list);\n\n\n        /* This function is used to get data from a LIST.  A pointer to the\n           actual data with index NUMBER is returned and the length of this\n           data will be stored to DATALEN.  If there is no data at the given\n           index or the index represents another list, `NULL\' is returned.\n           *Note:* The returned pointer is valid as long as LIST is not\n           modified or released.  */\n        const char *gcry_sexp_nth_data (const gcry_sexp_t list, int number,\n                                        size_t *datalen);\n\n        /* This function is used to get data from a LIST.  A malloced buffer to the\n           data with index NUMBER is returned and the length of this\n           data will be stored to RLENGTH.  If there is no data at the given\n           index or the index represents another list, `NULL\' is returned.  */\n        void *gcry_sexp_nth_buffer (const gcry_sexp_t list, int number,\n                                    size_t *rlength);\n\n        /* This function is used to get and convert data from a LIST.  The\n           data is assumed to be a Nul terminated string.  The caller must\n           release the returned value using `gcry_free\'.  If there is no data\n           at the given index, the index represents a list or the value can\'t\n           be converted to a string, `NULL\' is returned.  */\n        char *gcry_sexp_nth_string (gcry_sexp_t list, int number);\n\n        /* This function is used to get and convert data from a LIST. This\n           data is assumed to be an MPI stored in the format described by\n           MPIFMT and returned as a standard Libgcrypt MPI.  The caller must\n           release this returned value using `gcry_mpi_release\'.  If there is\n           no data at the given index, the index represents a list or the\n           value can\'t be converted to an MPI, `NULL\' is returned.  */\n        gcry_mpi_t gcry_sexp_nth_mpi (gcry_sexp_t list, int number, int mpifmt);\n\n        /* Convenience fucntion to extract parameters from an S-expression\n         * using a list of single letter parameters.  */\n        gpg_error_t gcry_sexp_extract_param (gcry_sexp_t sexp,\n                                             const char *path,\n                                             const char *list,\n                                             ...);\n        ')
gcrypt_ffi.cdef('\n        /*******************************************\n         *                                         *\n         *  Multi Precision Integer Functions      *\n         *                                         *\n         *******************************************/\n\n        /* Different formats of external big integer representation. */\n        enum gcry_mpi_format\n          {\n            GCRYMPI_FMT_NONE= 0,\n            GCRYMPI_FMT_STD = 1,    /* Twos complement stored without length.  */\n            GCRYMPI_FMT_PGP = 2,    /* As used by OpenPGP (unsigned only).  */\n            GCRYMPI_FMT_SSH = 3,    /* As used by SSH (like STD but with length).  */\n            GCRYMPI_FMT_HEX = 4,    /* Hex format. */\n            GCRYMPI_FMT_USG = 5,    /* Like STD but unsigned. */\n            GCRYMPI_FMT_OPAQUE = 8  /* Opaque format (some functions only).  */\n          };\n\n        /* Flags used for creating big integers.  */\n        enum gcry_mpi_flag\n          {\n            GCRYMPI_FLAG_SECURE = 1,  /* Allocate the number in "secure" memory.  */\n            GCRYMPI_FLAG_OPAQUE = 2,  /* The number is not a real one but just\n                                         a way to store some bytes.  This is\n                                         useful for encrypted big integers.  */\n            GCRYMPI_FLAG_IMMUTABLE = 4, /* Mark the MPI as immutable.  */\n            GCRYMPI_FLAG_CONST     = 8, /* Mark the MPI as a constant.  */\n            GCRYMPI_FLAG_USER1 = 0x0100,/* User flag 1.  */\n            GCRYMPI_FLAG_USER2 = 0x0200,/* User flag 2.  */\n            GCRYMPI_FLAG_USER3 = 0x0400,/* User flag 3.  */\n            GCRYMPI_FLAG_USER4 = 0x0800,/* User flag 4.  */\n          };\n\n\n        /* Allocate a new big integer object, initialize it with 0 and\n           initially allocate memory for a number of at least NBITS. */\n        gcry_mpi_t gcry_mpi_new (unsigned int nbits);\n\n        /* Same as gcry_mpi_new() but allocate in "secure" memory. */\n        gcry_mpi_t gcry_mpi_snew (unsigned int nbits);\n\n        /* Release the number A and free all associated resources. */\n        void gcry_mpi_release (gcry_mpi_t a);\n\n        /* Create a new number with the same value as A. */\n        gcry_mpi_t gcry_mpi_copy (const gcry_mpi_t a);\n\n        /* Store the big integer value U in W and release U.  */\n        void gcry_mpi_snatch (gcry_mpi_t w, gcry_mpi_t u);\n\n        /* Store the big integer value U in W. */\n        gcry_mpi_t gcry_mpi_set (gcry_mpi_t w, const gcry_mpi_t u);\n\n        /* Store the unsigned integer value U in W. */\n        gcry_mpi_t gcry_mpi_set_ui (gcry_mpi_t w, unsigned long u);\n\n        /* Swap the values of A and B. */\n        void gcry_mpi_swap (gcry_mpi_t a, gcry_mpi_t b);\n\n        /* Return 1 if A is negative; 0 if zero or positive.  */\n        int gcry_mpi_is_neg (gcry_mpi_t a);\n\n        /* W = - U */\n        void gcry_mpi_neg (gcry_mpi_t w, gcry_mpi_t u);\n\n        /* W = [W] */\n        void gcry_mpi_abs (gcry_mpi_t w);\n\n        /* Compare the big integer number U and V returning 0 for equality, a\n           positive value for U > V and a negative for U < V. */\n        int gcry_mpi_cmp (const gcry_mpi_t u, const gcry_mpi_t v);\n\n        /* Compare the big integer number U with the unsigned integer V\n           returning 0 for equality, a positive value for U > V and a negative\n           for U < V. */\n        int gcry_mpi_cmp_ui (const gcry_mpi_t u, unsigned long v);\n\n        /* Convert the external representation of an integer stored in BUFFER\n           with a length of BUFLEN into a newly create MPI returned in\n           RET_MPI.  If NSCANNED is not NULL, it will receive the number of\n           bytes actually scanned after a successful operation. */\n        gcry_error_t gcry_mpi_scan (gcry_mpi_t *ret_mpi, enum gcry_mpi_format format,\n                                    const void *buffer, size_t buflen,\n                                    size_t *nscanned);\n\n        /* Convert the big integer A into the external representation\n           described by FORMAT and store it in the provided BUFFER which has\n           been allocated by the user with a size of BUFLEN bytes.  NWRITTEN\n           receives the actual length of the external representation unless it\n           has been passed as NULL. */\n        gcry_error_t gcry_mpi_print (enum gcry_mpi_format format,\n                                     unsigned char *buffer, size_t buflen,\n                                     size_t *nwritten,\n                                     const gcry_mpi_t a);\n\n        /* Convert the big integer A int the external representation described\n           by FORMAT and store it in a newly allocated buffer which address\n           will be put into BUFFER.  NWRITTEN receives the actual lengths of the\n           external representation. */\n        gcry_error_t gcry_mpi_aprint (enum gcry_mpi_format format,\n                                      unsigned char **buffer, size_t *nwritten,\n                                      const gcry_mpi_t a);\n\n        /* Dump the value of A in a format suitable for debugging to\n           Libgcrypt\'s logging stream.  Note that one leading space but no\n           trailing space or linefeed will be printed.  It is okay to pass\n           NULL for A. */\n        void gcry_mpi_dump (const gcry_mpi_t a);\n\n\n        /* W = U + V.  */\n        void gcry_mpi_add (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v);\n\n        /* W = U + V.  V is an unsigned integer. */\n        void gcry_mpi_add_ui (gcry_mpi_t w, gcry_mpi_t u, unsigned long v);\n\n        /* W = U + V mod M. */\n        void gcry_mpi_addm (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v, gcry_mpi_t m);\n\n        /* W = U - V. */\n        void gcry_mpi_sub (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v);\n\n        /* W = U - V.  V is an unsigned integer. */\n        void gcry_mpi_sub_ui (gcry_mpi_t w, gcry_mpi_t u, unsigned long v );\n\n        /* W = U - V mod M */\n        void gcry_mpi_subm (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v, gcry_mpi_t m);\n\n        /* W = U * V. */\n        void gcry_mpi_mul (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v);\n\n        /* W = U * V.  V is an unsigned integer. */\n        void gcry_mpi_mul_ui (gcry_mpi_t w, gcry_mpi_t u, unsigned long v );\n\n        /* W = U * V mod M. */\n        void gcry_mpi_mulm (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v, gcry_mpi_t m);\n\n        /* W = U * (2 ^ CNT). */\n        void gcry_mpi_mul_2exp (gcry_mpi_t w, gcry_mpi_t u, unsigned long cnt);\n\n        /* Q = DIVIDEND / DIVISOR, R = DIVIDEND % DIVISOR,\n           Q or R may be passed as NULL.  ROUND should be negative or 0. */\n        void gcry_mpi_div (gcry_mpi_t q, gcry_mpi_t r,\n                           gcry_mpi_t dividend, gcry_mpi_t divisor, int round);\n\n        /* R = DIVIDEND % DIVISOR */\n        void gcry_mpi_mod (gcry_mpi_t r, gcry_mpi_t dividend, gcry_mpi_t divisor);\n\n        /* W = B ^ E mod M. */\n        void gcry_mpi_powm (gcry_mpi_t w,\n                            const gcry_mpi_t b, const gcry_mpi_t e,\n                            const gcry_mpi_t m);\n\n        /* Set G to the greatest common divisor of A and B.\n           Return true if the G is 1. */\n        int gcry_mpi_gcd (gcry_mpi_t g, gcry_mpi_t a, gcry_mpi_t b);\n\n        /* Set X to the multiplicative inverse of A mod M.\n           Return true if the value exists. */\n        int gcry_mpi_invm (gcry_mpi_t x, gcry_mpi_t a, gcry_mpi_t m);\n\n        /* Create a new point object.  NBITS is usually 0.  */\n        gcry_mpi_point_t gcry_mpi_point_new (unsigned int nbits);\n\n        /* Release the object POINT.  POINT may be NULL. */\n        void gcry_mpi_point_release (gcry_mpi_point_t point);\n\n        /* Store the projective coordinates from POINT into X, Y, and Z.  */\n        void gcry_mpi_point_get (gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_t z,\n                                 gcry_mpi_point_t point);\n\n        /* Store the projective coordinates from POINT into X, Y, and Z and\n           release POINT.  */\n        void gcry_mpi_point_snatch_get (gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_t z,\n                                        gcry_mpi_point_t point);\n\n        /* Store the projective coordinates X, Y, and Z into POINT.  */\n        gcry_mpi_point_t gcry_mpi_point_set (gcry_mpi_point_t point,\n                                             gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_t z);\n\n        /* Store the projective coordinates X, Y, and Z into POINT and release\n           X, Y, and Z.  */\n        gcry_mpi_point_t gcry_mpi_point_snatch_set (gcry_mpi_point_t point,\n                                                    gcry_mpi_t x, gcry_mpi_t y,\n                                                    gcry_mpi_t z);\n\n        /* Allocate a new context for elliptic curve operations based on the\n           parameters given by KEYPARAM or using CURVENAME.  */\n        gpg_error_t gcry_mpi_ec_new (gcry_ctx_t *r_ctx,\n                                     gcry_sexp_t keyparam, const char *curvename);\n\n        /* Get a named MPI from an elliptic curve context.  */\n        gcry_mpi_t gcry_mpi_ec_get_mpi (const char *name, gcry_ctx_t ctx, int copy);\n\n        /* Get a named point from an elliptic curve context.  */\n        gcry_mpi_point_t gcry_mpi_ec_get_point (const char *name,\n                                                gcry_ctx_t ctx, int copy);\n\n        /* Store a named MPI into an elliptic curve context.  */\n        gpg_error_t gcry_mpi_ec_set_mpi (const char *name, gcry_mpi_t newvalue,\n                                         gcry_ctx_t ctx);\n\n        /* Store a named point into an elliptic curve context.  */\n        gpg_error_t gcry_mpi_ec_set_point (const char *name, gcry_mpi_point_t newvalue,\n                                           gcry_ctx_t ctx);\n\n        /* Store the affine coordinates of POINT into X and Y.  */\n        int gcry_mpi_ec_get_affine (gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_point_t point,\n                                    gcry_ctx_t ctx);\n\n        /* W = 2 * U.  */\n        void gcry_mpi_ec_dup (gcry_mpi_point_t w, gcry_mpi_point_t u, gcry_ctx_t ctx);\n\n        /* W = U + V.  */\n        void gcry_mpi_ec_add (gcry_mpi_point_t w,\n                              gcry_mpi_point_t u, gcry_mpi_point_t v, gcry_ctx_t ctx);\n\n        /* W = N * U.  */\n        void gcry_mpi_ec_mul (gcry_mpi_point_t w, gcry_mpi_t n, gcry_mpi_point_t u,\n                              gcry_ctx_t ctx);\n\n        /* Return true if POINT is on the curve described by CTX.  */\n        int gcry_mpi_ec_curve_point (gcry_mpi_point_t w, gcry_ctx_t ctx);\n\n        /* Return the number of bits required to represent A. */\n        unsigned int gcry_mpi_get_nbits (gcry_mpi_t a);\n\n        /* Return true when bit number N (counting from 0) is set in A. */\n        int      gcry_mpi_test_bit (gcry_mpi_t a, unsigned int n);\n\n        /* Set bit number N in A. */\n        void     gcry_mpi_set_bit (gcry_mpi_t a, unsigned int n);\n\n        /* Clear bit number N in A. */\n        void     gcry_mpi_clear_bit (gcry_mpi_t a, unsigned int n);\n\n        /* Set bit number N in A and clear all bits greater than N. */\n        void     gcry_mpi_set_highbit (gcry_mpi_t a, unsigned int n);\n\n        /* Clear bit number N in A and all bits greater than N. */\n        void     gcry_mpi_clear_highbit (gcry_mpi_t a, unsigned int n);\n\n        /* Shift the value of A by N bits to the right and store the result in X. */\n        void     gcry_mpi_rshift (gcry_mpi_t x, gcry_mpi_t a, unsigned int n);\n\n        /* Shift the value of A by N bits to the left and store the result in X. */\n        void     gcry_mpi_lshift (gcry_mpi_t x, gcry_mpi_t a, unsigned int n);\n\n        /* Store NBITS of the value P points to in A and mark A as an opaque\n           value.  On success A received the the ownership of the value P.\n           WARNING: Never use an opaque MPI for anything thing else than\n           gcry_mpi_release, gcry_mpi_get_opaque. */\n        gcry_mpi_t gcry_mpi_set_opaque (gcry_mpi_t a, void *p, unsigned int nbits);\n\n        /* Store NBITS of the value P points to in A and mark A as an opaque\n           value.  The function takes a copy of the provided value P.\n           WARNING: Never use an opaque MPI for anything thing else than\n           gcry_mpi_release, gcry_mpi_get_opaque. */\n        gcry_mpi_t gcry_mpi_set_opaque_copy (gcry_mpi_t a,\n                                             const void *p, unsigned int nbits);\n\n        /* Return a pointer to an opaque value stored in A and return its size\n           in NBITS.  Note that the returned pointer is still owned by A and\n           that the function should never be used for an non-opaque MPI. */\n        void *gcry_mpi_get_opaque (gcry_mpi_t a, unsigned int *nbits);\n\n        /* Set the FLAG for the big integer A.  Currently only the flag\n           GCRYMPI_FLAG_SECURE is allowed to convert A into an big intger\n           stored in "secure" memory. */\n        void gcry_mpi_set_flag (gcry_mpi_t a, enum gcry_mpi_flag flag);\n\n        /* Clear FLAG for the big integer A.  Note that this function is\n           currently useless as no flags are allowed. */\n        void gcry_mpi_clear_flag (gcry_mpi_t a, enum gcry_mpi_flag flag);\n\n        /* Return true if the FLAG is set for A. */\n        int gcry_mpi_get_flag (gcry_mpi_t a, enum gcry_mpi_flag flag);\n\n        /* Private function - do not use.  */\n        gcry_mpi_t _gcry_mpi_get_const (int no);\n        ')
gcrypt_ffi.cdef('\n        /************************************\n         *                                  *\n         *   Symmetric Cipher Functions     *\n         *                                  *\n         ************************************/\n\n        /* The data object used to hold a handle to an encryption object.  */\n        struct gcry_cipher_handle;\n        typedef struct gcry_cipher_handle *gcry_cipher_hd_t;\n\n        /* All symmetric encryption algorithms are identified by their IDs.\n           More IDs may be registered at runtime. */\n        enum gcry_cipher_algos\n          {\n            GCRY_CIPHER_NONE        = 0,\n            GCRY_CIPHER_IDEA        = 1,\n            GCRY_CIPHER_3DES        = 2,\n            GCRY_CIPHER_CAST5       = 3,\n            GCRY_CIPHER_BLOWFISH    = 4,\n            GCRY_CIPHER_SAFER_SK128 = 5,\n            GCRY_CIPHER_DES_SK      = 6,\n            GCRY_CIPHER_AES         = 7,\n            GCRY_CIPHER_AES192      = 8,\n            GCRY_CIPHER_AES256      = 9,\n            GCRY_CIPHER_TWOFISH     = 10,\n\n            /* Other cipher numbers are above 300 for OpenPGP reasons. */\n            GCRY_CIPHER_ARCFOUR     = 301,  /* Fully compatible with RSA\'s RC4 (tm). */\n            GCRY_CIPHER_DES         = 302,  /* Yes, this is single key 56 bit DES. */\n            GCRY_CIPHER_TWOFISH128  = 303,\n            GCRY_CIPHER_SERPENT128  = 304,\n            GCRY_CIPHER_SERPENT192  = 305,\n            GCRY_CIPHER_SERPENT256  = 306,\n            GCRY_CIPHER_RFC2268_40  = 307,  /* Ron\'s Cipher 2 (40 bit). */\n            GCRY_CIPHER_RFC2268_128 = 308,  /* Ron\'s Cipher 2 (128 bit). */\n            GCRY_CIPHER_SEED        = 309,  /* 128 bit cipher described in RFC4269. */\n            GCRY_CIPHER_CAMELLIA128 = 310,\n            GCRY_CIPHER_CAMELLIA192 = 311,\n            GCRY_CIPHER_CAMELLIA256 = 312,\n            GCRY_CIPHER_SALSA20     = 313,\n            GCRY_CIPHER_SALSA20R12  = 314,\n            GCRY_CIPHER_GOST28147   = 315\n          };\n\n        /* The supported encryption modes.  Note that not all of them are\n           supported for each algorithm. */\n        enum gcry_cipher_modes\n          {\n            GCRY_CIPHER_MODE_NONE   = 0,  /* Not yet specified. */\n            GCRY_CIPHER_MODE_ECB    = 1,  /* Electronic codebook. */\n            GCRY_CIPHER_MODE_CFB    = 2,  /* Cipher feedback. */\n            GCRY_CIPHER_MODE_CBC    = 3,  /* Cipher block chaining. */\n            GCRY_CIPHER_MODE_STREAM = 4,  /* Used with stream ciphers. */\n            GCRY_CIPHER_MODE_OFB    = 5,  /* Outer feedback. */\n            GCRY_CIPHER_MODE_CTR    = 6,  /* Counter. */\n            GCRY_CIPHER_MODE_AESWRAP= 7,  /* AES-WRAP algorithm.  */\n            GCRY_CIPHER_MODE_CCM    = 8,  /* Counter with CBC-MAC.  */\n            GCRY_CIPHER_MODE_GCM    = 9   /* Galois Counter Mode. */\n          };\n\n        /* Flags used with the open function. */\n        enum gcry_cipher_flags\n          {\n            GCRY_CIPHER_SECURE      = 1,  /* Allocate in secure memory. */\n            GCRY_CIPHER_ENABLE_SYNC = 2,  /* Enable CFB sync mode. */\n            GCRY_CIPHER_CBC_CTS     = 4,  /* Enable CBC cipher text stealing (CTS). */\n            GCRY_CIPHER_CBC_MAC     = 8   /* Enable CBC message auth. code (MAC). */\n          };\n\n        /* Create a handle for algorithm ALGO to be used in MODE.  FLAGS may\n           be given as an bitwise OR of the gcry_cipher_flags values. */\n        gcry_error_t gcry_cipher_open (gcry_cipher_hd_t *handle,\n                                      int algo, int mode, unsigned int flags);\n\n        /* Close the cioher handle H and release all resource. */\n        void gcry_cipher_close (gcry_cipher_hd_t h);\n\n        /* Perform various operations on the cipher object H. */\n        gcry_error_t gcry_cipher_ctl (gcry_cipher_hd_t h, int cmd, void *buffer,\n                                     size_t buflen);\n\n        /* Retrieve various information about the cipher object H. */\n        gcry_error_t gcry_cipher_info (gcry_cipher_hd_t h, int what, void *buffer,\n                                      size_t *nbytes);\n\n        /* Retrieve various information about the cipher algorithm ALGO. */\n        gcry_error_t gcry_cipher_algo_info (int algo, int what, void *buffer,\n                                           size_t *nbytes);\n\n        /* Map the cipher algorithm whose ID is contained in ALGORITHM to a\n           string representation of the algorithm name.  For unknown algorithm\n           IDs this function returns "?".  */\n        const char *gcry_cipher_algo_name (int algorithm);\n\n        /* Map the algorithm name NAME to an cipher algorithm ID.  Return 0 if\n           the algorithm name is not known. */\n        int gcry_cipher_map_name (const char *name);\n\n        /* Given an ASN.1 object identifier in standard IETF dotted decimal\n           format in STRING, return the encryption mode associated with that\n           OID or 0 if not known or applicable. */\n        int gcry_cipher_mode_from_oid (const char *string);\n\n        /* Encrypt the plaintext of size INLEN in IN using the cipher handle H\n           into the buffer OUT which has an allocated length of OUTSIZE.  For\n           most algorithms it is possible to pass NULL for in and 0 for INLEN\n           and do a in-place decryption of the data provided in OUT.  */\n        gcry_error_t gcry_cipher_encrypt (gcry_cipher_hd_t h,\n                                          void *out, size_t outsize,\n                                          const void *in, size_t inlen);\n\n        /* The counterpart to gcry_cipher_encrypt.  */\n        gcry_error_t gcry_cipher_decrypt (gcry_cipher_hd_t h,\n                                          void *out, size_t outsize,\n                                          const void *in, size_t inlen);\n\n        /* Set KEY of length KEYLEN bytes for the cipher handle HD.  */\n        gcry_error_t gcry_cipher_setkey (gcry_cipher_hd_t hd,\n                                         const void *key, size_t keylen);\n\n\n        /* Set initialization vector IV of length IVLEN for the cipher handle HD. */\n        gcry_error_t gcry_cipher_setiv (gcry_cipher_hd_t hd,\n                                        const void *iv, size_t ivlen);\n\n        /* Provide additional authentication data for AEAD modes/ciphers.  */\n        gcry_error_t gcry_cipher_authenticate (gcry_cipher_hd_t hd, const void *abuf,\n                                               size_t abuflen);\n\n        /* Get authentication tag for AEAD modes/ciphers.  */\n        gcry_error_t gcry_cipher_gettag (gcry_cipher_hd_t hd, void *outtag,\n                                         size_t taglen);\n\n        /* Check authentication tag for AEAD modes/ciphers.  */\n        gcry_error_t gcry_cipher_checktag (gcry_cipher_hd_t hd, const void *intag,\n                                           size_t taglen);\n\n        /* Set counter for CTR mode.  (CTR,CTRLEN) must denote a buffer of\n           block size length, or (NULL,0) to set the CTR to the all-zero block. */\n        gpg_error_t gcry_cipher_setctr (gcry_cipher_hd_t hd,\n                                        const void *ctr, size_t ctrlen);\n\n        /* Retrieve the key length in bytes used with algorithm A. */\n        size_t gcry_cipher_get_algo_keylen (int algo);\n\n        /* Retrieve the block length in bytes used with algorithm A. */\n        size_t gcry_cipher_get_algo_blklen (int algo);\n        ')
gcrypt_ffi.cdef('\n        /************************************\n         *                                  *\n         *    Asymmetric Cipher Functions   *\n         *                                  *\n         ************************************/\n\n        /* The algorithms and their IDs we support.  */\n        enum gcry_pk_algos\n          {\n            GCRY_PK_RSA   = 1,      /* RSA */\n            GCRY_PK_RSA_E = 2,      /* (deprecated: use 1).  */\n            GCRY_PK_RSA_S = 3,      /* (deprecated: use 1).  */\n            GCRY_PK_ELG_E = 16,     /* (deprecated: use 20). */\n            GCRY_PK_DSA   = 17,     /* Digital Signature Algorithm.  */\n            GCRY_PK_ECC   = 18,     /* Generic ECC.  */\n            GCRY_PK_ELG   = 20,     /* Elgamal       */\n            GCRY_PK_ECDSA = 301,    /* (deprecated: use 18).  */\n            GCRY_PK_ECDH  = 302     /* (deprecated: use 18).  */\n          };\n\n        /* Encrypt the DATA using the public key PKEY and store the result as\n           a newly created S-expression at RESULT. */\n        gcry_error_t gcry_pk_encrypt (gcry_sexp_t *result,\n                                      gcry_sexp_t data, gcry_sexp_t pkey);\n\n        /* Decrypt the DATA using the private key SKEY and store the result as\n           a newly created S-expression at RESULT. */\n        gcry_error_t gcry_pk_decrypt (gcry_sexp_t *result,\n                                      gcry_sexp_t data, gcry_sexp_t skey);\n\n        /* Sign the DATA using the private key SKEY and store the result as\n           a newly created S-expression at RESULT. */\n        gcry_error_t gcry_pk_sign (gcry_sexp_t *result,\n                                   gcry_sexp_t data, gcry_sexp_t skey);\n\n        /* Check the signature SIGVAL on DATA using the public key PKEY. */\n        gcry_error_t gcry_pk_verify (gcry_sexp_t sigval,\n                                     gcry_sexp_t data, gcry_sexp_t pkey);\n\n        /* Check that private KEY is sane. */\n        gcry_error_t gcry_pk_testkey (gcry_sexp_t key);\n\n        /* Generate a new key pair according to the parameters given in\n           S_PARMS.  The new key pair is returned in as an S-expression in\n           R_KEY. */\n        gcry_error_t gcry_pk_genkey (gcry_sexp_t *r_key, gcry_sexp_t s_parms);\n\n        /* Catch all function for miscellaneous operations. */\n        gcry_error_t gcry_pk_ctl (int cmd, void *buffer, size_t buflen);\n\n        /* Retrieve information about the public key algorithm ALGO. */\n        gcry_error_t gcry_pk_algo_info (int algo, int what,\n                                        void *buffer, size_t *nbytes);\n\n        /* Map the public key algorithm whose ID is contained in ALGORITHM to\n           a string representation of the algorithm name.  For unknown\n           algorithm IDs this functions returns "?". */\n        const char *gcry_pk_algo_name (int algorithm);\n\n        /* Map the algorithm NAME to a public key algorithm Id.  Return 0 if\n           the algorithm name is not known. */\n        int gcry_pk_map_name (const char* name);\n\n        /* Return what is commonly referred as the key length for the given\n           public or private KEY.  */\n        unsigned int gcry_pk_get_nbits (gcry_sexp_t key);\n\n        /* Return the so called KEYGRIP which is the SHA-1 hash of the public\n           key parameters expressed in a way depending on the algorithm.  */\n        unsigned char *gcry_pk_get_keygrip (gcry_sexp_t key, unsigned char *array);\n\n        /* Return the name of the curve matching KEY.  */\n        const char *gcry_pk_get_curve (gcry_sexp_t key, int iterator,\n                                       unsigned int *r_nbits);\n\n        /* Return an S-expression with the parameters of the named ECC curve\n           NAME.  ALGO must be set to an ECC algorithm.  */\n        gcry_sexp_t gcry_pk_get_param (int algo, const char *name);\n\n        /* Return an S-expression representing the context CTX.  */\n        gcry_error_t gcry_pubkey_get_sexp (gcry_sexp_t *r_sexp,\n                                           int mode, gcry_ctx_t ctx);\n        ')
gcrypt_ffi.cdef('\n        /************************************\n         *                                  *\n         *   Cryptograhic Hash Functions    *\n         *                                  *\n         ************************************/\n\n        /* Algorithm IDs for the hash functions we know about. Not all of them\n           are implemnted. */\n        enum gcry_md_algos\n          {\n            GCRY_MD_NONE    = 0,\n            GCRY_MD_MD5     = 1,\n            GCRY_MD_SHA1    = 2,\n            GCRY_MD_RMD160  = 3,\n            GCRY_MD_MD2     = 5,\n            GCRY_MD_TIGER   = 6,   /* TIGER/192 as used by gpg <= 1.3.2. */\n            GCRY_MD_HAVAL   = 7,   /* HAVAL, 5 pass, 160 bit. */\n            GCRY_MD_SHA256  = 8,\n            GCRY_MD_SHA384  = 9,\n            GCRY_MD_SHA512  = 10,\n            GCRY_MD_SHA224  = 11,\n            GCRY_MD_MD4     = 301,\n            GCRY_MD_CRC32         = 302,\n            GCRY_MD_CRC32_RFC1510 = 303,\n            GCRY_MD_CRC24_RFC2440 = 304,\n            GCRY_MD_WHIRLPOOL     = 305,\n            GCRY_MD_TIGER1        = 306, /* TIGER fixed.  */\n            GCRY_MD_TIGER2        = 307, /* TIGER2 variant.   */\n            GCRY_MD_GOSTR3411_94  = 308, /* GOST R 34.11-94.  */\n            GCRY_MD_STRIBOG256    = 309, /* GOST R 34.11-2012, 256 bit.  */\n            GCRY_MD_STRIBOG512    = 310  /* GOST R 34.11-2012, 512 bit.  */\n          };\n\n        /* Flags used with the open function.  */\n        enum gcry_md_flags\n          {\n            GCRY_MD_FLAG_SECURE = 1,  /* Allocate all buffers in "secure" memory.  */\n            GCRY_MD_FLAG_HMAC   = 2,  /* Make an HMAC out of this algorithm.  */\n            GCRY_MD_FLAG_BUGEMU1 = 0x0100\n          };\n\n        /* (Forward declaration.)  */\n        struct gcry_md_context;\n\n        /* This object is used to hold a handle to a message digest object.\n           This structure is private - only to be used by the public gcry_md_*\n           macros.  */\n        typedef struct gcry_md_handle\n        {\n          /* Actual context.  */\n          struct gcry_md_context *ctx;\n\n          /* Buffer management.  */\n          int  bufpos;\n          int  bufsize;\n          unsigned char buf[1];\n        } *gcry_md_hd_t;\n\n        /* Create a message digest object for algorithm ALGO.  FLAGS may be\n           given as an bitwise OR of the gcry_md_flags values.  ALGO may be\n           given as 0 if the algorithms to be used are later set using\n           gcry_md_enable.  */\n        gcry_error_t gcry_md_open (gcry_md_hd_t *h, int algo, unsigned int flags);\n\n        /* Release the message digest object HD.  */\n        void gcry_md_close (gcry_md_hd_t hd);\n\n        /* Add the message digest algorithm ALGO to the digest object HD.  */\n        gcry_error_t gcry_md_enable (gcry_md_hd_t hd, int algo);\n\n        /* Create a new digest object as an exact copy of the object HD.  */\n        gcry_error_t gcry_md_copy (gcry_md_hd_t *bhd, gcry_md_hd_t ahd);\n\n        /* Reset the digest object HD to its initial state.  */\n        void gcry_md_reset (gcry_md_hd_t hd);\n\n        /* Perform various operations on the digest object HD. */\n        gcry_error_t gcry_md_ctl (gcry_md_hd_t hd, int cmd,\n                                  void *buffer, size_t buflen);\n\n        /* Pass LENGTH bytes of data in BUFFER to the digest object HD so that\n           it can update the digest values.  This is the actual hash\n           function. */\n        void gcry_md_write (gcry_md_hd_t hd, const void *buffer, size_t length);\n\n        /* Read out the final digest from HD return the digest value for\n           algorithm ALGO. */\n        unsigned char *gcry_md_read (gcry_md_hd_t hd, int algo);\n\n        /* Convenience function to calculate the hash from the data in BUFFER\n           of size LENGTH using the algorithm ALGO avoiding the creating of a\n           hash object.  The hash is returned in the caller provided buffer\n           DIGEST which must be large enough to hold the digest of the given\n           algorithm. */\n        void gcry_md_hash_buffer (int algo, void *digest,\n                                  const void *buffer, size_t length);\n\n        /* Convenience function to hash multiple buffers.  */\n        gpg_error_t gcry_md_hash_buffers (int algo, unsigned int flags, void *digest,\n                                          const gcry_buffer_t *iov, int iovcnt);\n\n        /* Retrieve the algorithm used with HD.  This does not work reliable\n           if more than one algorithm is enabled in HD. */\n        int gcry_md_get_algo (gcry_md_hd_t hd);\n\n        /* Retrieve the length in bytes of the digest yielded by algorithm\n           ALGO. */\n        unsigned int gcry_md_get_algo_dlen (int algo);\n\n        /* Return true if the the algorithm ALGO is enabled in the digest\n           object A. */\n        int gcry_md_is_enabled (gcry_md_hd_t a, int algo);\n\n        /* Return true if the digest object A is allocated in "secure" memory. */\n        int gcry_md_is_secure (gcry_md_hd_t a);\n\n        /* Retrieve various information about the object H.  */\n        gcry_error_t gcry_md_info (gcry_md_hd_t h, int what, void *buffer,\n                                  size_t *nbytes);\n\n        /* Retrieve various information about the algorithm ALGO.  */\n        gcry_error_t gcry_md_algo_info (int algo, int what, void *buffer,\n                                       size_t *nbytes);\n\n        /* Map the digest algorithm id ALGO to a string representation of the\n           algorithm name.  For unknown algorithms this function returns\n           "?". */\n        const char *gcry_md_algo_name (int algo);\n\n        /* Map the algorithm NAME to a digest algorithm Id.  Return 0 if\n           the algorithm name is not known. */\n        int gcry_md_map_name (const char* name);\n\n        /* For use with the HMAC feature, the set MAC key to the KEY of\n           KEYLEN bytes. */\n        gcry_error_t gcry_md_setkey (gcry_md_hd_t hd, const void *key, size_t keylen);\n\n        /* Start or stop debugging for digest handle HD; i.e. create a file\n           named dbgmd-<n>.<suffix> while hashing.  If SUFFIX is NULL,\n           debugging stops and the file will be closed. */\n        void gcry_md_debug (gcry_md_hd_t hd, const char *suffix);\n        ')
gcrypt_ffi.cdef('\n        /**********************************************\n         *                                            *\n         *   Message Authentication Code Functions    *\n         *                                            *\n         **********************************************/\n\n        /* The data object used to hold a handle to an encryption object.  */\n        struct gcry_mac_handle;\n        typedef struct gcry_mac_handle *gcry_mac_hd_t;\n\n        /* Algorithm IDs for the hash functions we know about. Not all of them\n           are implemented. */\n        enum gcry_mac_algos\n          {\n            GCRY_MAC_NONE               = 0,\n\n            GCRY_MAC_HMAC_SHA256        = 101,\n            GCRY_MAC_HMAC_SHA224        = 102,\n            GCRY_MAC_HMAC_SHA512        = 103,\n            GCRY_MAC_HMAC_SHA384        = 104,\n            GCRY_MAC_HMAC_SHA1          = 105,\n            GCRY_MAC_HMAC_MD5           = 106,\n            GCRY_MAC_HMAC_MD4           = 107,\n            GCRY_MAC_HMAC_RMD160        = 108,\n            GCRY_MAC_HMAC_TIGER1        = 109, /* The fixed TIGER variant */\n            GCRY_MAC_HMAC_WHIRLPOOL     = 110,\n            GCRY_MAC_HMAC_GOSTR3411_94  = 111,\n            GCRY_MAC_HMAC_STRIBOG256    = 112,\n            GCRY_MAC_HMAC_STRIBOG512    = 113,\n\n            GCRY_MAC_CMAC_AES           = 201,\n            GCRY_MAC_CMAC_3DES          = 202,\n            GCRY_MAC_CMAC_CAMELLIA      = 203,\n            GCRY_MAC_CMAC_CAST5         = 204,\n            GCRY_MAC_CMAC_BLOWFISH      = 205,\n            GCRY_MAC_CMAC_TWOFISH       = 206,\n            GCRY_MAC_CMAC_SERPENT       = 207,\n            GCRY_MAC_CMAC_SEED          = 208,\n            GCRY_MAC_CMAC_RFC2268       = 209,\n            GCRY_MAC_CMAC_IDEA          = 210,\n            GCRY_MAC_CMAC_GOST28147     = 211,\n\n            GCRY_MAC_GMAC_AES           = 401,\n            GCRY_MAC_GMAC_CAMELLIA      = 402,\n            GCRY_MAC_GMAC_TWOFISH       = 403,\n            GCRY_MAC_GMAC_SERPENT       = 404,\n            GCRY_MAC_GMAC_SEED          = 405\n          };\n\n        /* Flags used with the open function.  */\n        enum gcry_mac_flags\n          {\n            GCRY_MAC_FLAG_SECURE = 1,  /* Allocate all buffers in "secure" memory.  */\n          };\n\n        /* Create a MAC handle for algorithm ALGO.  FLAGS may be given as an bitwise OR\n           of the gcry_mac_flags values.  CTX maybe NULL or gcry_ctx_t object to be\n           associated with HANDLE.  */\n        gcry_error_t gcry_mac_open (gcry_mac_hd_t *handle, int algo,\n                                    unsigned int flags, gcry_ctx_t ctx);\n\n        /* Close the MAC handle H and release all resource. */\n        void gcry_mac_close (gcry_mac_hd_t h);\n\n        /* Perform various operations on the MAC object H. */\n        gcry_error_t gcry_mac_ctl (gcry_mac_hd_t h, int cmd, void *buffer,\n                                   size_t buflen);\n\n        /* Retrieve various information about the MAC algorithm ALGO. */\n        gcry_error_t gcry_mac_algo_info (int algo, int what, void *buffer,\n                                         size_t *nbytes);\n\n        /* Set KEY of length KEYLEN bytes for the MAC handle HD.  */\n        gcry_error_t gcry_mac_setkey (gcry_mac_hd_t hd, const void *key,\n                                      size_t keylen);\n\n        /* Set initialization vector IV of length IVLEN for the MAC handle HD. */\n        gcry_error_t gcry_mac_setiv (gcry_mac_hd_t hd, const void *iv,\n                                     size_t ivlen);\n\n        /* Pass LENGTH bytes of data in BUFFER to the MAC object HD so that\n           it can update the MAC values.  */\n        gcry_error_t gcry_mac_write (gcry_mac_hd_t hd, const void *buffer,\n                                     size_t length);\n\n        /* Read out the final authentication code from the MAC object HD to BUFFER. */\n        gcry_error_t gcry_mac_read (gcry_mac_hd_t hd, void *buffer, size_t *buflen);\n\n        /* Verify the final authentication code from the MAC object HD with BUFFER. */\n        gcry_error_t gcry_mac_verify (gcry_mac_hd_t hd, const void *buffer,\n                                      size_t buflen);\n\n        /* Retrieve the length in bytes of the MAC yielded by algorithm ALGO. */\n        unsigned int gcry_mac_get_algo_maclen (int algo);\n\n        /* Retrieve the default key length in bytes used with algorithm A. */\n        unsigned int gcry_mac_get_algo_keylen (int algo);\n\n        /* Map the MAC algorithm whose ID is contained in ALGORITHM to a\n           string representation of the algorithm name.  For unknown algorithm\n           IDs this function returns "?".  */\n        const char *gcry_mac_algo_name (int algorithm);\n\n        /* Map the algorithm name NAME to an MAC algorithm ID.  Return 0 if\n           the algorithm name is not known. */\n        int gcry_mac_map_name (const char *name);\n        ')
gcrypt_ffi.cdef('\n        /******************************\n         *                            *\n         *  Key Derivation Functions  *\n         *                            *\n         ******************************/\n\n        /* Algorithm IDs for the KDFs.  */\n        enum gcry_kdf_algos\n          {\n            GCRY_KDF_NONE = 0,\n            GCRY_KDF_SIMPLE_S2K = 16,\n            GCRY_KDF_SALTED_S2K = 17,\n            GCRY_KDF_ITERSALTED_S2K = 19,\n            GCRY_KDF_PBKDF1 = 33,\n            GCRY_KDF_PBKDF2 = 34,\n            GCRY_KDF_SCRYPT = 48\n          };\n\n        /* Derive a key from a passphrase.  */\n        gpg_error_t gcry_kdf_derive (const void *passphrase, size_t passphraselen,\n                                     int algo, int subalgo,\n                                     const void *salt, size_t saltlen,\n                                     unsigned long iterations,\n                                     size_t keysize, void *keybuffer);\n        ')
gcrypt_ffi.cdef('\n        /************************************\n         *                                  *\n         *   Random Generating Functions    *\n         *                                  *\n         ************************************/\n\n        /* The type of the random number generator.  */\n        enum gcry_rng_types\n          {\n            GCRY_RNG_TYPE_STANDARD   = 1, /* The default CSPRNG generator.  */\n            GCRY_RNG_TYPE_FIPS       = 2, /* The FIPS X9.31 AES generator.  */\n            GCRY_RNG_TYPE_SYSTEM     = 3  /* The system\'s native generator. */\n          };\n\n        /* The possible values for the random quality.  The rule of thumb is\n           to use STRONG for session keys and VERY_STRONG for key material.\n           WEAK is usually an alias for STRONG and should not be used anymore\n           (except with gcry_mpi_randomize); use gcry_create_nonce instead. */\n        typedef enum gcry_random_level\n          {\n            GCRY_WEAK_RANDOM = 0,\n            GCRY_STRONG_RANDOM = 1,\n            GCRY_VERY_STRONG_RANDOM = 2\n          }\n        gcry_random_level_t;\n\n        /* Fill BUFFER with LENGTH bytes of random, using random numbers of\n           quality LEVEL. */\n        void gcry_randomize (void *buffer, size_t length,\n                             enum gcry_random_level level);\n\n        /* Add the external random from BUFFER with LENGTH bytes into the\n           pool. QUALITY should either be -1 for unknown or in the range of 0\n           to 100 */\n        gcry_error_t gcry_random_add_bytes (const void *buffer, size_t length,\n                                            int quality);\n\n        /* Return NBYTES of allocated random using a random numbers of quality\n           LEVEL. */\n        void *gcry_random_bytes (size_t nbytes, enum gcry_random_level level)\n                                ;\n\n        /* Return NBYTES of allocated random using a random numbers of quality\n           LEVEL.  The random numbers are created returned in "secure"\n           memory. */\n        void *gcry_random_bytes_secure (size_t nbytes, enum gcry_random_level level)\n                                       ;\n\n\n        /* Set the big integer W to a random value of NBITS using a random\n           generator with quality LEVEL.  Note that by using a level of\n           GCRY_WEAK_RANDOM gcry_create_nonce is used internally. */\n        void gcry_mpi_randomize (gcry_mpi_t w,\n                                 unsigned int nbits, enum gcry_random_level level);\n\n\n        /* Create an unpredicable nonce of LENGTH bytes in BUFFER. */\n        void gcry_create_nonce (void *buffer, size_t length);\n        ')
gcrypt_ffi.cdef('\n        /*******************************/\n        /*                             */\n        /*    Prime Number Functions   */\n        /*                             */\n        /*******************************/\n\n        /* The function should return 1 if the operation shall continue, 0 to\n           reject the prime candidate. */\n        typedef int (*gcry_prime_check_func_t) (void *arg, int mode,\n                                                gcry_mpi_t candidate);\n\n        /* Flags for gcry_prime_generate():  */\n\n        /* Generate a new prime number of PRIME_BITS bits and store it in\n           PRIME.  If FACTOR_BITS is non-zero, one of the prime factors of\n           (prime - 1) / 2 must be FACTOR_BITS bits long.  If FACTORS is\n           non-zero, allocate a new, NULL-terminated array holding the prime\n           factors and store it in FACTORS.  FLAGS might be used to influence\n           the prime number generation process.  */\n        gcry_error_t gcry_prime_generate (gcry_mpi_t *prime,\n                                          unsigned int prime_bits,\n                                          unsigned int factor_bits,\n                                          gcry_mpi_t **factors,\n                                          gcry_prime_check_func_t cb_func,\n                                          void *cb_arg,\n                                          gcry_random_level_t random_level,\n                                          unsigned int flags);\n\n        /* Find a generator for PRIME where the factorization of (prime-1) is\n           in the NULL terminated array FACTORS. Return the generator as a\n           newly allocated MPI in R_G.  If START_G is not NULL, use this as\n           teh start for the search. */\n        gcry_error_t gcry_prime_group_generator (gcry_mpi_t *r_g,\n                                                 gcry_mpi_t prime,\n                                                 gcry_mpi_t *factors,\n                                                 gcry_mpi_t start_g);\n\n\n        /* Convenience function to release the FACTORS array. */\n        void gcry_prime_release_factors (gcry_mpi_t *factors);\n\n\n        /* Check wether the number X is prime.  */\n        gcry_error_t gcry_prime_check (gcry_mpi_t x, unsigned int flags);\n        ')
gcrypt_ffi.cdef('\n        /************************************\n         *                                  *\n         *     Miscellaneous Stuff          *\n         *                                  *\n         ************************************/\n\n        /* Release the context object CTX.  */\n        void gcry_ctx_release (gcry_ctx_t ctx);\n\n        /* Log data using Libgcrypt\'s own log interface.  */\n        void gcry_log_debug (const char *fmt, ...);\n        void gcry_log_debughex (const char *text, const void *buffer, size_t length);\n        void gcry_log_debugmpi (const char *text, gcry_mpi_t mpi);\n        void gcry_log_debugpnt (const char *text,\n                                gcry_mpi_point_t point, gcry_ctx_t ctx);\n        void gcry_log_debugsxp (const char *text, gcry_sexp_t sexp);\n\n\n        /* Log levels used by the internal logging facility. */\n        enum gcry_log_levels\n          {\n            GCRY_LOG_CONT   = 0,    /* (Continue the last log line.) */\n            GCRY_LOG_INFO   = 10,\n            GCRY_LOG_WARN   = 20,\n            GCRY_LOG_ERROR  = 30,\n            GCRY_LOG_FATAL  = 40,\n            GCRY_LOG_BUG    = 50,\n            GCRY_LOG_DEBUG  = 100\n          };\n\n        /* Type for progress handlers.  */\n        typedef void (*gcry_handler_progress_t) (void *, const char *, int, int, int);\n\n        /* Type for memory allocation handlers.  */\n        typedef void *(*gcry_handler_alloc_t) (size_t n);\n\n        /* Type for secure memory check handlers.  */\n        typedef int (*gcry_handler_secure_check_t) (const void *);\n\n        /* Type for memory reallocation handlers.  */\n        typedef void *(*gcry_handler_realloc_t) (void *p, size_t n);\n\n        /* Type for memory free handlers.  */\n        typedef void (*gcry_handler_free_t) (void *);\n\n        /* Type for out-of-memory handlers.  */\n        typedef int (*gcry_handler_no_mem_t) (void *, size_t, unsigned int);\n\n        /* Type for fatal error handlers.  */\n        typedef void (*gcry_handler_error_t) (void *, int, const char *);\n\n        /* Type for logging handlers.  */\n        typedef void (*gcry_handler_log_t) (void *, int, const char *, ...);\n\n        /* Certain operations can provide progress information.  This function\n           is used to register a handler for retrieving these information. */\n        void gcry_set_progress_handler (gcry_handler_progress_t cb, void *cb_data);\n\n\n        /* Register a custom memory allocation functions. */\n        void gcry_set_allocation_handler (\n                                     gcry_handler_alloc_t func_alloc,\n                                     gcry_handler_alloc_t func_alloc_secure,\n                                     gcry_handler_secure_check_t func_secure_check,\n                                     gcry_handler_realloc_t func_realloc,\n                                     gcry_handler_free_t func_free);\n\n        /* Register a function used instead of the internal out of memory\n           handler. */\n        void gcry_set_outofcore_handler (gcry_handler_no_mem_t h, void *opaque);\n\n        /* Register a function used instead of the internal fatal error\n           handler. */\n        void gcry_set_fatalerror_handler (gcry_handler_error_t fnc, void *opaque);\n\n        /* Register a function used instead of the internal logging\n           facility. */\n        void gcry_set_log_handler (gcry_handler_log_t f, void *opaque);\n\n        /* Reserved for future use. */\n        void gcry_set_gettext_handler (const char *(*f)(const char*));\n\n        /* Libgcrypt uses its own memory allocation.  It is important to use\n           gcry_free () to release memory allocated by libgcrypt. */\n        void *gcry_malloc (size_t n);\n        void *gcry_calloc (size_t n, size_t m);\n        void *gcry_malloc_secure (size_t n);\n        void *gcry_calloc_secure (size_t n, size_t m);\n        void *gcry_realloc (void *a, size_t n);\n        char *gcry_strdup (const char *string);\n        void *gcry_xmalloc (size_t n);\n        void *gcry_xcalloc (size_t n, size_t m);\n        void *gcry_xmalloc_secure (size_t n);\n        void *gcry_xcalloc_secure (size_t n, size_t m);\n        void *gcry_xrealloc (void *a, size_t n);\n        char *gcry_xstrdup (const char * a);\n        void  gcry_free (void *a);\n\n        /* Return true if A is allocated in "secure" memory. */\n        int gcry_is_secure (const void *a);\n        ')
gcrypt_ffi.compile()
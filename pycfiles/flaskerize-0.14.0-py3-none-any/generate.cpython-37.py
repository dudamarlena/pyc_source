# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /Users/apryor/projects/flaskerize/flaskerize/generate.py
# Compiled at: 2020-01-22 12:12:28
# Size of source mod 2**32: 7423 bytes
from typing import Callable, Dict
HEADER = '# DO NOT EDIT THIS FILE. It is generated by flaskerize and may be\n# overwritten'

def _generate(contents, output_name: str, filename: str=None, mode: str='w', dry_run: bool=False) -> None:
    if dry_run:
        print(contents)
    else:
        if filename is None:
            filename = f"{output_name.replace('.py', '')}.py"
        with open(filename, mode) as (fid):
            fid.write(contents)
    if filename:
        print(f"Successfully created {filename}")


def hello_world(args) -> None:
    print('Generating a hello_world app')
    CONTENTS = f"{HEADER}\n\nimport os\nfrom flask import Flask, send_from_directory\n\ndef create_app():\n    app = Flask(__name__)\n\n    # Serve React App\n    @app.route('/')\n    def serve():\n        return 'Hello, Flaskerize!'\n    return app\n\nif __name__ == '__main__':\n    app = create_app()\n    app.run()\n\n    "
    _generate(CONTENTS,
      output_name=(args.output_name),
      filename=(args.output_file),
      dry_run=(args.dry_run))
    print('Successfully created new app')


def app_from_dir(args) -> None:
    """
    Serve files using `send_from_directory`. Note this is less secure than
    from_static_files as anything within the directory can be served.
    """
    print('Generating an app from static site directory')
    CONTENTS = f"{HEADER}\n\nimport os\nfrom flask import Flask, send_from_directory\n\n\ndef create_app():\n    app = Flask(__name__, static_folder='{args.source}')\n\n    # Serve static site\n    @app.route('/')\n    def index():\n        return send_from_directory(app.static_folder, 'index.html')\n            \n    return app\n\nif __name__ == '__main__':\n    app = create_app()\n    app.run()\n\n"
    _generate(CONTENTS,
      output_name=(args.output_name),
      filename=(args.output_file),
      dry_run=(args.dry_run))
    print('Successfully created new app')


def blueprint(args):
    """
    Static site blueprint
    """
    print('Generating a blueprint from static site')
    CONTENTS = f"{HEADER}\n\nimport os\nfrom flask import Blueprint, send_from_directory\n\nsite = Blueprint('site', __name__, static_folder='{args.source}')\n\n# Serve static site\n@site.route('/')\ndef index():\n    return send_from_directory(site.static_folder, 'index.html')\n\n"
    _generate(CONTENTS,
      output_name=(args.output_name),
      filename=(args.output_file),
      dry_run=(args.dry_run))
    print('Successfully created new blueprint')


def wsgi(args):
    from flaskerize.utils import split_file_factory
    filename, func = split_file_factory(args.source)
    filename = filename.replace('.py', '')
    CONTENTS = f"{HEADER}\n\nfrom {filename} import {func}\napp = {func}()\n    "
    _generate(CONTENTS,
      output_name=(args.output_name),
      filename=(args.output_file),
      dry_run=(args.dry_run))
    print('Successfully created new wsgi')


def namespace(args):
    """
    Generate a new Flask-RESTplus API Namespace
    """
    CONTENTS = f"from flask import request, jsonify\nfrom flask_restx import Namespace, Resource\nfrom flask_accepts import accepts, responds\nimport marshmallow as ma\n\napi = Namespace('{args.output_name}', description='All things {args.output_name}')\n\n\nclass {args.output_name.title()}:\n    '''A super awesome {args.output_name}'''\n\n    def __init__(self, id: int, a_float: float = 42.0, description: str = ''):\n        self.id = id\n        self.a_float = a_float\n        self.description = description\n\n\nclass {args.output_name.title()}Schema(ma.Schema):\n    id = ma.fields.Integer()\n    a_float = ma.fields.Float()\n    description = ma.fields.String(256)\n\n    @ma.post_load\n    def make(self, kwargs):\n        return {args.output_name.title()}(**kwargs)\n\n\n@api.route('/')\nclass {args.output_name.title()}Resource(Resource):\n    @accepts(schema={args.output_name.title()}Schema, api=api)\n    @responds(schema={args.output_name.title()}Schema)\n    def post(self):\n        return request.parsed_obj\n\n    @accepts(dict(name='id', type=int, help='ID of the {args.output_name.title()}'), api=api)\n    @responds(schema={args.output_name.title()}Schema)\n    def get(self):\n        return {args.output_name.title()}(id=request.parsed_args['id'])\n\n    @accepts(schema={args.output_name.title()}Schema, api=api)\n    @responds(schema={args.output_name.title()}Schema)\n    def update(self, id, data):\n        pass\n\n    @accepts(dict(name='id', type=int, help='ID of the {args.output_name.title()}'), api=api)\n    def delete(self, id):\n        pass\n\n"
    print(args)
    _generate(CONTENTS,
      output_name=(args.output_name),
      filename=(args.output_file),
      dry_run=(args.dry_run))
    if not args.without_test:
        namespace_test(args)


def namespace_test(args):
    """
    Generate a new Flask-RESTplus API Namespace
    """
    CONTENTS = f"import pytest\n\nfrom app.test.fixtures import app, client\nfrom .{args.output_name} import {args.output_name.title()}, {args.output_name.title()}Schema\n\n\n@pytest.fixture\ndef schema():\n    return {args.output_name.title()}Schema()\n\n\ndef test_schema_valid(schema):  # noqa\n    assert schema\n\n\ndef test_post(app, client, schema):  # noqa\n    with client:\n        obj = {args.output_name.title()}(id=42)\n        resp = client.post('{args.output_name}/', json=schema.dump(obj).data)\n        rv = schema.load(resp.json).data\n        assert obj.id == rv.id\n\n\ndef test_get(app, client, schema):  # noqa\n    with client:\n        resp = client.get('{args.output_name}/?id=42')\n        rv = schema.load(resp.json).data\n        assert rv\n        assert rv.id == 42\n\n"
    print(args)
    _generate(CONTENTS,
      output_name=(args.output_name and args.output_name.replace('.py', '') + '_test.py'),
      filename=(args.output_file and args.output_file.replace('.py', '') + '_test.py'),
      dry_run=(args.dry_run))


def dockerfile(args):
    import os
    CONTENTS = f'FROM python:3.7 as base\n\nFROM base as builder\nRUN mkdir /install\nWORKDIR /install\nRUN pip install --install-option="--prefix=/install" gunicorn\nRUN pip install --install-option="--prefix=/install" flask\n\nFROM base\nCOPY --from=builder /install /usr/local\nCOPY . /app\nWORKDIR /app\n\nEXPOSE 8080\nENTRYPOINT ["gunicorn", "--bind", "0.0.0.0:8080", "--access-logfile", "-", "--error-logfile", "-", "{args.source}"]\n\n'
    _generate(CONTENTS,
      output_name=(args.output_name),
      filename=(args.output_file),
      dry_run=(args.dry_run))
    print('Successfully created new Dockerfile')
    print('Next, run `docker build -t my_app_image .` to build the docker image and then use `docker run my_app_image -p 127.0.0.1:80:8080` to launch')


a = {'hello-world':hello_world, 
 'hw':hello_world, 
 'dockerfile':dockerfile, 
 'wsgi':wsgi, 
 'app_from_dir':app_from_dir, 
 'blueprint':blueprint, 
 'bp':blueprint, 
 'namespace':namespace, 
 'ns':namespace}
a: Dict[(str, Callable)]
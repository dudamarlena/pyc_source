# uncompyle6 version 3.7.4
# Python bytecode 3.6 (3379)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: build/bdist.linux-x86_64/egg/xsrfprobe/modules/Analysis.py
# Compiled at: 2020-01-29 10:31:04
# Size of source mod 2**32: 7111 bytes
import stringdist, itertools, time
from xsrfprobe.core.colors import *
from xsrfprobe.modules.Entropy import calcEntropy
from xsrfprobe.core.verbout import verbout
from xsrfprobe.core.utils import sameSequence, byteString
from xsrfprobe.files.discovered import REQUEST_TOKENS
from xsrfprobe.core.logger import VulnLogger, NovulLogger

def Analysis():
    """
    The main idea behind this is to observe and analyse
           the patterns in which the CSRF tokens
                  are generated by server.
    """
    ctr = 0
    if len(REQUEST_TOKENS) > 1:
        verbout(color.RED, '\n +--------------+')
        verbout(color.RED, ' |   Analysis   |')
        verbout(color.RED, ' +--------------+\n')
        print(GR + 'Proceeding for post-scan analysis of tokens gathered...')
        verbout(G, 'A total of %s tokens was discovered during the scan' % len(REQUEST_TOKENS))
        for tokenx1, tokenx2 in itertools.combinations(REQUEST_TOKENS, 2):
            try:
                verbout(GR, 'Analysing 2 Anti-CSRF Tokens from gathered requests...')
                verbout(color.CYAN, ' [+] First Token: ' + color.BLUE + tokenx1)
                verbout(color.ORANGE, ' [+] Shannon Entropy: ' + color.GREEN + '%s' % calcEntropy(tokenx1))
                verbout(color.CYAN, ' [+] Second Token: ' + color.BLUE + tokenx2)
                verbout(color.ORANGE, ' [+] Shannon Entropy: ' + color.GREEN + '%s' % calcEntropy(tokenx2))
                m = stringdist.rdlevenshtein(tokenx1, tokenx2)
                verbout(color.CYAN, ' [+] Edit Distance Calculated: ' + color.GREY + str(m) + '%')
                n = stringdist.rdlevenshtein_norm(tokenx1, tokenx2)
                verbout(color.CYAN, ' [+] Alignment Ratio Calculated: ' + color.GREY + str(n))
                if len(tokenx1) == len(tokenx2):
                    verbout(C, 'Token length calculated is same: ' + color.ORANGE + 'Each %s bytes' % len(byteString(tokenx1)))
                else:
                    verbout(C, 'Token length calculated is different: ' + color.ORANGE + 'By %s bytes' % (len(byteString(tokenx1)) - len(byteString(tokenx2))))
                time.sleep(0.5)
                p = sameSequence(tokenx1, tokenx2)
                tokenx01 = tokenx1.replace(p, '')
                tokenx02 = tokenx2.replace(p, '')
                if n == 0.5 or m == len(tokenx1) / 2:
                    verbout(GR, 'The tokens are composed of 2 parts (one static and other dynamic)... ')
                    verbout(C, 'Static Part : ' + color.GREY + p + color.END + ' | Length: ' + color.CYAN + str(len(p)))
                    verbout(O, 'Dynamic Part of Token 0x1: ' + color.GREY + tokenx01 + color.END + ' | Length: ' + color.CYAN + str(len(tokenx01)))
                    verbout(O, 'Dynamic Part of Token 0x2: ' + color.GREY + tokenx02 + color.END + ' | Length: ' + color.CYAN + str(len(tokenx02)))
                    if len(len(tokenx1) / 2) <= 6:
                        verbout(color.RED, ' [-] Post-Analysis reveals that token might be ' + color.BR + ' VULNERABLE ' + color.END + '!')
                        print(color.RED + ' [+] Possible CSRF Vulnerability Detected!')
                        print(color.ORANGE + ' [!] Vulnerability Type: ' + color.BR + ' Weak Dynamic Part of Tokens ' + color.END)
                        print(color.GREY + ' [+] Tokens can easily be ' + color.RED + 'Forged by Bruteforcing/Guessing' + color.END + '!\n')
                        VulnLogger('Analysis', 'Tokens can easily be Forged by Bruteforcing/Guessing.', '[i] Token 1: ' + tokenx1 + '\n[i] Token 2: ' + tokenx2)
                else:
                    if n < 0.5 or m < len(tokenx1) / 2:
                        verbout(R, 'Token distance calculated is ' + color.RED + 'less than 0.5!')
                        verbout(C, 'Static Part : ' + color.GREY + p + color.END + ' | Length: ' + color.CYAN + str(len(p)))
                        verbout(O, 'Dynamic Part of Token 0x1: ' + color.GREY + tokenx01 + color.END + ' | Length: ' + color.CYAN + str(len(tokenx01)))
                        verbout(O, 'Dynamic Part of Token 0x2: ' + color.GREY + tokenx02 + color.END + ' | Length: ' + color.CYAN + str(len(tokenx02)))
                        verbout(color.RED, ' [-] Post-Analysis reveals that token might be ' + color.BR + ' VULNERABLE ' + color.END + '!')
                        print(color.GREEN + ' [+] Possible CSRF Vulnerability Detected!')
                        print(color.ORANGE + ' [!] Vulnerability Type: ' + color.BR + ' Weak Dynamic Part of Tokens ' + color.END)
                        print(color.GREY + ' [+] Tokens can easily be ' + color.RED + 'Forged by Bruteforcing/Guessing' + color.END + '!\n')
                        VulnLogger('Analysis', 'Tokens can easily be Forged by Bruteforcing/Guessing.', '[i] Token 1: ' + tokenx1 + '\n[i] Token 2: ' + tokenx2)
                    else:
                        verbout(R, 'Token distance calculated is ' + color.GREEN + 'greater than 0.5!')
                        verbout(C, 'Static Part : ' + color.GREY + p + color.END + ' | Length: ' + color.CYAN + str(len(p)))
                        verbout(O, 'Dynamic Part of Token 0x1: ' + color.GREY + tokenx01 + color.END + ' | Length: ' + color.CYAN + str(len(tokenx01)))
                        verbout(O, 'Dynamic Part of Token 0x2: ' + color.GREY + tokenx02 + color.END + ' | Length: ' + color.CYAN + str(len(tokenx02)))
                        verbout(color.GREEN, ' [+] Post-Analysis reveals that tokens are ' + color.BG + ' NOT VULNERABLE ' + color.END + '!')
                        print(color.ORANGE + ' [!] Vulnerability Mitigation: ' + color.BG + ' Strong Dynamic Part of Tokens ' + color.END)
                        print(color.GREY + ' [+] Tokens ' + color.GREEN + 'Cannot be Forged by Bruteforcing/Guessing' + color.END + '!\n')
                        NovulLogger('Analysis', 'Tokens cannot be Forged by Bruteforcing/Guessing.')
                time.sleep(1)
            except KeyboardInterrupt:
                ctr += 1
                continue

        print(C + 'Post-Scan Analysis Completed!')
# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /Users/vohl/Documents/code/shwirl/shwirl/extern/vispy/scene/visuals.py
# Compiled at: 2018-10-01 14:58:41
# Size of source mod 2**32: 9555 bytes
"""
The classes in scene.visuals are visuals that may be added to a scenegraph
using the methods and properties defined in `vispy.scene.Node` such as name,
visible, parent, children, etc...

These classes are automatically generated by mixing `vispy.scene.Node` with
the Visual classes found in `vispy.visuals`.

For developing custom visuals, it is recommended to subclass from
`vispy.visuals.Visual` rather than `vispy.scene.Node`.
"""
import re, weakref
from .. import visuals
from .node import Node
from visuals.filters import ColorFilter, PickingFilter

class VisualNode(Node):
    _next_id = 1
    _visual_ids = weakref.WeakValueDictionary()

    def __init__(self, parent=None, name=None):
        Node.__init__(self, parent=parent, name=name, transforms=(self.transforms))
        self.interactive = False
        self._opacity_filter = ColorFilter()
        self.attach(self._opacity_filter)
        self._id = VisualNode._next_id
        VisualNode._visual_ids[self._id] = self
        VisualNode._next_id += 1
        self._picking_filter = PickingFilter(id_=(self._id))
        self.attach(self._picking_filter)

    def _update_opacity(self):
        self._opacity_filter.color = (
         1, 1, 1, self._opacity)

    def _set_clipper(self, node, clipper):
        """Assign a clipper that is inherited from a parent node.

        If *clipper* is None, then remove any clippers for *node*.
        """
        if node in self._clippers:
            self.detach(self._clippers.pop(node))
        if clipper is not None:
            self.attach(clipper)
            self._clippers[node] = clipper

    @property
    def picking(self):
        """Boolean that determines whether this node (and its children) are
        drawn in picking mode.
        """
        return self._picking

    @picking.setter
    def picking(self, p):
        for c in self.children:
            c.picking = p

        if self._picking == p:
            return
        self._picking = p
        self._picking_filter.enabled = p
        self.update_gl_state(blend=(not p))

    def _update_trsys(self, event):
        """Transform object(s) have changed for this Node; assign these to the
        visual's TransformSystem.
        """
        doc = self.document_node
        scene = self.scene_node
        root = self.root_node
        self.transforms.visual_transform = self.node_transform(scene)
        self.transforms.scene_transform = scene.node_transform(doc)
        self.transforms.document_transform = doc.node_transform(root)
        Node._update_trsys(self, event)

    @property
    def interactive(self):
        """Whether this widget should be allowed to accept mouse and touch
        events.
        """
        return self._interactive

    @interactive.setter
    def interactive(self, i):
        self._interactive = i

    def draw(self):
        if self.picking:
            if not self.interactive:
                return
        self._visual_superclass.draw(self)


def create_visual_node(subclass):
    clsname = subclass.__name__
    if not (clsname.endswith('Visual') and issubclass(subclass, visuals.BaseVisual)):
        raise RuntimeError('Class "%s" must end with Visual, and must subclass BaseVisual' % clsname)
    clsname = clsname[:-6]
    try:
        doc = generate_docstring(subclass, clsname)
    except Exception:
        doc = subclass.__doc__

    def __init__(self, *args, **kwargs):
        parent = kwargs.pop('parent', None)
        name = kwargs.pop('name', None)
        self.name = name
        self._visual_superclass = subclass
        (subclass.__init__)(self, *args, **kwargs)
        self.unfreeze()
        VisualNode.__init__(self, parent=parent, name=name)
        self.freeze()

    cls = type(clsname, (VisualNode, subclass), {'__init__':__init__, 
     '__doc__':doc})
    return cls


def generate_docstring(subclass, clsname):
    sc_doc = subclass.__doc__
    if sc_doc is None:
        sc_doc = ''
    lines = sc_doc.split('\n')
    while lines and lines[0].strip() == '':
        lines.pop(0)

    i = 0
    params_started = False
    param_indent = None
    first_blank = None
    param_end = None
    while i < len(lines):
        line = lines[i]
        if re.search('\\w', line):
            indent = len(line) - len(line.lstrip())
            if params_started:
                if indent < param_indent:
                    break
                else:
                    if indent == param_indent:
                        if re.match('\\s*[a-zA-Z0-9_]+\\s*:\\s*\\S+', line) is None:
                            break
                param_end = i + 1
            elif re.match('\\s*Parameters\\s*', line):
                params_started = True
                param_indent = indent
                if first_blank is None:
                    first_blank = i
        elif first_blank is None:
            if line.strip() == '':
                first_blank = i
        i += 1
        if i == len(lines) and param_end is None:
            param_end = i

    if not params_started:
        lines.extend(['', '    Parameters', '    ----------'])
        param_end = len(lines)
        if first_blank is None:
            first_blank = param_end - 3
        params_started = True
    class_desc = '\n    This class inherits from visuals.%sVisual and scene.Node, allowing the visual to be placed inside a scenegraph.\n' % clsname
    parm_doc = '    parent : Node\n        The parent node to assign to this node (optional).\n    name : string\n        A name for this node, used primarily for debugging\n        (optional).'
    lines = lines[:first_blank] + [class_desc] + lines[first_blank:param_end] + [parm_doc] + lines[param_end:]
    doc = '\n'.join(lines)
    return doc


Arrow = create_visual_node(visuals.ArrowVisual)
Axis = create_visual_node(visuals.AxisVisual)
Box = create_visual_node(visuals.BoxVisual)
ColorBar = create_visual_node(visuals.ColorBarVisual)
Compound = create_visual_node(visuals.CompoundVisual)
Cube = create_visual_node(visuals.CubeVisual)
Ellipse = create_visual_node(visuals.EllipseVisual)
Graph = create_visual_node(visuals.GraphVisual)
GridLines = create_visual_node(visuals.GridLinesVisual)
GridMesh = create_visual_node(visuals.GridMeshVisual)
Histogram = create_visual_node(visuals.HistogramVisual)
Image = create_visual_node(visuals.ImageVisual)
InfiniteLine = create_visual_node(visuals.InfiniteLineVisual)
Isocurve = create_visual_node(visuals.IsocurveVisual)
Isoline = create_visual_node(visuals.IsolineVisual)
Isosurface = create_visual_node(visuals.IsosurfaceVisual)
Line = create_visual_node(visuals.LineVisual)
LinearRegion = create_visual_node(visuals.LinearRegionVisual)
LinePlot = create_visual_node(visuals.LinePlotVisual)
Markers = create_visual_node(visuals.MarkersVisual)
Mesh = create_visual_node(visuals.MeshVisual)
Plane = create_visual_node(visuals.PlaneVisual)
Polygon = create_visual_node(visuals.PolygonVisual)
Rectangle = create_visual_node(visuals.RectangleVisual)
RegularPolygon = create_visual_node(visuals.RegularPolygonVisual)
ScrollingLines = create_visual_node(visuals.ScrollingLinesVisual)
Spectrogram = create_visual_node(visuals.SpectrogramVisual)
Sphere = create_visual_node(visuals.SphereVisual)
SurfacePlot = create_visual_node(visuals.SurfacePlotVisual)
Text = create_visual_node(visuals.TextVisual)
Tube = create_visual_node(visuals.TubeVisual)
Volume = create_visual_node(visuals.VolumeVisual)
XYZAxis = create_visual_node(visuals.XYZAxisVisual)
__all__ = [name for name, obj in globals().items() if isinstance(obj, type) if issubclass(obj, VisualNode)]
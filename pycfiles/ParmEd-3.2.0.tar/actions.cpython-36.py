# uncompyle6 version 3.7.4
# Python bytecode 3.6 (3379)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /home/swails/src/ParmEd/parmed/tools/actions.py
# Compiled at: 2018-01-23 21:07:53
# Size of source mod 2**32: 196579 bytes
"""
All of the prmtop actions used in PARMED. Each class is a separate action.
"""
from __future__ import absolute_import, division, print_function
import copy, math, os, sys, warnings
from collections import Counter, OrderedDict
import numpy as np
from .. import gromacs, unit as u
from ..amber import AmberAsciiRestart, AmberMask, AmberMdcrd, AmberParm, AmoebaParm, ChamberParm, NetCDFRestart, NetCDFTraj
from ..amber._chamberparm import ConvertFromPSF
from ..charmm import CharmmParameterSet, CharmmPsfFile
from ..exceptions import ParmedError
from ..formats import CIFFile, Mol2File, PDBFile
from ..formats.registry import load_file
from ..modeller import AmberOFFLibrary, ResidueTemplateContainer
from ..periodic_table import Element as _Element
from ..residue import ANION_NAMES, CATION_NAMES, SOLVENT_NAMES, AminoAcidResidue, DNAResidue, RNAResidue
from ..structure import Structure
from ..topologyobjects import Angle, AngleType, Bond, BondType, Dihedral, DihedralType, DihedralTypeList
from ..utils.six import add_metaclass, iteritems, string_types
from ..utils.six.moves import range, zip
from .argumentlist import ArgumentList
from .exceptions import AddPDBError, AddPDBWarning, AmbiguousParmError, ArgumentError, ChamberError, ChangeLJPairError, ChangeStateError, DeleteDihedralError, FileDoesNotExist, FileExists, HMassRepartitionError, IncompatibleParmsError, InputError, LJ12_6_4Error, NoArgument, NonexistentParm, ParmedChangeError, ParmError, ParmFileNotFound, ParmWarning, SeriousParmWarning, SetParamError, SimulationError, TiMergeError, UnhandledArgumentWarning, WriteOFFError
from .parmlist import ParmList
GB_RADII = [
 'amber6', 'bondi', 'mbondi', 'mbondi2', 'mbondi3']
__all__ = []
COMMANDMAP = dict()
Usages = dict(go='go', quit='quit', help='help [<action>]', history='history')

class ActionType(type):
    __doc__ = '\n    Metaclass for defining Action types, to add it to the list of available\n    actions and provide a hash lookup to the interpreter to support\n    case-insensitive command access\n\n    Parameters\n    ----------\n    cls : class type\n        The class that is being generated by this metaclass\n    name : str\n        The name of the class being created\n    bases : tuple of types\n        Tuple of all base class types for this class\n    dct: dict\n        The list of options and attributes currently present in this class\n    '

    def __init__(cls, name, bases, dct):
        global COMMANDMAP
        global Usages
        global __all__
        __all__.append(name)
        if name != 'Action':
            COMMANDMAP[name.lower()] = cls
        if 'usage' in dct:
            Usages[name.lower()] = '%s %s' % (name, dct['usage'])
        else:
            if name != 'Action':
                Usages[name.lower()] = name
        super(ActionType, cls).__init__(name, bases, dct)


lawsuit = object

@add_metaclass(ActionType)
class Action(lawsuit):
    __doc__ = "\n    The base class for all ParmEd actions. The metaclass for Action adds the\n    action and its usage statement to a map that is imported and used by the\n    ParmEd interpreter. So just adding the subclass, wherever it happens, and\n    giving it a 'usage' attribute is sufficient to have it added to the\n    interpreter map. There are a number of attributes that can refine the\n    behavior of individual Actions in the interpreter:\n\n    Parameters\n    ----------\n    input_parm : Structure\n    arg_list : str or ArgumentList\n\n    Attributes\n    ----------\n    stderr : file-like, optional\n        Having a ``write`` attribute, this is where errors and warnings will be\n        written. Default is sys.stderr\n    needs_parm : bool, optional\n        If this Action needs a ``parm`` instance to operate on. If your Action\n        either acts on the interpreter or *creates* a parm, this can be False.\n        Default is True\n    supported_subclasses : tuple\n        A tuple of all types whose subclasses can be acted upon by this Action.\n        This is useful for permissive Action classes\n    strictly_supported : tuple\n        This Action can *only* act on a particular set of class instances. If\n        the parm does not have one of the listed types, it is not supported\n        (subclasses do *not* count here)\n    not_supported : tuple\n        These classes are *not* supported (supplements supported_subclasses)\n    "
    stderr = sys.stderr
    needs_parm = True
    overwrite = True
    supported_subclasses = (
     Structure,)
    strictly_supported = ()
    not_supported = ()

    def __init__(self, input_parm, arg_list=None, *args, **kwargs):
        self.valid = False
        if isinstance(input_parm, ParmList):
            self.parm_list = input_parm
        else:
            if isinstance(input_parm, Structure):
                self.parm_list = ParmList()
                self.parm_list.add_parm(input_parm)
            else:
                if input_parm is None:
                    self.parm_list = ParmList()
                else:
                    raise TypeError('input_parm expected to be a ParmList or Structure instance')
        self.parm = self.parm_list.parm
        if self.needs_parm:
            if self.parm_list.empty():
                raise ParmError('Action requires a loaded topology file')
        if args or kwargs:
            if arg_list is None:
                arg_list = ''
            elif isinstance(arg_list, string_types):
                if ' ' in arg_list.strip():
                    arg_list = '"%s"  ' % arg_list
            else:
                arg_list = '%s ' % arg_list
            arg_list += ' '.join([self._format_arg(a) for a in args])
            for kw, item in iteritems(kwargs):
                arg_list += ' %s %s ' % (kw, self._format_arg(item))

        else:
            if arg_list is None:
                arg_list = ArgumentList('')
            else:
                if isinstance(arg_list, string_types):
                    arg_list = self._format_arg(arg_list)
                else:
                    if isinstance(arg_list, string_types):
                        arg_list = ArgumentList(arg_list)
                    else:
                        arg_list = ArgumentList(str(arg_list))
                parm = arg_list.get_key_string('parm', None)
                if parm is not None:
                    try:
                        parm = int(parm)
                    except ValueError:
                        if parm in self.parm_list:
                            print('Using parm %s' % parm)
                            self.parm = self.parm_list[parm]
                        else:
                            warnings.warn('Cannot find parm %s. Skipping this action' % parm, SeriousParmWarning)
                            return
                    else:
                        if parm >= 0 and parm < len(self.parm_list):
                            print('Using parm %s' % self.parm_list[parm])
                            self.parm = self.parm_list[parm]
                        else:
                            warnings.warn('Cannot find parm %s. Skipping this action' % parm, SeriousParmWarning)
                            return
        if self.needs_parm:
            if self.strictly_supported:
                if type(self.parm) not in self.strictly_supported:
                    raise ParmError('%s objects are not supported by this action' % type(self.parm).__name__)
            if not self.strictly_supported:
                for cls in self.not_supported:
                    if type(self.parm) is cls:
                        raise ParmError('%s objects are not supported by this action' % type(self.parm).__name__)

                for cls in self.supported_subclasses:
                    if isinstance(self.parm, cls):
                        break
                else:
                    raise ParmError('%s objects are not supported by this action' % type(self.parm).__name__)

        self._arg_list = arg_list
        try:
            self.init(arg_list)
        except NoArgument:
            cmdname = type(self).__name__
            try:
                usage = '%s %s' % (cmdname, self.usage)
            except AttributeError:
                usage = cmdname

            Action.stderr.write('Bad command %s:\n\t%s\n' % (cmdname, usage))
            return
        else:
            unmarked_cmds = arg_list.unmarked()
            if len(unmarked_cmds) > 0:
                warnings.warn(' '.join(unmarked_cmds), UnhandledArgumentWarning)
            self.valid = True

    def init(self, arg_list):
        """ This should be overridden if anything needs to be done """
        raise NotImplementedError('init must be overridden by Action subclass')

    def execute(self):
        """ Commands involved in executing the action """
        pass

    def __str__(self):
        return ''

    @staticmethod
    def _format_arg(arg):
        """
        Formats an argument so that if it's a string with a space in it, the argument will be
        encapsulated with quotes
        """
        arg = str(arg)
        if ' ' in arg or '\t' in arg:
            return ' "%s" ' % arg
        else:
            return arg


class parmout(Action):
    __doc__ = '\n    Final prmtop written after all actions are complete\n    '
    usage = '<prmtop_name> [<inpcrd_name>] [netcdf]'
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        self.filename = arg_list.get_next_string()
        self.rst_name = arg_list.get_next_string(optional=True)
        if arg_list.has_key('netcdf'):
            self.rst7_format = 'NCRST'
        else:
            self.rst7_format = 'RST7'

    def __str__(self):
        if self.rst_name is not None:
            return 'Outputting Amber topology file %s and restart %s' % (self.filename,
             self.rst_name)
        else:
            return 'Outputting Amber topology file %s' % self.filename

    def execute(self):
        if not Action.overwrite:
            if os.path.exists(self.filename):
                raise FileExists('%s exists; not overwriting.' % self.filename)
        else:
            if self.rst_name is not None:
                if not Action.overwrite:
                    if os.path.exists(self.rst_name):
                        raise FileExists('%s exists; not overwriting.' % self.rst_name)
            self.parm.write_parm(self.filename)
            if self.rst_name is not None:
                self.parm.save((self.rst_name), format=(self.rst7_format), overwrite=(Action.overwrite))


class setOverwrite(Action):
    __doc__ = '\n    Necessary to overwrite original topology file name.\n    '
    usage = '[True|False]'
    needs_parm = False

    def init(self, arg_list):
        arg = arg_list.get_next_string(optional=True)
        if arg is not None:
            if arg.lower() not in ('false', 'true'):
                warnings.warn('setOverwrite: unrecognized argument. Assuming False', SeriousParmWarning)
        self._overwrite = arg is None or arg.lower() == 'true'

    def __str__(self):
        if self._overwrite:
            return 'Files are overwritable'
        else:
            return 'Files are NOT overwritable'

    def execute(self):
        Action.overwrite = self._overwrite


class writeFrcmod(Action):
    __doc__ = '\n    Writes an frcmod file from all of the parameters in the topology file.\n    '
    usage = '<frcmod_name>'
    strictly_supported = (AmberParm,)

    def init(self, arg_list):
        self.frcmod_name = arg_list.get_next_string(optional=True)
        if self.frcmod_name is None:
            self.frcmod_name = 'frcmod'
        hbond_indexes = set()
        for idx in self.parm.parm_data['NONBONDED_PARM_INDEX']:
            if idx < 0:
                hbond_indexes.add(abs(idx))

        try:
            for idx in hbond_indexes:
                if self.parm.parm_data['HBOND_ACOEF'][(idx - 1)] > 0 or self.parm.parm_data['HBOND_BCOEF'][(idx - 1)] > 0 or self.parm.parm_data['HBCUT'][(idx - 1)] > 0:
                    warnings.warn('Frcmod dumping does not work with 10-12 prmtops', SeriousParmWarning)
                    break

        except IndexError:
            pass

    def __str__(self):
        return 'Dumping FRCMOD file %s with parameters from %s' % (
         self.frcmod_name, self.parm)

    def execute(self):
        """ Writes the frcmod file """
        from parmed.amber.parameters import AmberParameterSet
        if not Action.overwrite:
            if os.path.exists(self.frcmod_name):
                raise FileExists('%s exists; not overwriting' % self.frcmod_name)
        parmset = AmberParameterSet.from_structure(self.parm)
        title = 'Force field parameters from %s' % os.path.split(str(self.parm))[1]
        parmset.write((self.frcmod_name), title=title)


class loadRestrt(Action):
    __doc__ = '\n    Loads a restart file so we have coordinates. Necessary for distance-based\n    mask criteria and writeOFF\n    '
    usage = '<restrt_filename>'
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        self.rst_name = arg_list.get_next_string()

    def __str__(self):
        return 'Loading restart file %s' % self.rst_name

    def execute(self):
        self.parm.load_rst7(self.rst_name)


class loadCoordinates(Action):
    __doc__ = '\n    Reads a coordinate file and loads the first set of coordinates found into\n    the active structure. File type is auto-detected. Supported file formats\n    include:\n\n        - Amber restart file\n        - Amber NetCDF restart file\n        - CHARMM coordinate file\n        - CHARMM restart file\n        - Amber mdcrd trajectory\n        - Amber NetCDF trajectory\n        - PDB file\n        - PDBx/mmCIF file\n        - Gromacs GRO file\n        - Mol2 file\n    '
    usage = '<filename>'

    def init(self, arg_list):
        self.filename = arg_list.get_next_string()

    def __str__(self):
        return 'Adding coordinates to %s from %s' % (self.parm.name, self.filename)

    def execute(self):
        crd = load_file((self.filename), natom=(len(self.parm.atoms)), hasbox=(self.parm.box is not None))
        try:
            self.parm.coordinates = crd.coordinates.copy()
        except AttributeError:
            raise ParmError('Cannot get coordinates from %s' % self.filename)

        self.parm.box = copy.copy(crd.box)


class writeCoordinates(Action):
    __doc__ = '\n    Writes the coordinates of the active structure to a coordinate file. The\n    format of the file is detected from filename extension, with the following\n    extensions being recognized:\n\n        - ``.nc``: Amber NetCDF trajectory with a single frame\n        - ``.ncrst``: Amber NetCDF restart file\n        - ``.pdb``: PDB file\n        - ``.cif``: PDBx/mmCIF file\n        - ``.rst7``, ``.restrt``, ``.inpcrd``: Amber restart file\n        - ``.mdcrd``: Amber mdcrd file\n        - ``.mol2``: Sybyl Mol2 file\n        - Default is Amber restart file\n\n    Alternatively, the following keywords can be used to override the filename\n    extension:\n\n        - ``netcdftraj``: Amber NetCDF trajectory with a single frame\n        - ``netcdf``: Amber NetCDF restart file\n        - ``pdb``: PDB file\n        - ``cif``: PDBx/mmCIF file\n        - ``restart``: Amber restart/inpcrd file\n        - ``mdcrd``: Amber mdcrd file\n        - ``mol2``: Sybyl mol2 file\n\n    Note, NetCDF files require scipy or netCDF4 to be installed.\n    '
    usage = '<filename> [netcdftraj | netcdf | pdb | cif | restart | mdcrd | mol2]'

    def init(self, arg_list):
        self.filename = filename = arg_list.get_next_string()
        self.filetype = arg_list.get_next_string(optional=True, default='').lower()
        if not self.filetype:
            if filename.endswith('.nc'):
                self.filetype = 'NCTRAJ'
            else:
                if filename.endswith('.ncrst'):
                    self.filetype = 'NCRESTART'
                else:
                    if filename.endswith('.pdb'):
                        self.filetype = 'PDB'
                    else:
                        if filename.endswith('.cif'):
                            self.filetype = 'CIF'
                        else:
                            if filename.endswith('.rst7') or filename.endswith('.restrt') or filename.endswith('.inpcrd'):
                                self.filetype = 'RESTART'
                            else:
                                if filename.endswith('.mdcrd'):
                                    self.filetype = 'MDCRD'
                                else:
                                    if filename.endswith('.mol2'):
                                        self.filetype = 'MOL2'
                                    else:
                                        self.filetype = 'RESTART'
        else:
            if self.filetype == 'netcdftraj':
                self.filetype = 'NCTRAJ'
            else:
                if self.filetype == 'netcdf':
                    self.filetype = 'NCRESTART'
                else:
                    if self.filetype == 'pdb':
                        self.filetype = 'PDB'
                    else:
                        if self.filetype == 'cif':
                            self.filetype = 'CIF'
                        else:
                            if self.filetype == 'restart':
                                self.filetype = 'RESTART'
                            else:
                                if self.filetype == 'mdcrd':
                                    self.filetype = 'MDCRD'
                                else:
                                    if self.filetype == 'mol2':
                                        self.filetype = 'MOL2'
                                    else:
                                        raise InputError('Unrecognized file format %s' % self.filetype)

    def __str__(self):
        return 'Writing coordinates to %s as type %s' % (self.filename, self.filetype)

    def execute(self):
        if not Action.overwrite:
            if os.path.exists(self.filename):
                raise FileExists('%s exists; not overwriting' % self.filename)
        else:
            coordinates = self.parm.coordinates
            velocities = self.parm.velocities
            if self.filetype == 'NCTRAJ':
                traj = NetCDFTraj.open_new((self.filename), natom=(len(self.parm.atoms)), box=(self.parm.box is not None),
                  vels=(velocities is not None))
                traj.add_time(0)
                traj.add_coordinates(coordinates)
                if velocities is not None:
                    traj.add_velocities(velocities)
                if self.parm.box is not None:
                    traj.add_box(self.parm.box)
                traj.close()
            else:
                if self.filetype == 'NCRESTART':
                    rst = NetCDFRestart.open_new((self.filename), natom=(len(self.parm.atoms)), box=(self.parm.box is not None),
                      vels=(velocities is not None))
                    rst.coordinates = coordinates
                    if velocities is not None:
                        rst.velocities = velocities
                    if self.parm.box is not None:
                        rst.box = self.parm.box
                    rst.time = 0
                    rst.close()
                else:
                    if self.filetype == 'PDB':
                        PDBFile.write((self.parm), (self.filename), renumber=True)
                    else:
                        if self.filetype == 'CIF':
                            CIFFile.write((self.parm), (self.filename), renumber=True)
                        else:
                            if self.filetype == 'MOL2':
                                Mol2File.write(self.parm, self.filename)
                            else:
                                if self.filetype == 'MDCRD':
                                    traj = AmberMdcrd((self.filename), natom=(len(self.parm.atoms)), hasbox=(self.parm.box is not None),
                                      mode='w')
                                    traj.add_coordinates(coordinates)
                                    if self.parm.box is not None:
                                        traj.add_box(self.parm.box)
                                    traj.close()
                                else:
                                    if self.filetype == 'RESTART':
                                        rst = AmberAsciiRestart((self.filename), natom=(len(self.parm.atoms)), mode='w', hasbox=(self.parm.box is not None))
                                        rst.coordinates = coordinates
                                        if velocities is not None:
                                            rst.velocities = velocities
                                        if self.parm.box is not None:
                                            rst.box = self.parm.box
                                        rst.close()
                                    else:
                                        raise AssertionError('Should not be here. Unrecognized coordinate file format type.')


class writeOFF(Action):
    __doc__ = '\n    Writes an Amber OFF Library with all of the residues found in the topology\n    '
    usage = '<OFF_filename>'
    strictly_supported = (AmberParm,)

    def init(self, arg_list):
        self.off_file = arg_list.get_next_string()

    def __str__(self):
        return 'Writing Amber OFF file %s' % self.off_file

    def execute(self):
        if not Action.overwrite:
            if os.path.exists(self.off_file):
                raise FileExists('%s exists; not overwriting' % self.off_file)
        if self.parm.coordinates is None:
            raise WriteOFFError('You must load a restart for WriteOFF!')
        lib = ResidueTemplateContainer.from_structure(self.parm).to_library()
        AmberOFFLibrary.write(lib, self.off_file)


class changeRadii(Action):
    __doc__ = '\n    Changes intrinsic GB radii to the specified set: Allowed values are\n        amber6, bondi, mbondi, mbondi2, mbondi3\n    '
    usage = '<radii_set>'
    not_supported = (AmoebaParm,)

    def init(self, arg_list):
        self.radii = arg_list.get_next_string()

    def __str__(self):
        return 'Changing PB/GB radii to %s' % self.radii

    def execute(self):
        from parmed.tools.changeradii import ChRad
        if isinstance(self.parm, AmberParm):
            if 'RADIUS_SET' not in self.parm.flag_list:
                self.parm.add_flag('RADIUS_SET', '1a80', num_items=1)
            else:
                if 'RADII' not in self.parm.flag_list:
                    self.parm.add_flag('RADII', '5E16.8', num_items=(len(self.parm.atoms)))
                if 'SCREEN' not in self.parm.flag_list:
                    self.parm.add_flag('SCREEN', '5E16.8', num_items=(len(self.parm.atoms)))
            ChRad(self.parm, self.radii)
            for i, atom in enumerate(self.parm.atoms):
                self.parm.parm_data['RADII'][i] = atom.solvent_radius
                self.parm.parm_data['SCREEN'][i] = atom.screen

        else:
            ChRad(self.parm, self.radii)


class changeLJPair(Action):
    __doc__ = '\n    Changes a particular Lennard Jones pair based on a given (pre-combined)\n    epsilon/Rmin\n    '
    usage = '<mask1> <mask2> <Rmin> <epsilon>'
    strictly_supported = (AmberParm, ChamberParm)

    def init(self, arg_list):
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())
        self.rmin = arg_list.get_next_float()
        self.eps = arg_list.get_next_float()

    def __str__(self):
        return 'Setting LJ %s-%s pairwise interaction to have Rmin = %16.5f and Epsilon = %16.5f' % (
         self.mask1, self.mask2, self.rmin, self.eps)

    def execute(self):
        selection1 = self.mask1.Selection()
        selection2 = self.mask2.Selection()
        if sum(selection1) == 0 or sum(selection2) == 0:
            Action.stderr.write('Skipping empty masks in changeLJPair\n')
            return 0
        attype1 = None
        attype2 = None
        for i, atom in enumerate(self.parm.atoms):
            if selection1[i] == 1:
                if attype1 is None:
                    attype1 = atom.nb_idx
                else:
                    if attype1 != atom.nb_idx:
                        raise ChangeLJPairError('First mask matches multiple atom types!')
                if selection2[i] == 1:
                    if attype2 is None:
                        attype2 = atom.nb_idx
                    elif attype2 != atom.nb_idx:
                        raise ChangeLJPairError('Second mask matches multiple atom types!')

        _change_lj_pair(self.parm, attype1, attype2, self.rmin, self.eps)


class changeLJ14Pair(Action):
    __doc__ = '\n    Changes a particular 1-4 Lennard Jones pair based on a given (pre-combined)\n    epsilon/Rmin. Only valid for CHAMBER prmtops\n    '
    usage = '<mask1> <mask2> <Rmin> <epsilon>'
    strictly_supported = (ChamberParm,)

    def init(self, arg_list):
        assert self.parm.chamber, 'Chamber-style prmtop required!'
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())
        self.rmin = arg_list.get_next_float()
        self.eps = arg_list.get_next_float()

    def __str__(self):
        return 'Setting LJ 1-4 %s-%s pairwise interaction to have 1-4 Rmin = %16.5f and 1-4 Epsilon = %16.5f' % (
         self.mask1, self.mask2, self.rmin, self.eps)

    def execute(self):
        selection1 = self.mask1.Selection()
        selection2 = self.mask2.Selection()
        if sum(selection1) == 0 or sum(selection2) == 0:
            Action.stderr.write('Skipping empty masks in changeLJ14Pair\n')
            return
        attype1 = None
        attype2 = None
        for i, atom in enumerate(self.parm.atoms):
            if selection1[i] == 1:
                if attype1 is None:
                    attype1 = atom.nb_idx
                else:
                    if attype1 != atom.nb_idx:
                        raise ChangeLJPairError('First mask matches multiple atom types!')
                if selection2[i] == 1:
                    if attype2 is None:
                        attype2 = atom.nb_idx
                    elif attype2 != atom.nb_idx:
                        raise ChangeLJPairError('Second mask matches multiple atom types!')

        _change_lj_pair(self.parm, attype1, attype2, self.rmin, self.eps, True)


class checkValidity(Action):
    __doc__ = '\n    Basic checks for prmtop validity.\n    '
    output = sys.stdout
    strictly_supported = (AmberParm, ChamberParm)

    def init(self, arg_list):
        pass

    def __str__(self):
        return 'Determining validity of prmtop'

    def execute(self):
        from parmed.tools.checkvalidity import check_validity
        from parmed.tools.exceptions import WarningList
        warning_log = WarningList(empty_msg=('%s looks OK to me!' % self.parm))
        check_validity(self.parm, warning_log)
        warning_log.dump(self.output)


class change(Action):
    __doc__ = '\n    Changes the property of given atoms to a new value. <property> can be\n    CHARGE, MASS, RADII, SCREEN, ATOM_NAME, ATOM_TYPE, ATOM_TYPE_INDEX,\n    or ATOMIC_NUMBER (note, changing elements with this command will NOT\n    change their assignment for SHAKE!).\n\n    If given, the [quiet] keyword will prevent ParmEd from printing out a\n    summary with every property changed for every atom that was changed\n    useful for suppressing overwhelming output if you are zeroing every\n    charge, for instance)\n    '
    usage = '<property> <mask> <new_value> [quiet]'

    def init(self, arg_list):
        self.quiet = arg_list.has_key('quiet')
        self.mask = AmberMask(self.parm, arg_list.get_next_mask())
        self.prop = self.flag_name = prop = arg_list.get_next_string().upper()
        self.add_flag = False
        if prop in ('CHARGE', 'RADII', 'SCREEN', 'MASS'):
            self.new_val = arg_list.get_next_float()
            self.new_val_str = '%.4f' % self.new_val
        else:
            if prop in ('ATOM_TYPE_INDEX', 'ATOMIC_NUMBER'):
                self.new_val = arg_list.get_next_int()
                self.new_val_str = '%4i' % self.new_val
            else:
                if prop in ('ATOM_NAME', 'AMBER_ATOM_TYPE', 'TREE_CHAIN_CLASSIFICATION',
                            'ATOM_TYPE'):
                    self.new_val = arg_list.get_next_string()
                    if len(self.new_val) > 4:
                        warnings.warn('Only 4 letters allowed for %s entries! Truncating remaining letters.' % prop, ParmWarning)
                        self.new_val = self.new_val[:4]
                    self.new_val_str = '%-4s' % self.new_val
                else:
                    raise ParmedChangeError('You may only use "change" with CHARGE, MASS, RADII, SCREEN, ATOM_NAME, ATOM_TYPE, ATOM_TYPE_INDEX, ATOMIC_NUMBER, or TREE_CHAIN_CLASSIFICATION')
        if type(self.parm) is AmoebaParm:
            if prop in ('CHARGE', 'RADII', 'SCREEN', 'ATOM_TYPE_INDEX'):
                raise ParmedChangeError('You cannot change %s in Amoeba topologies' % prop)
            if prop == 'ATOMIC_NUMBER':
                if self.parm.amoeba:
                    self.flag_name = 'AMOEBA_ATOMIC_NUMBER'
                if prop not in self.parm.parm_data:
                    self.add_flag = True

    def __str__(self):
        atnums = self.mask.Selection()
        if sum(atnums) == 0:
            return 'change %s: Nothing to do' % self.prop
        else:
            if self.quiet:
                return 'Changing %s of %s to %s' % (self.prop, self.mask, self.new_val)
            string = ''
            for i, atom in enumerate(self.parm.atoms):
                if atnums[i] == 1:
                    string += 'Changing %s of atom # %d (%s) from %s to %s\n' % (
                     self.prop, i + 1, atom.name, self.parm.parm_data[self.prop][i], self.new_val_str)

            return string

    def execute(self):
        atnums = self.mask.Selection()
        if sum(atnums) == 0:
            warnings.warn('change %s: %s matches no atoms' % (self.prop, self.mask), ParmWarning)
            return
        else:
            if self.prop == 'ATOM_TYPE_INDEX':
                prop = 'nb_idx'
            else:
                if self.prop == 'ATOM_NAME':
                    prop = 'name'
                else:
                    if self.prop in ('AMBER_ATOM_TYPE', 'ATOM_TYPE'):
                        prop = 'type'
                    else:
                        if self.prop == 'TREE_CHAIN_CLASSIFICATION':
                            prop = 'tree'
                        else:
                            if self.prop == 'RADII':
                                prop = 'solvent_radius'
                            else:
                                prop = self.prop.lower()
        for i, atom in enumerate(self.parm.atoms):
            if atnums[i] == 1:
                setattr(atom, prop, self.new_val)

        if isinstance(self.parm, AmberParm):
            if self.add_flag:
                addAtomicNumber(self.parm).execute()
            for i, atom in enumerate(self.parm.atoms):
                self.parm.parm_data[self.flag_name][i] = getattr(atom, prop)


class printInfo(Action):
    __doc__ = '\n    Prints all prmtop data corresponding to the given %FLAG\n    '
    usage = '<flag>'
    outfile = sys.stdout
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        self.flag = arg_list.get_next_string().upper()
        if self.flag not in self.parm.flag_list:
            warnings.warn('%%FLAG %s not found!' % self.flag, SeriousParmWarning)
            self.found = False
        else:
            if self.parm.formats[self.flag].type is float:
                self.format = '%16.5f '
            else:
                self.format = '%-16s '
            self.found = True

    def __repr__(self):
        ret_str = []
        if self.found:
            for i, item in enumerate(self.parm.parm_data[self.flag]):
                ret_str.append(self.format % item)
                if i % 5 == 4:
                    ret_str.append('\n')

        return ''.join(ret_str)

    def __str__(self):
        return self.__repr__()


class addLJType(Action):
    __doc__ = "\n    Turns given mask into a new LJ atom type. It uses the radius and Rmin from\n    the first atom type in <mask> if new_radius or new_epsilon aren't provided\n    "
    usage = '<mask> [radius <new_radius>] [epsilon <new_epsilon>] [radius_14 <new_radius14>] [epsilon_14 <new_epsilon14>]'
    strictly_supported = (
     AmberParm, ChamberParm)

    def init(self, arg_list):
        self.new_radius_14 = arg_list.get_key_float('radius_14', None)
        self.new_epsilon_14 = arg_list.get_key_float('epsilon_14', None)
        self.new_radius = arg_list.get_key_float('radius', None)
        self.new_epsilon = arg_list.get_key_float('epsilon', None)
        self.mask = AmberMask(self.parm, arg_list.get_next_mask())

    def __str__(self):
        return 'Making atoms %s into a new LJ atom type' % self.mask

    def execute(self):
        from parmed.tools.addljtype import AddLJType
        sel_atms = self.mask.Selection()
        for i, atom in enumerate(self.parm.atoms):
            if sel_atms[i] == 1:
                break

        if self.new_radius is None:
            self.new_radius = self.parm.LJ_radius[(atom.nb_idx - 1)]
        else:
            self.new_radius = self.new_radius
        if self.new_epsilon is None:
            self.new_epsilon = self.parm.LJ_depth[(atom.nb_idx - 1)]
        else:
            self.new_epsilon = self.new_epsilon
        if self.new_radius_14 is None:
            if self.parm.chamber:
                self.new_radius_14 = self.parm.LJ_14_radius[(atom.nb_idx - 1)]
        if not self.parm.chamber:
            self.new_radius_14 = None
        if self.new_epsilon_14 is None:
            if self.parm.chamber:
                self.new_epsilon_14 = self.parm.LJ_14_depth[(atom.nb_idx - 1)]
        if not self.parm.chamber:
            self.new_epsilon_14 = None
        AddLJType(self.parm, sel_atms, self.new_radius, self.new_epsilon, self.new_radius_14, self.new_epsilon_14)
        self.parm.load_atom_info()


class outparm(parmout):
    __doc__ = '\n    Prints a new prmtop like parmout, but keeps its place in the action stack so\n    several can be written out in 1 parmed session\n    '
    usage = '<prmtop_name> [<inpcrd_name>] [netcdf]'


class printLJTypes(Action):
    __doc__ = '\n    Prints the Lennard Jones type index for the given atom mask or, if no value\n    is given, the LJ type index for each atom.\n    '
    usage = '[<mask>|<type idx>]'
    strictly_supported = (AmberParm, ChamberParm)

    def init(self, arg_list):
        try:
            self.mask = AmberMask(self.parm, arg_list.get_next_mask())
            self.type_list = None
            try_type = False
        except NoArgument:
            try_type = True

        if try_type:
            try:
                self.type_list = arg_list.get_next_string()
                self.mask = None
            except NoArgument:
                self.mask = AmberMask(self.parm, ':*')

        if self.mask is None:
            type_fields = self.type_list.strip().split(',')
            self.type_list = []
            for field in type_fields:
                if len(field.strip()) == 0:
                    continue
                if '-' in field:
                    begin = int(field.split('-')[0])
                    end = min(int(field.split('-')[1]), self.parm.ptr('ntypes'))
                    if begin <= 0 or end < begin or begin > self.parm.ptr('ntypes'):
                        raise ParmError('printLJTypes: Bad atom type range')
                    self.type_list.extend([i for i in range(begin, end + 1)])
                else:
                    idx = int(field)
                    if idx <= 0 or idx > self.parm.ptr('ntypes'):
                        raise ParmError('printLJTypes: Bad atom type index')
                    self.type_list.append(int(field))

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        if self.mask:
            selection = self.mask.Selection()
        else:
            if self.type_list:
                selection = [0 for atom in self.parm.atoms]
                for i, atom in enumerate(self.parm.atoms):
                    if atom.nb_idx in self.type_list:
                        selection[i] = 1

        if sum(selection) == 0:
            return 'Nothing to do for printLJTypes'
        else:
            indices = set()
            for i, atom in enumerate(self.parm.atoms):
                if selection[i] == 1:
                    indices.add(atom.nb_idx)

            string = '\n%15s %4s %4s\n' % ('  ATOM NUMBER  ', 'NAME', 'TYPE')
            string += '---------------------------------------------\n'
            for i, atom in enumerate(self.parm.atoms):
                if atom.nb_idx in indices:
                    string += 'ATOM %-10d %-4s %-4s: Type index: %d\n' % (i + 1, atom.name, atom.type,
                     atom.nb_idx)

            return string


class scee(Action):
    __doc__ = '\n    Sets the 1-4 EEL scaling factor in the prmtop\n    '
    usage = '<scee_value>'
    not_supported = (AmoebaParm,)

    def init(self, arg_list):
        self.scee_value = arg_list.get_next_float()

    def __str__(self):
        return 'Setting default SCEE electrostatic scaling value to %.4f' % self.scee_value

    def execute(self):
        for dt in self.parm.dihedral_types:
            dt.scee = self.scee_value

        if isinstance(self.parm, AmberParm):
            nptra = self.parm.ptr('nptra')
            if 'SCEE_SCALE_FACTOR' not in self.parm.flag_list:
                self.parm.add_flag('SCEE_SCALE_FACTOR', '5E16.8', data=[self.scee_value for i in range(nptra)])
            else:
                self.parm.parm_data['SCEE_SCALE_FACTOR'] = [self.scee_value for i in range(nptra)]


class scnb(Action):
    __doc__ = '\n    Sets the 1-4 VDW scaling factor in the prmtop\n    '
    usage = '<scnb_value>'
    not_supported = (AmoebaParm,)

    def init(self, arg_list):
        self.scnb_value = arg_list.get_next_float()

    def __str__(self):
        return 'Setting default SCNB van der Waals scaling value to %.4f' % self.scnb_value

    def execute(self):
        for dt in self.parm.dihedral_types:
            dt.scnb = self.scnb_value

        if isinstance(self.parm, AmberParm):
            nptra = self.parm.ptr('nptra')
            if 'SCNB_SCALE_FACTOR' not in self.parm.flag_list:
                self.parm.add_flag('SCNB_SCALE_FACTOR', '5E16.8', data=[self.scnb_value for i in range(nptra)])
            else:
                self.parm.parm_data['SCNB_SCALE_FACTOR'] = [self.scnb_value for i in range(nptra)]


class changeLJSingleType(Action):
    __doc__ = '\n    Allows you to change the radius/well depth of a single LJ type specified by\n    <mask>. Note, this may change more than the atoms selected in just the mask!\n    To find out what else will be changed, look at the output of printLJTypes.\n\n    Use addLJType to change the Lennard-Jones parameters on a set of specific\n    atoms.\n\n        - <mask> : The selection of atoms to change the LJ type for. All atoms\n                   selected must have the same LJ type\n        - <radius> : Rmin/2 (van der Waals radius of the new type)\n        - <depth> : Well-depth (a.k.a., epsilon)\n    '
    usage = '<mask> <radius> <depth>'
    strictly_supported = (AmberParm, ChamberParm)

    def init(self, arg_list):
        self.mask = AmberMask(self.parm, arg_list.get_next_mask())
        self.radius = arg_list.get_next_float()
        self.depth = arg_list.get_next_float()
        self.orig_radius = self.orig_depth = None
        selection = self.mask.Selection()
        if 1 in selection:
            first_loc = selection.index(1)
            attype = self.parm.atoms[first_loc].nb_idx
            self.orig_radius = self.parm.LJ_radius[(attype - 1)]
            self.orig_depth = self.parm.LJ_depth[(attype - 1)]

    def __str__(self):
        if sum(self.mask.Selection()) == 0:
            return 'No atoms selected in %s. Nothing to do.' % self.mask
        else:
            return 'Changing %s Lennard-Jones well depth from %.4f to %.4f (kal/mol) and radius from %.4f to %.4f (Angstroms)' % (
             self.mask, self.orig_depth, self.depth,
             self.orig_radius, self.radius)

    def execute(self):
        from math import sqrt
        from parmed.tools.exceptions import LJ_TypeError
        if self.orig_radius is None:
            return
        attype = None
        selection = self.mask.Selection()
        for i, atom in enumerate(self.parm.atoms):
            if selection[i] == 1:
                if attype is None:
                    attype = atom.nb_idx
                elif attype != atom.nb_idx:
                    raise LJ_TypeError('changeLJSingleType: Mask has multiple atom types!')

        self.parm.fill_LJ()
        self.parm.LJ_radius[attype - 1] = self.radius
        self.parm.LJ_depth[attype - 1] = self.depth
        ntypes = self.parm.ptr('NTYPES')
        for i in range(ntypes):
            lj_index = self.parm.parm_data['NONBONDED_PARM_INDEX'][(ntypes * i + attype - 1)] - 1
            rij = self.parm.LJ_radius[i] + self.radius
            wij = sqrt(self.parm.LJ_depth[i] * self.depth)
            acoef = wij * rij ** 12
            bcoef = 2 * wij * rij ** 6
            self.parm.parm_data['LENNARD_JONES_ACOEF'][lj_index] = acoef
            self.parm.parm_data['LENNARD_JONES_BCOEF'][lj_index] = bcoef


class printDetails(Action):
    __doc__ = '\n    Returns information about all atoms in a given mask\n    '
    usage = '<mask>'

    def init(self, arg_list):
        self.mask = AmberMask(self.parm, arg_list.get_next_mask())

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        selection = self.mask.Selection()
        retstr = ['\nThe mask %s matches %d atoms:\n\n' % (self.mask, sum(selection))]
        if isinstance(self.parm, AmoebaParm):
            retstr.append('%7s%7s%9s%6s%6s%7s%10s\n' % ('ATOM', 'RES', 'RESNAME', 'NAME',
                                                        'TYPE', 'At.#', 'Mass'))
            for i, atm in enumerate(self.parm.atoms):
                if not selection[i]:
                    pass
                else:
                    retstr.append('%7d%7d%9s%6s%6s%7d%10.4f\n' % (
                     i + 1, atm.residue.idx + 1, atm.residue.name, atm.name, atm.type,
                     atm.atomic_number, atm.mass))

        else:
            retstr.append('%7s%7s%9s%6s%6s%7s%12s%12s%10s%10s%10s%10s\n' % ('ATOM',
                                                                            'RES',
                                                                            'RESNAME',
                                                                            'NAME',
                                                                            'TYPE',
                                                                            'At.#',
                                                                            'LJ Radius',
                                                                            'LJ Depth',
                                                                            'Mass',
                                                                            'Charge',
                                                                            'GB Radius',
                                                                            'GB Screen'))
            for i, atm in enumerate(self.parm.atoms):
                if not selection[i]:
                    pass
                else:
                    retstr.append('%7d%7d%9s%6s%6s%7d%12.4f%12.4f%10.4f%10.4f%10.4f%10.4f\n' % (
                     i + 1, atm.residue.idx + 1, atm.residue.name, atm.name, atm.type,
                     atm.atomic_number, atm.rmin, atm.epsilon, atm.mass, atm.charge,
                     atm.solvent_radius, atm.screen))

        return ''.join(retstr)


class printFlags(Action):
    __doc__ = '\n    Prints all %FLAGs found in the topology file\n    '
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        pass

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        string = [
         '\n']
        string.extend('%%FLAG %s\n' % flag for flag in self.parm.flag_list)
        return ''.join(string)


class printPointers(Action):
    __doc__ = '\n    Prints a list of all the POINTERS and their values\n    '
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        pass

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        ptrs = self.parm.parm_data['POINTERS']
        ret_str = '\nNATOM (number of atoms in system)................= %d\nNTYPES (number of atom type names)...............= %d\nNBONH (number of bonds containing H).............= %d\nMBONA (number of bonds without H)................= %d\nNTHETH (number of angles containing H)...........= %d\nMTHETA (number of angles without H)..............= %d\nNPHIH (number of dihedrals containing H).........= %d\nMPHIA (number of dihedrals without H)............= %d\nNHPARM (currently unused)........................= %d\nNPARM (1 if made with addles, 0 if not)..........= %d\nNNB (number of excluded atoms)...................= %d\nNRES (number of residues in system)..............= %d\nNBONA (MBONA + constraint bonds).................= %d\nNTHETA (MTHETA + constraint angles)..............= %d\nNPHIA (MPHIA + constraint dihedrals).............= %d\nNUMBND (number of unique bond types).............= %d\nNUMANG (number of unique angle types)............= %d\nNPTRA (number of unique dihedral types)..........= %d\nNATYP (number of nonbonded atom types)...........= %d\nNPHB (number of distinct 10-12 H-bond pairs).....= %d\nIFPERT (1 if prmtop is perturbed; not used)......= %d\nNBPER (perturbed bonds; not used)................= %d\nNGPER (perturbed angles; not used)...............= %d\nNDPER (perturbed dihedrals; not used)............= %d\nMBPER (bonds in perturbed group; not used).......= %d\nMGPER (angles in perturbed group; not used)......= %d\nMDPER (diheds in perturbed group; not used)......= %d\nIFBOX (Type of box: 1=orthogonal, 2=not, 0=none).= %d\nNMXRS (number of atoms in largest residue).......= %d\nIFCAP (1 if solvent cap exists)..................= %d\nNUMEXTRA (number of extra points in topology)....= %d\n' % tuple(ptrs[:31])
        if len(ptrs) == 32:
            ret_str += 'NCOPY (number of PIMD slices/number of beads)....= %d\n' % ptrs[31]
        if self.parm.ptr('IFBOX'):
            ret_str += '\nSOLVENT POINTERS\n' + '\nIPTRES (Final solute residue)....................= %d\nNSPM (Total number of molecules).................= %d\nNSPSOL (The first solvent "molecule")............= %d\n' % (self.parm.parm_data['SOLVENT_POINTERS'][0],
             self.parm.parm_data['SOLVENT_POINTERS'][1],
             self.parm.parm_data['SOLVENT_POINTERS'][2])
        return ret_str


class setMolecules(Action):
    __doc__ = '\n    Determines the molecularity of the system based on the bonding network and\n    correctly determines the SOLVENT_POINTERS and ATOMS_PER_MOLECULE sections of\n    the topology file. It will consider the ions to be part of the solute if\n    True is passed or not if False is passed. Defaults to True.\n    '
    usage = '[solute_ions True|False]'
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        solute_ions = arg_list.get_key_string('solute_ions', None)
        if solute_ions is None:
            self.solute_ions = arg_list.get_next_string(optional=True)
        else:
            if solute_ions.lower() == 'true':
                self.solute_ions = True
            else:
                if solute_ions.lower() == 'false':
                    self.solute_ions = False
                else:
                    warnings.warn('Value of solute_ions is unrecognized [%s]! Assuming True' % solute_ions, SeriousParmWarning)
                    self.solute_ions = True

    def __str__(self):
        return 'Setting MOLECULE properties of the prmtop (SOLVENT_POINTERS and ATOMS_PER_MOLECULE)'

    def execute(self):
        owner = self.parm.rediscover_molecules(self.solute_ions)
        if owner is not None:
            if self.parm.coordinates is None:
                warnings.warn('The atoms in %s were reordered to correct molecule ordering. Any topology printed from now on will *not* work with the original inpcrd or trajectory files created with this prmtop! Consider quitting and loading a restart prior to using setMolecules' % self.parm, ParmWarning)
            self.parm.remake_parm()
        self.parm.load_pointers()


class changeProtState(Action):
    __doc__ = '\n    Changes the protonation state of a given titratable residue that can be\n    treated via constant pH MD in Amber.\n    '
    usage = '<mask> <state #>'
    strictly_supported = (AmberParm,)

    def init(self, arg_list):
        self.state = arg_list.get_next_int()
        self.mask = AmberMask(self.parm, arg_list.get_next_mask())

    def __str__(self):
        sel = self.mask.Selection()
        if sum(sel) == 0:
            return 'No residues selected for state change'
        else:
            res = self.parm.atoms[sel.index(1)].residue
            return 'Changing protonation state of residue %d (%s) to %d' % (res.idx + 1, res.name,
             self.state)

    @staticmethod
    def _add_ash_glh(residues):
        """
        Adds ASH and GLH to the titratable residue list unless it's already
        there
        """
        if 'ASH' in residues.titratable_residues:
            return
        dummyrefene1 = residues._ReferenceEnergy()
        dummyrefene1_old = residues._ReferenceEnergy()
        dummyrefene1_old.set_pKa(1.0)
        dummyrefene2 = residues._ReferenceEnergy()
        atomnames = ['N', 'H', 'CA', 'HA', 'CB', 'HB2', 'HB3', 'CG', 'OD1', 'OD2', 'HD21', 'C', 'O']
        ash = residues.TitratableResidue('ASH', atomnames, pka=4.0, typ='ph')
        ash.add_state(protcnt=0, refene=dummyrefene1, refene_old=dummyrefene1_old, pka_corr=0.0, charges=[
         -0.4157, 0.2719, 0.0341, 0.0864, -0.1783, -0.0122, -0.0122, 0.7994,
         -0.8014, -0.8014, 0.0, 0.5973, -0.5679])
        ash.add_state(protcnt=1, refene=dummyrefene2, refene_old=dummyrefene2, pka_corr=4.0, charges=[
         -0.4157, 0.2719, 0.0341, 0.0864, -0.0316, 0.0488, 0.0488, 0.6462,
         -0.5554, -0.6376, 0.4747, 0.5973, -0.5679])
        ash.check()
        atomnames = [
         'N', 'H', 'CA', 'HA', 'CB', 'HB2', 'HB3', 'CG', 'HG2', 'HG3', 'CD', 'OE1',
         'OE2', 'HE21', 'C', 'O']
        glh = residues.TitratableResidue('GLH', atomnames, pka=4.4, typ='ph')
        glh.add_state(protcnt=0, refene=dummyrefene1, refene_old=dummyrefene1_old, pka_corr=0.0, charges=[
         -0.4157, 0.2719, 0.0145, 0.0779, -0.0398, -0.0173, -0.0173, 0.0136,
         -0.0425, -0.0425, 0.8054, -0.8188, -0.8188, 0.0, 0.5973, -0.5679])
        glh.add_state(protcnt=1, refene=dummyrefene2, refene_old=dummyrefene2, pka_corr=4.4, charges=[
         -0.4157, 0.2719, 0.0145, 0.0779, -0.0071, 0.0256, 0.0256, -0.0174,
         0.043, 0.043, 0.6801, -0.5838, -0.6511, 0.4641, 0.5973, -0.5679])
        glh.check()
        residues.ASH, residues.GLH = ash, glh
        residues.titratable_residues.extend(['ASH', 'GLH'])

    def execute(self):
        from parmed.amber import titratable_residues as residues
        changeProtState._add_ash_glh(residues)
        sel = self.mask.Selection()
        if sum(sel) == 0:
            return
        residue = self.parm.atoms[sel.index(1)].residue
        resname = residue.name
        if resname not in residues.titratable_residues:
            raise ChangeStateError("Residue %s isn't defined as a titratable residue in titratable_residues.py" % resname)
        if not getattr(residues, resname).typ == 'ph':
            raise ChangeStateError('Redidue %s is not a pH titratable residue' % resname)
        res = getattr(residues, resname)
        if self.state >= len(res.states):
            raise ChangeStateError('Residue %s only has titratable states 0--%d. You chose state %d' % (
             resname, len(res.states) - 1, self.state))
        if sum(sel) != len(res.states[self.state].charges):
            raise ChangeStateError('You must select one and only one entire titratable residue')
        charges = res.states[self.state].charges
        for i, atom in enumerate(residue.atoms):
            if sel[atom.idx] != 1:
                raise ChangeStateError('You must select 1 and only 1 entire residue of which to change the protonation state')
            self.parm.parm_data['CHARGE'][atom.idx] = atom.charge = charges[i]


class changeRedoxState(Action):
    __doc__ = '\n    Changes the reduction state of a given titratable residue that can be\n    treated via constant redox potential MD in Amber.\n    '
    usage = '<mask> <state #>'
    strictly_supported = (AmberParm,)

    def init(self, arg_list):
        self.state = arg_list.get_next_int()
        self.mask = AmberMask(self.parm, arg_list.get_next_mask())

    def __str__(self):
        sel = self.mask.Selection()
        if sum(sel) == 0:
            return 'No residues selected for state change'
        else:
            res = self.parm.atoms[sel.index(1)].residue
            return 'Changing reduction state of residue %d (%s) to %d' % (res.idx + 1, res.name,
             self.state)

    def execute(self):
        from parmed.amber import titratable_residues as residues
        sel = self.mask.Selection()
        if sum(sel) == 0:
            return
        residue = self.parm.atoms[sel.index(1)].residue
        resname = residue.name
        if resname not in residues.titratable_residues:
            raise ChangeStateError("Residue %s isn't defined as a titratable residue in titratable_residues.py" % resname)
        if not getattr(residues, resname).typ == 'redox':
            raise ChangeStateError('Redidue %s is not a redox potential titratable residue' % resname)
        res = getattr(residues, resname)
        if self.state >= len(res.states):
            raise ChangeStateError('Residue %s only has titratable states 0--%d. You chose state %d' % (
             resname, len(res.states) - 1, self.state))
        if sum(sel) != len(res.states[self.state].charges):
            raise ChangeStateError('You must select one and only one entire titratable residue')
        charges = res.states[self.state].charges
        for i, atom in enumerate(residue.atoms):
            if sel[atom.idx] != 1:
                raise ChangeStateError('You must select 1 and only 1 entire residue of which to change the reduction state')
            self.parm.parm_data['CHARGE'][atom.idx] = atom.charge = charges[i]


class netCharge(Action):
    __doc__ = '\n    Prints the total charge of all of the atoms given by the mask. Defaults to all atoms\n    '
    usage = '[<mask>]'
    outfile = sys.stdout

    def init(self, arg_list):
        mask = arg_list.get_next_mask(optional=True)
        if mask is None:
            mask = ':*'
        self.mask = AmberMask(self.parm, mask)

    def __str__(self):
        return 'The net charge of %s is %.4f' % (self.mask,
         sum([self.parm.atoms[i].charge for i in self.mask.Selected()]))

    def execute(self):
        """ Calculates the charge of all atoms selected in mask """
        return sum([self.parm.atoms[i].charge for i in self.mask.Selected()])


class strip(Action):
    __doc__ = '\n    Deletes the atoms specified by <mask> from the topology file and rebuilds\n    the topology file according to the parameters that remain. If nobox is\n    provided, the unit cell information is discarded (useful when stripping\n    solvent to run an aperiodic implicit solvent calculation).\n    '
    usage = '<mask> [nobox]'

    def init(self, arg_list):
        self.mask = AmberMask(self.parm, arg_list.get_next_mask())
        self.nobox = arg_list.has_key('nobox')
        self.num_atoms = sum(self.mask.Selection())

    def __str__(self):
        retstr = [
         "Removing mask '%s' (%d atoms) from the topology file." % (
          self.mask, self.num_atoms)]
        if self.nobox:
            retstr.append('Deleting box info.')
        return ' '.join(retstr)

    def execute(self):
        self.parm.strip(self.mask)
        if self.nobox:
            self.parm.box = None


class defineSolvent(Action):
    __doc__ = '\n    Allows you to change what parmed will consider to be "solvent".\n    <residue list> must be a comma-separated set of residue names with no\n    spaces between them.\n    '
    usage = '<residue_list>'
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        from parmed import residue
        res_list = arg_list.get_next_string()
        res_list.replace(' ', '')
        if res_list.endswith(','):
            self.res_list = res_list[:len(res_list) - 1]
        else:
            self.res_list = res_list
        residue.SOLVENT_NAMES = self.res_list.split(',')

    def __str__(self):
        return 'Residues %s are now considered to be solvent' % self.res_list


class addExclusions(Action):
    __doc__ = '\n    Allows you to add arbitrary exclusions to the exclusion list. Every atom in\n    <mask2> is added to the exclusion list for each atom in <mask1> so that\n    non-bonded interactions between those atom pairs will not be computed. NOTE\n    that this ONLY applies to direct-space (short-range) non-bonded potentials.\n    For PME simulations, long-range electrostatics between these atom pairs are\n    still computed (in different unit cells).\n    '
    usage = '<mask1> <mask2>'
    not_supported = (AmoebaParm,)

    def init(self, arg_list):
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())

    def __str__(self):
        return 'Adding atoms from %s to exclusion lists of atoms in %s' % (
         self.mask2, self.mask1)

    def execute(self):
        for i in self.mask1.Selected():
            atm1 = self.parm.atoms[i]
            for j in self.mask2.Selected():
                atm2 = self.parm.atoms[j]
                if atm1 is atm2:
                    pass
                else:
                    atm1.exclude(atm2)
                self.parm.atoms.changed = True


class printBonds(Action):
    __doc__ = '\n    Prints all of the bonds (with their details) for the given atoms in the\n    mask. If a second mask is given, only bonds in which one atom appears in\n    *each* list will be printed. If coordinates and parameter types are present,\n    also print the actual distance (in Angstroms) and energy (in kcal/mol) for\n    each printed bond.\n    '
    usage = '[<mask> [<mask>] ]'

    def init(self, arg_list):
        mask = arg_list.get_next_mask(optional=True, default='*')
        self.mask = AmberMask(self.parm, mask)
        mask = arg_list.get_next_mask(optional=True, default='*')
        self.mask2 = AmberMask(self.parm, mask)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        retstr = [
         '%19s %19s %10s %10s' % ('Atom 1', 'Atom 2', 'R eq', 'Frc Cnst')]
        atomsel = set(self.mask.Selected())
        atomsel2 = set(self.mask2.Selected())
        do_measured = self.parm.coordinates is not None
        do_energy = all(b.type is not None for b in self.parm.bonds)
        if do_measured:
            retstr.append(' %10s' % 'Distance')
            if do_energy:
                retstr.append(' %10s' % 'Energy')
        retstr.append('\n')
        for bond in self.parm.bonds:
            atom1, atom2 = bond.atom1, bond.atom2
            found = False
            if atom1.idx in atomsel:
                if atom2.idx in atomsel2:
                    found = True
            if atom2.idx in atomsel:
                if atom1.idx in atomsel2:
                    found = True
            if not found:
                pass
            else:
                if bond.type is not None:
                    retstr.append('%7d %4s (%4s) %7d %4s (%4s) %10.4f %10.4f' % (
                     atom1.idx + 1, atom1.name, atom1.type, atom2.idx + 1,
                     atom2.name, atom2.type, bond.type.req, bond.type.k))
                else:
                    retstr.append('%7d %4s (%4s) %7d %4s (%4s) %-10s %-10s' % (
                     atom1.idx + 1, atom1.name, atom1.type, atom2.idx + 1,
                     atom2.name, atom2.type, 'N/A', 'N/A'))
                if do_measured:
                    retstr.append(' %10.4f' % bond.measure())
                    if do_energy:
                        retstr.append(' %10.4f' % bond.energy())
                retstr.append('\n')

        return ''.join(retstr)


class printAngles(Action):
    __doc__ = '\n    Prints all of the angles (with their details) for the given atoms in the\n    mask. If a second mask is given, only atoms whose central atom is in the\n    second mask and another atom is in the first mask is printed. If a third\n    mask is given, the central atom must be in the second mask and the other two\n    atoms must appear in the first *and* third masks (in any order).\n\n    If coordinates and parameter types are present, the value of the angle (in\n    degrees) and its energy (in kcal/mol) are reported for each printed angle.\n    '
    usage = '[<mask> [<mask> [<mask>] ] ]'

    def init(self, arg_list):
        mask = arg_list.get_next_mask(optional=True, default=':*')
        self.mask = AmberMask(self.parm, mask)
        arg2 = arg_list.get_next_mask(optional=True)
        arg3 = arg_list.get_next_mask(optional=True)
        if arg2 is None:
            self.one_arg = True
        else:
            self.one_arg = False
            self.mask2 = AmberMask(self.parm, arg2)
            if arg3 is None:
                arg3 = '*'
            self.mask3 = AmberMask(self.parm, arg3)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        retstr = [
         '%19s  %19s  %19s %10s %10s' % ('Atom 1', 'Atom 2', 'Atom 3', 'Frc Cnst', 'Theta eq')]
        do_measured = self.parm.coordinates is not None
        do_energy = all(a.type is not None for a in self.parm.angles)
        if do_measured:
            retstr.append(' %10s' % 'Angle')
            if do_energy:
                retstr.append(' %10s' % 'Energy')
        retstr.append('\n')
        if self.one_arg:
            atomsel = self.mask.Selection()
            for angle in self.parm.angles:
                atom1, atom2, atom3 = angle.atom1, angle.atom2, angle.atom3
                if not (atomsel[atom1.idx] or atomsel[atom2.idx] or atomsel[atom3.idx]):
                    pass
                else:
                    if angle.type is not None:
                        retstr.append('%7d %4s (%4s)  %7d %4s (%4s)  %7d %4s (%4s) %10.4f %10.4f' % (
                         atom1.idx + 1, atom1.name,
                         atom1.type, atom2.idx + 1, atom2.name, atom2.type,
                         atom3.idx + 1, atom3.name, atom3.type, angle.type.k,
                         angle.type.theteq))
                    else:
                        retstr.append('%7d %4s (%4s)  %7d %4s (%4s)  %7d %4s (%4s) %-10s %-10s' % (
                         atom1.idx + 1, atom1.name,
                         atom1.type, atom2.idx + 1, atom2.name, atom2.type,
                         atom3.idx + 1, atom3.name, atom3.type, 'N/A', 'N/A'))
                    if do_measured:
                        retstr.append(' %10.4f' % angle.measure())
                        if do_energy:
                            retstr.append(' %10.4f' % angle.energy())
                    retstr.append('\n')

        else:
            atomsel = set(self.mask.Selected())
            atomsel2 = set(self.mask2.Selected())
            atomsel3 = set(self.mask3.Selected())
            for angle in self.parm.angles:
                atom1, atom2, atom3 = angle.atom1, angle.atom2, angle.atom3
                if atom2.idx not in atomsel2:
                    continue
                if atom1.idx not in atomsel:
                    if atom1.idx not in atomsel3:
                        continue
                found = False
                if atom1.idx in atomsel:
                    if atom3.idx in atomsel3:
                        found = True
                if atom3.idx in atomsel:
                    if atom1.idx in atomsel3:
                        found = True
                if not found:
                    pass
                else:
                    if angle.type is not None:
                        retstr.append('%7d %4s (%4s)  %7d %4s (%4s)  %7d %4s (%4s) %10.4f %10.4f' % (
                         atom1.idx + 1, atom1.name,
                         atom1.type, atom2.idx + 1, atom2.name, atom2.type,
                         atom3.idx + 1, atom3.name, atom3.type, angle.type.k,
                         angle.type.theteq))
                    else:
                        retstr.append('%7d %4s (%4s)  %7d %4s (%4s)  %7d %4s (%4s) %-10s %-10s' % (
                         atom1.idx + 1, atom1.name,
                         atom1.type, atom2.idx + 1, atom2.name, atom2.type,
                         atom3.idx + 1, atom3.name, atom3.type, 'N/A', 'N/A'))
                    if do_measured:
                        retstr.append(' %10.4f' % angle.measure())
                        if do_energy:
                            retstr.append(' %10.4f' % angle.energy())
                    retstr.append('\n')

        return ''.join(retstr)


class printDihedrals(Action):
    __doc__ = '\n    Prints all of the dihedrals (with their details) for the given atoms in the\n    mask. If multiple masks are given, only dihedrals that have one atom in each\n    mask are printed. Ordering is important here, so the first atom must be in\n    the first mask, the second atom in the second, etc. The order can be\n    precisely reversed, but no other ordering is recognized.\n\n    If coordinates and parameter types are present, the value of the torsion\n    angle (in degrees) and the energy of each dihedral (in kcal/mol) are\n    reported for each printed dihedral.\n    '
    usage = '[<mask> [<mask> [<mask> [<mask>] ] ] ]'

    def init(self, arg_list):
        mask = arg_list.get_next_mask(optional=True, default=':*')
        self.mask = AmberMask(self.parm, mask)
        arg2 = arg_list.get_next_mask(optional=True)
        arg3 = arg_list.get_next_mask(optional=True)
        arg4 = arg_list.get_next_mask(optional=True)
        if arg2 is None:
            self.one_mask = True
        else:
            self.one_mask = False
            self.mask2 = AmberMask(self.parm, arg2)
            if arg3 is None:
                arg3 = '*'
            self.mask3 = AmberMask(self.parm, arg3)
            if arg4 is None:
                arg4 = '*'
            self.mask4 = AmberMask(self.parm, arg4)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        retstr = [
         '%21s  %19s  %19s  %19s %10s %10s %10s %10s %10s' % ('Atom 1', 'Atom 2', 'Atom 3',
                                                     'Atom 4', 'Height', 'Periodic.',
                                                     'Phase', 'EEL Scale', 'VDW Scale')]
        do_measured = self.parm.coordinates is not None
        do_energy = all(isinstance(d.type, (DihedralType, DihedralTypeList)) for d in self.parm.dihedrals)
        if do_measured:
            retstr.append(' %10s' % 'Dihedral')
            if do_energy:
                retstr.append(' %10s' % 'Energy')
        retstr.append('\n')
        if self.one_mask:
            atomsel = self.mask.Selection()
            for dihedral in self.parm.dihedrals:
                atom1 = dihedral.atom1
                atom2 = dihedral.atom2
                atom3 = dihedral.atom3
                atom4 = dihedral.atom4
                if not (atomsel[atom1.idx] or atomsel[atom2.idx] or atomsel[atom3.idx] or atomsel[atom4.idx]):
                    pass
                else:
                    if isinstance(self.parm, AmoebaParm):
                        char = ' '
                        scee = scnb = 'N/A'
                        k = '%10.4f' % dihedral.type.phi_k
                        per = '%10.4f' % dihedral.type.per
                        phase = '%10.4f' % dihedral.type.phase
                    else:
                        if dihedral.improper:
                            char = 'I'
                            if dihedral.type is not None:
                                scee = '%10.4f' % dihedral.type.scee
                                scnb = '%10.4f' % dihedral.type.scnb
                                k = '%10.4f' % dihedral.type.phi_k
                                per = '%10.4f' % dihedral.type.per
                                phase = '%10.4f' % dihedral.type.phase
                            else:
                                scee = scnb = k = per = phase = 'N/A'
                        else:
                            if dihedral.ignore_end:
                                char = 'M'
                                if dihedral.type is not None:
                                    scee = '%10.4f' % dihedral.type.scee
                                    scnb = '%10.4f' % dihedral.type.scnb
                                    k = '%10.4f' % dihedral.type.phi_k
                                    per = '%10.4f' % dihedral.type.per
                                    phase = '%10.4f' % dihedral.type.phase
                                else:
                                    scee = scnb = k = per = phase = 'N/A'
                            else:
                                char = ' '
                                if dihedral.type is not None:
                                    scee = '%10.4f' % dihedral.type.scee
                                    scnb = '%10.4f' % dihedral.type.scnb
                                    k = '%10.4f' % dihedral.type.phi_k
                                    per = '%10.4f' % dihedral.type.per
                                    phase = '%10.4f' % dihedral.type.phase
                                else:
                                    scee = scnb = k = per = phase = 'N/A'
                    retstr.append('%1s %7d %4s (%4s)  %7d %4s (%4s)  %7d %4s (%4s)  %7d %4s (%4s) %10s %10s %10s %10s %10s' % (
                     char, atom1.idx + 1, atom1.name, atom1.type, atom2.idx + 1,
                     atom2.name, atom2.type, atom3.idx + 1, atom3.name,
                     atom3.type, atom4.idx + 1, atom4.name, atom4.type,
                     k, per, phase, scee, scnb))
                    if do_measured:
                        retstr.append(' %10.4f' % dihedral.measure())
                        if do_energy:
                            retstr.append(' %10.4f' % dihedral.energy())
                    retstr.append('\n')

        else:
            atomsel = set(self.mask.Selected())
            atomsel2 = set(self.mask2.Selected())
            atomsel3 = set(self.mask3.Selected())
            atomsel4 = set(self.mask4.Selected())
            for dihedral in self.parm.dihedrals:
                atom1 = dihedral.atom1
                atom2 = dihedral.atom2
                atom3 = dihedral.atom3
                atom4 = dihedral.atom4
                if atom1.idx not in atomsel:
                    if atom1.idx not in atomsel4:
                        continue
                found = False
                if atom1.idx in atomsel:
                    if atom2.idx in atomsel2:
                        if atom3.idx in atomsel3:
                            if atom4.idx in atomsel4:
                                found = True
                if atom1.idx in atomsel4:
                    if atom2.idx in atomsel3:
                        if atom3.idx in atomsel2:
                            if atom4.idx in atomsel:
                                found = True
                if not found:
                    pass
                else:
                    if isinstance(self.parm, AmoebaParm):
                        char = ' '
                        scee = scnb = 'N/A'
                        k = '%10.4f' % dihedral.type.phi_k
                        per = '%10.4f' % dihedral.type.per
                        phase = '%10.4f' % dihedral.type.phase
                    else:
                        if dihedral.improper:
                            char = 'I'
                            if dihedral.type is not None:
                                scee = '%10.4f' % dihedral.type.scee
                                scnb = '%10.4f' % dihedral.type.scnb
                                k = '%10.4f' % dihedral.type.phi_k
                                per = '%10.4f' % dihedral.type.per
                                phase = '%10.4f' % dihedral.type.phase
                            else:
                                scee = scnb = k = per = phase = 'N/A'
                        else:
                            if dihedral.ignore_end:
                                char = 'M'
                                if dihedral.type is not None:
                                    scee = '%10.4f' % dihedral.type.scee
                                    scnb = '%10.4f' % dihedral.type.scnb
                                    k = '%10.4f' % dihedral.type.phi_k
                                    per = '%10.4f' % dihedral.type.per
                                    phase = '%10.4f' % dihedral.type.phase
                                else:
                                    scee = scnb = k = per = phase = 'N/A'
                            else:
                                char = ' '
                                if dihedral.type is not None:
                                    scee = '%10.4f' % dihedral.type.scee
                                    scnb = '%10.4f' % dihedral.type.scnb
                                    k = '%10.4f' % dihedral.type.phi_k
                                    per = '%10.4f' % dihedral.type.per
                                    phase = '%10.4f' % dihedral.type.phase
                                else:
                                    scee = scnb = k = per = phase = 'N/A'
                    retstr.append('%1s %7d %4s (%4s)  %7d %4s (%4s)  %7d %4s (%4s)  %7d %4s (%4s) %10s %10s %10s %10s %10s' % (
                     char, atom1.idx + 1, atom1.name,
                     atom1.type, atom2.idx + 1, atom2.name, atom2.type,
                     atom3.idx + 1, atom3.name, atom3.type, atom4.idx + 1,
                     atom4.name, atom4.type, k, per, phase, scee, scnb))
                    if do_measured:
                        retstr.append(' %10.4f' % dihedral.measure())
                        if do_energy:
                            retstr.append(' %10.4f' % dihedral.energy())
                    retstr.append('\n')

        return ''.join(retstr)


class setBond(Action):
    __doc__ = '\n    Changes (or adds a non-existent) bond in the topology file. Each mask must\n    select the same number of atoms, and a bond will be placed between the\n    atoms in mask1 and mask2 (one bond between atom1 from mask1 and atom1\n    from mask2 and another bond between atom2 from mask1 and atom2 from mask2,\n    etc.)\n\n        - <mask1> : Selection of first atoms in each bond\n        - <mask2> : Selection of second atoms in each bond\n        - <k> : Force constant (kcal/mol/A^2) in energy expression k(R-Req)^2\n        - <Req> : Equilibrium distance (A)\n    '
    usage = '<mask1> <mask2> <k> <Req>'
    not_supported = (AmoebaParm,)

    def init(self, arg_list):
        self.k = arg_list.get_next_float()
        self.req = arg_list.get_next_float()
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())

    def __str__(self):
        return 'Set a bond between %s and %s with k = %f kcal/(mol Angstrom**2) and Req = %f Angstroms' % (
         self.mask1, self.mask2,
         self.k, self.req)

    def execute(self):
        sel1 = self.mask1.Selection()
        sel2 = self.mask2.Selection()
        if sum(sel1) != sum(sel2):
            raise SetParamError('setBond: Each mask must select the same number of atoms!')
        if sum(sel1) == 0:
            return
        new_bnd_typ = BondType(self.k, self.req)
        exists = False
        for bnd_typ in self.parm.bond_types:
            if new_bnd_typ == bnd_typ:
                new_bnd_typ = bnd_typ
                exists = True
                break

        if not exists:
            self.parm.bond_types.append(new_bnd_typ)
            new_bnd_typ.list = self.parm.bond_types
        atnum1, atnum2 = (-1, -1)
        for it in range(sum(sel1)):
            atnum1 = sel1.index(1, atnum1 + 1)
            atnum2 = sel2.index(1, atnum2 + 1)
            atm1 = self.parm.atoms[atnum1]
            atm2 = self.parm.atoms[atnum2]
            if atm2 in atm1.bond_partners and atm1 in atm2.bond_partners:
                for bond in atm1.bonds:
                    if atm2 in bond:
                        bond.type = new_bnd_typ
                        self.parm.bonds.changed = True
                        break

            else:
                self.parm.bonds.append(Bond(atm1, atm2, new_bnd_typ))

        self.parm.update_dihedral_exclusions()


class setAngle(Action):
    __doc__ = '\n    Changes (or adds a non-existent) angle in the topology file. Each mask must\n    select the same number of atoms, and an angle will be placed between the\n    atoms in mask1, mask2, and mask3 (one angle between atom1 from mask1, atom1\n    from mask2, and atom1 from mask3, another angle between atom2 from mask1,\n    atom2 from mask2, and atom2 from mask3, etc.)\n\n        - <mask1> : The selection of one of the end-atoms in each angle\n        - <mask2> : The selection of central atoms in each angle\n        - <mask3> : The selection of other end-atoms in each angle\n        - <k> : Force constant in kcal/mol/radians^2 in energy expression\n                k(THET - THETeq)^2\n        - <THETeq> : Equilibrium angle (in *degrees*)\n    '
    usage = '<mask1> <mask2> <mask3> <k> <THETeq>'
    not_supported = (AmoebaParm,)

    def init(self, arg_list):
        self.k = arg_list.get_next_float()
        self.theteq = arg_list.get_next_float()
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask3 = AmberMask(self.parm, arg_list.get_next_mask())

    def __str__(self):
        return 'Set an angle between %s, %s and %s with k = %f kcal/(mol rad**2) and THETeq = %f degrees' % (
         self.mask1, self.mask2,
         self.mask3, self.k, self.theteq)

    def execute(self):
        sel1 = self.mask1.Selection()
        sel2 = self.mask2.Selection()
        sel3 = self.mask3.Selection()
        if sum(sel1) != sum(sel2) or sum(sel1) != sum(sel3):
            raise SetParamError('Each mask in setAngle must select the same number of atoms!')
        if sum(sel1) == 0:
            return
        new_ang_typ = AngleType(self.k, self.theteq)
        exists = False
        for ang_typ in self.parm.angle_types:
            if new_ang_typ == ang_typ:
                new_ang_typ = ang_typ
                exists = True
                break

        if not exists:
            self.parm.angle_types.append(new_ang_typ)
            new_ang_typ.list = self.parm.angle_types
        atnum1, atnum2, atnum3 = (-1, -1, -1)
        for it in range(sum(sel1)):
            atnum1 = sel1.index(1, atnum1 + 1)
            atnum2 = sel2.index(1, atnum2 + 1)
            atnum3 = sel3.index(1, atnum3 + 1)
            atm1 = self.parm.atoms[atnum1]
            atm2 = self.parm.atoms[atnum2]
            atm3 = self.parm.atoms[atnum3]
            found = False
            if atm1 in atm3.angle_partners:
                for ang in atm1.angles:
                    if atm2 in ang and atm3 in ang:
                        ang.type = new_ang_typ
                        self.parm.angles.changed = True
                        found = True
                        break

            if not found:
                self.parm.angles.append(Angle(atm1, atm2, atm3, new_ang_typ))

        self.parm.update_dihedral_exclusions()


class addDihedral(Action):
    __doc__ = '\n    Adds a dihedral between mask1, mask2, mask3, and mask4. Each mask must\n    specify the same number of atoms, and the dihedral is defined around the\n    bond between atoms in mask 2 and 3. If each mask selects 2 atoms, for\n    instance, a dihedral will be placed around atom1 in mask 1, atom1 in mask 2,\n    atom1 in mask 3, and atom1 in mask 4.  A second dihedral will be placed\n    around atom2 in mask 1, atom2 in mask 2, atom2 in mask 3, and atom2 in\n    mask4.\n\n        - <mask1> : Selection of one of the end-atoms for each dihedral\n        - <mask2> : Selection of the middle atom bonded to <mask1> and\n                    <mask3> in each dihedral\n        - <mask3> : Selection of the other middle atom bonded to <mask2>\n                    and <mask4>\n        - <mask4> : Selection of the other end-atom in each dihedral\n        - <phi_k> : Force constant in kcal/mol\n        - <per> : Periodicity\n        - <phase> : Torsion phase shift\n        - <scnb> : 1-4 Lennard-Jones scaling constant (default 2.0)\n        - <scee> : 1-4 electrostatic scaling constant (default 1.2)\n        - <type> : Type of dihedral, either "improper" or "normal".\n                   Default is "normal"\n    '
    usage = '<mask1> <mask2> <mask3> <mask4> <phi_k> <per> <phase> [<scee>] [<scnb>] [type <type>]'
    not_supported = (
     AmoebaParm,)

    def init(self, arg_list):
        self.phi_k = arg_list.get_next_float()
        self.per = arg_list.get_next_float()
        self.phase = arg_list.get_next_float()
        self.scee = arg_list.get_next_float(optional=True, default=1.2)
        self.scnb = arg_list.get_next_float(optional=True, default=2.0)
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask3 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask4 = AmberMask(self.parm, arg_list.get_next_mask())
        dihed_type = arg_list.get_key_string('type', 'normal')
        if dihed_type.lower() == 'normal'[:len(dihed_type)]:
            self.improper = False
            self.type = 'a normal'
        else:
            if dihed_type.lower() == 'improper'[:len(dihed_type)]:
                self.improper = True
                self.type = 'an improper'
            else:
                raise InputError('addDihedral: type must be "normal" or "improper"')

    def __str__(self):
        return 'Set %s dihedral between %s, %s, %s, and %s with phi_k = %f kcal/mol periodicity = %f phase = %f degrees scee = %f scnb = %f' % (
         self.type, self.mask1, self.mask2, self.mask3, self.mask4,
         self.phi_k, self.per, self.phase, self.scee, self.scnb)

    def execute(self):
        sel1 = self.mask1.Selection()
        sel2 = self.mask2.Selection()
        sel3 = self.mask3.Selection()
        sel4 = self.mask4.Selection()
        if sum(sel1) != sum(sel2) or sum(sel1) != sum(sel3) or sum(sel1) != sum(sel4):
            raise SetParamError('addDihedral: Each mask must select the same number of atoms!')
        if sum(sel1) == 0:
            return
        new_dih_typ = DihedralType(self.phi_k, self.per, self.phase, self.scee, self.scnb)
        exists = False
        for dih_typ in self.parm.dihedral_types:
            if new_dih_typ == dih_typ:
                new_dih_typ = dih_typ
                exists = True
                break

        if not exists:
            self.parm.dihedral_types.append(new_dih_typ)
            new_dih_typ.list = self.parm.dihedral_types
        atnum1, atnum2, atnum3, atnum4 = (-1, -1, -1, -1)
        for it in range(sum(sel1)):
            atnum1 = sel1.index(1, atnum1 + 1)
            atnum2 = sel2.index(1, atnum2 + 1)
            atnum3 = sel3.index(1, atnum3 + 1)
            atnum4 = sel4.index(1, atnum4 + 1)
            atm1 = self.parm.atoms[atnum1]
            atm2 = self.parm.atoms[atnum2]
            atm3 = self.parm.atoms[atnum3]
            atm4 = self.parm.atoms[atnum4]
            if atm1 is atm2 or atm1 is atm3 or atm1 is atm4 or atm2 is atm3 or atm2 is atm4 or atm3 is atm4:
                raise SetParamError('addDihedral: Duplicate atoms found!')
            ignore_end = atm1 in atm4.bond_partners or atm1 in atm4.angle_partners or atm1 in atm4.dihedral_partners
            self.parm.dihedrals.append(Dihedral(atm1, atm2, atm3, atm4, improper=(self.improper), ignore_end=ignore_end,
              type=new_dih_typ))


class addAtomicNumber(Action):
    __doc__ = '\n    Adds the atomic number of each atom to a new section titled "ATOMIC_NUMBER"\n    in the topology file. Elements are identified by the atomic mass found in\n    the MASS section of the topology files.  Elements are matched by picking the\n    element whose average atomic mass in the periodic table is closest to each\n    atom, which should work appropriately for all isotopes of all atoms, except\n    possibly Tritium\n    '
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        if self.parm.amoeba:
            self.present = 'AMOEBA_ATOMIC_NUMBER' in self.parm.flag_list
        else:
            self.present = 'ATOMIC_NUMBER' in self.parm.flag_list

    def __str__(self):
        if self.present:
            return 'ATOMIC_NUMBER already in [%s] -- Doing nothing.' % self.parm
        else:
            return 'Adding ATOMIC_NUMBER to [%s]' % self.parm

    def execute(self):
        if self.present:
            return
        else:
            if self.parm.amoeba:
                self.parm.add_flag('AMOEBA_ATOMIC_NUMBER', '10I8', num_items=(len(self.parm.atoms)))
                flag = 'AMOEBA_ATOMIC_NUMBER'
            else:
                self.parm.add_flag('ATOMIC_NUMBER', '10I8', num_items=(len(self.parm.atoms)))
                flag = 'ATOMIC_NUMBER'
        for i, atm in enumerate(self.parm.atoms):
            self.parm.parm_data[flag][i] = atm.atomic_number


class deleteDihedral(Action):
    __doc__ = '\n    Deletes the dihedral around <mask2> and <mask3> in which the end-groups are\n    <mask1> and <mask4>. For multi-term dihedrals, it removes each term.\n    '
    usage = '<mask1> <mask2> <mask3> <mask4>'
    not_supported = (AmoebaParm,)

    def init(self, arg_list):
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask3 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask4 = AmberMask(self.parm, arg_list.get_next_mask())
        if sum(self.mask1.Selection()) != sum(self.mask2.Selection()) or sum(self.mask1.Selection()) != sum(self.mask3.Selection()) or sum(self.mask1.Selection()) != sum(self.mask4.Selection()):
            raise DeleteDihedralError('All masks must select the same number of atoms!. They selected %d, %d, %d, and %d, respectively' % (
             sum(self.mask1.Selection()), sum(self.mask2.Selection()),
             sum(self.mask3.Selection()), sum(self.mask4.Selection())))

    def __str__(self):
        if sum(self.mask1.Selection()) == 0:
            return 'No specified dihedrals to delete'
        else:
            return 'Deleting dihedral terms involving [%s]-[%s]-[%s]-[%s] (At most %d total, distinct, dihedrals)' % (
             self.mask1, self.mask2, self.mask3, self.mask4,
             sum(self.mask1.Selection()))

    def execute(self):
        """ Returns the total number of dihedrals deleted """
        sel1, sel2 = self.mask1.Selection(), self.mask2.Selection()
        sel3, sel4 = self.mask3.Selection(), self.mask4.Selection()
        if sum(sel1) == 0:
            return
        else:
            deleting_dihedrals = []
            atnum1 = atnum2 = atnum3 = atnum4 = -1
            total_diheds = 0
            for i in range(sum(sel1)):
                atnum1 = sel1.index(1, atnum1 + 1)
                atnum2 = sel2.index(1, atnum2 + 1)
                atnum3 = sel3.index(1, atnum3 + 1)
                atnum4 = sel4.index(1, atnum4 + 1)
                atm1 = self.parm.atoms[atnum1]
                atm2 = self.parm.atoms[atnum2]
                atm3 = self.parm.atoms[atnum3]
                atm4 = self.parm.atoms[atnum4]
                if atm1 is atm2 or atm1 is atm3 or atm1 is atm4 or atm2 is atm3 or atm2 is atm4 or atm3 is atm4:
                    warnings.warn('Skipping %d-%d-%d-%d dihedral deletion -- duplicate atoms!' % (
                     atnum1, atnum2, atnum3, atnum4), SeriousParmWarning)
                else:
                    proposed_dihedral = (
                     atnum1, atnum2, atnum3, atnum4)
                    for j, dihed in enumerate(self.parm.dihedrals):
                        if dihed.same_atoms(proposed_dihedral):
                            total_diheds += 1
                            deleting_dihedrals.append(j)

            if not deleting_dihedrals:
                return 0
            deleting_dihedrals.sort()
            while deleting_dihedrals:
                idx = deleting_dihedrals.pop()
                self.parm.dihedrals[idx].delete()
                del self.parm.dihedrals[idx]

            return total_diheds


class printLJMatrix(Action):
    __doc__ = '\n    This function prints out how every atom type interacts with the atom type(s)\n    in <mask>. The atom types are printed as all type names that have at least\n    one atom with the Lennard Jones index given in square brackets at the end.\n    Alternatively, you can request a particular atom type index\n    '
    usage = '<mask>|<index>'
    strictly_supported = (AmberParm, ChamberParm)

    def init(self, arg_list):
        self.idx = arg_list.get_next_int(optional=True)
        self.mask = None
        if self.idx is None:
            self.mask = AmberMask(self.parm, arg_list.get_next_mask())

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        has_1264 = hasattr(self.parm, 'parm_data') and 'LENNARD_JONES_CCOEF' in self.parm.parm_data
        ntypes = self.parm.ptr('NTYPES')
        ret_str = []
        if self.idx is not None:
            sel = [0 for i in self.parm.atoms]
            for i, atom in enumerate(self.parm.atoms):
                if atom.nb_idx == self.idx:
                    sel[i] = 1

        else:
            sel = self.mask.Selection()
        if sum(sel) == 0:
            return 'No atom types selected'
        else:
            typenames = [set() for i in range(self.parm.ptr('NTYPES'))]
            for i, atom in enumerate(self.parm.atoms):
                typenames[(atom.nb_idx - 1)].add(atom.type)

            sel_types = set()
            for i, atom in enumerate(self.parm.atoms):
                if sel[i] == 0:
                    pass
                else:
                    sel_types.add(atom.nb_idx)

            sel_types = sorted(list(sel_types))
            maxlen = 0
            for i, names in enumerate(typenames):
                typenames[i] = ','.join(sorted(list(names))) + ' [%d]' % (i + 1)
                maxlen = max(maxlen, len(typenames[i]))

            if has_1264:
                fmt = '\n%%%ds %%%ds %%15s %%15s %%15s %%10s %%10s' % (maxlen, maxlen)
                args = ('Atom Type 1', 'Atom Type 2', 'A coefficient', 'B coefficient',
                        'C coefficient', 'R i,j', 'Eps i,j')
            else:
                fmt = '\n%%%ds %%%ds %%15s %%15s %%10s %%10s' % (maxlen, maxlen)
                args = ('Atom Type 1', 'Atom Type 2', 'A coefficient', 'B coefficient',
                        'R i,j', 'Eps i,j')
            ret_str.append(fmt % args)
            ret_str.extend(['\n', '-' * len(ret_str[(-1)]), '\n'])
            for ty in sel_types:
                for ty2 in range(1, ntypes + 1):
                    type1, type2 = min(ty, ty2), max(ty, ty2)
                    idx = self.parm.parm_data['NONBONDED_PARM_INDEX'][(ntypes * (type1 - 1) + type2 - 1)]
                    acoef = self.parm.parm_data['LENNARD_JONES_ACOEF'][(idx - 1)]
                    bcoef = self.parm.parm_data['LENNARD_JONES_BCOEF'][(idx - 1)]
                    if has_1264:
                        ccoef = self.parm.parm_data['LENNARD_JONES_CCOEF'][(idx - 1)]
                    if bcoef == 0 or acoef == 0:
                        rij = eij = 0.0
                    else:
                        rij = (2 * acoef / bcoef) ** 0.16666666666666666
                        eij = bcoef * bcoef / (4 * acoef)
                    if has_1264:
                        ret_str.append('%%%ds %%%ds %%15.6f %%15.6f %%15.6f %%10.6f %%10.6f\n' % (maxlen, maxlen) % (
                         typenames[(type1 - 1)], typenames[(type2 - 1)],
                         acoef, bcoef, ccoef, rij, eij))
                    else:
                        ret_str.append('%%%ds %%%ds %%15.6f %%15.6f %%10.6f %%10.6f\n' % (maxlen, maxlen) % (
                         typenames[(type1 - 1)], typenames[(type2 - 1)],
                         acoef, bcoef, rij, eij))

            return ''.join(ret_str)


class tiMerge(Action):
    __doc__ = '\n    Merges molecules removing redundant bonding terms.  Input amber masks\n    corresponding to molecules 1/2 <mol1mask>/<mol2mask>, and the soft core\n    atoms in each molecule as <scmask1>/<scmask2>. The input topology can be\n    created using leap, with the two molecules to be merged adjacent to each\n    other in residue number. This improves the efficiency for pmemd TI when only\n    part of a molecule is being perturbed.\n\n    <scmask1/2N> are for softcore molecules that are not going to be merged.\n    These options will just add these atoms to the timask output, correcting for\n    any changes in atom number.\n\n    This can also be used for non-softcore simulations, where\n    <scmask1>/<scmask2> represent the perturbed atoms. The output will give the\n    scmask1/scmask2 flags, which can just be ignored.\n\n    <tol> is the tolerence to use when matching coordinates (default 0.01).\n    This is used when the atoms in molecules 1/2 are not in the same order and\n    for checking the input coordinates.\n    '
    usage = '<mol1mask> <mol2mask> <scmask1> <scmask2> [<scmask1N>] [<scmask2N>] [tol <tol>]'
    strictly_supported = (AmberParm, ChamberParm)
    output = sys.stdout

    def init(self, arg_list):
        self.tol = arg_list.get_key_float('tol', 0.01)
        self.molmask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.molmask2 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())
        self.sc_mask1 = ''
        self.sc_mask2 = ''
        molmask1N = arg_list.get_next_mask(optional=True)
        if molmask1N is not None:
            self.molmask1N = AmberMask(self.parm, molmask1N)
        else:
            self.molmask1N = None
        molmask2N = arg_list.get_next_mask(optional=True)
        if molmask2N is not None:
            self.molmask2N = AmberMask(self.parm, molmask2N)
        else:
            self.molmask2N = None

    def __str__(self):
        return 'Merging molecules [%s] [%s] with sc mask [%s] [%s]' % (
         self.molmask1, self.molmask2, self.mask1, self.mask2)

    def execute(self):
        sel1 = self.mask1.Selection()
        sel2 = self.mask2.Selection()
        molsel1 = self.molmask1.Selection()
        molsel2 = self.molmask2.Selection()
        natom = len(self.parm.atoms)
        if self.molmask1N is not None:
            molsel1N = self.molmask1N.Selection()
        else:
            molsel1N = [0 for i in range(natom)]
        if self.molmask2N is not None:
            molsel2N = self.molmask2N.Selection()
        else:
            molsel2N = [0 for i in range(natom)]
        for i in range(natom):
            if sel1[i]:
                if not molsel1[i]:
                    raise TiMergeError('scmask1 must be a subset of mol1mask.')
                else:
                    if sel2[i]:
                        if not molsel2[i]:
                            raise TiMergeError('scmask2 must be a subset of mol2mask.')
                    if molsel1[i]:
                        if molsel2[i]:
                            raise TiMergeError('mol1mask can not overlap with mol2mask.')
                if i < natom - 1 and molsel1[i] and not (molsel1[(i + 1)] or molsel2[(i + 1)]):
                    raise TiMergeError('mol1mask and mol2mask must be adjacent in topology. Recreate topology with the molecules to be merged adjacent in the PDB file.')

        coordinates = self.parm.coordinates
        if coordinates is None:
            raise TiMergeError('Load coordinates before merging topology.')
        keep_mask = [0 for i in range(natom)]
        for i in range(natom):
            if molsel2[i]:
                for j in range(natom):
                    if sel2[j]:
                        atm1 = self.parm.atoms[i]
                        atm2 = self.parm.atoms[j]
                        if atm1 in atm2.bond_partners or atm1 in atm2.angle_partners or atm1 in atm2.dihedral_partners:
                            keep_mask[i] = 1

        nremove = sum(molsel2) - sum(sel2)
        remove_mask = []
        remove_map = [0 for i in range(natom)]
        new_atm_idx = 0
        for i in range(natom):
            if molsel2[i] == 1:
                if sel2[i] == 0:
                    remove_mask.append('%d' % (i + 1))
            else:
                remove_map[i] = new_atm_idx
                new_atm_idx += 1

        remove_str = '@' + ','.join(remove_mask)
        mol1common = []
        mol2common = []
        for i in range(natom):
            if molsel1[i] == 1 and sel1[i] == 0:
                mol1common.append(i)

        for i in range(natom):
            if molsel2[i] == 1 and sel2[i] == 0:
                mol2common.append(i)

        if len(mol1common) != len(mol2common):
            raise TiMergeError('The number of nonsoftcore atoms in mol1mask and mol2mask must be the same.')
        mol2common_sort = []
        for i in range(len(mol1common)):
            atm_i = mol1common[i]
            for j in range(len(mol2common)):
                atm_j = mol2common[j]
                diff = coordinates[atm_i] - coordinates[atm_j]
                if (np.abs(diff) < self.tol).sum() == 3:
                    mol2common_sort.append(atm_j)

        mol2common = mol2common_sort
        if len(mol1common) != len(mol2common):
            raise TiMergeError('The number of nonsoftcore atoms in mol1mask and mol2mask must be the same. Check the masks. If these look correct try using a larger tolerance.')
        for i in range(len(mol1common)):
            atm_i = mol1common[i]
            atm_j = mol2common[i]
            diff = coordinates[atm_i] - coordinates[atm_j]
            if (np.abs(diff) > self.tol).any():
                raise TiMergeError('Common (nonsoftcore) atoms must have the same coordinates.')

        for j in range(natom):
            if keep_mask[j] == 1 and sel2[j] == 0:
                atm = self.parm.atoms[j]
                idx = mol1common[mol2common.index(j)]
                atm_new = self.parm.atoms[idx]
                for k in range(natom):
                    if sel2[k]:
                        atm2 = self.parm.atoms[k]
                        if atm in atm2.bond_partners:
                            atm._bond_partners.remove(atm2)
                            atm2._bond_partners.remove(atm)
                            atm2.bond_to(atm_new)
                        if atm in atm2.angle_partners:
                            atm._angle_partners.remove(atm2)
                            atm2._angle_partners.remove(atm)
                            atm2.angle_to(atm_new)
                        if atm in atm2.dihedral_partners:
                            atm._dihedral_partners.remove(atm2)
                            atm2._dihedral_partners.remove(atm)
                            atm2.dihedral_to(atm_new)
                        for bond in self.parm.bonds:
                            if bond.atom1.idx == j:
                                if bond.atom2.idx == k:
                                    bond.atom1 = atm_new
                                else:
                                    if bond.atom2.idx == j:
                                        if bond.atom1.idx == k:
                                            bond.atom2 = atm_new

                        for angle in self.parm.angles:
                            if angle.atom1.idx == j:
                                if angle.atom2.idx == k or angle.atom3.idx == k:
                                    angle.atom1 = atm_new
                                else:
                                    if angle.atom2.idx == j:
                                        if angle.atom1.idx == k or angle.atom3.idx == k:
                                            angle.atom2 = atm_new
                                    elif angle.atom3.idx == j:
                                        if angle.atom1.idx == k or angle.atom2.idx == k:
                                            angle.atom3 = atm_new

                        for dihed in self.parm.dihedrals:
                            if dihed.atom1.idx == j:
                                if dihed.atom2.idx == k or dihed.atom3.idx == k or dihed.atom4.idx == k:
                                    dihed.atom1 = atm_new
                                else:
                                    if dihed.atom2.idx == j:
                                        if dihed.atom1.idx == k or dihed.atom3.idx == k or dihed.atom4.idx == k:
                                            dihed.atom2 = atm_new
                                    else:
                                        if dihed.atom3.idx == j:
                                            if dihed.atom1.idx == k or dihed.atom2.idx == k or dihed.atom4.idx == k:
                                                dihed.atom3 = atm_new
                                        elif dihed.atom4.idx == j:
                                            if dihed.atom1.idx == k or dihed.atom2.idx == k or dihed.atom3.idx == k:
                                                dihed.atom4 = atm_new

                        for imp in self.parm.impropers:
                            if imp.atom1.idx == j:
                                if imp.atom2.idx == k or imp.atom3.idx == k or imp.atom4.idx == k:
                                    imp.atom1 = atm_new
                                else:
                                    if imp.atom2.idx == j:
                                        if imp.atom1.idx == k or imp.atom3.idx == k or imp.atom4.idx == k:
                                            imp.atom2 = atm_new
                                    else:
                                        if imp.atom3.idx == j:
                                            if imp.atom1.idx == k or imp.atom2.idx == k or imp.atom4.idx == k:
                                                imp.atom3 = atm_new
                                        elif imp.atom4.idx == j:
                                            if imp.atom1.idx == k or imp.atom2.idx == k or imp.atom3.idx == k:
                                                imp.atom4 = atm_new

                        for cmap in self.parm.cmaps:
                            if cmap.atom1.idx == j:
                                if cmap.atom2.idx == k or cmap.atom3.idx == k or cmap.atom4.idx == k or cmap.atom5.idx == k:
                                    cmap.atom1 = atm_new
                            else:
                                if cmap.atom2.idx == j:
                                    if cmap.atom1.idx == k or cmap.atom3.idx == k or cmap.atom4.idx == k or cmap.atom5.idx == k:
                                        cmap.atom2 = atm_new
                                    else:
                                        if cmap.atom3.idx == j:
                                            if cmap.atom1.idx == k or cmap.atom2.idx == k or cmap.atom4.idx == k or cmap.atom5.idx == k:
                                                cmap.atom3 = atm_new
                                        else:
                                            if cmap.atom4.idx == j:
                                                if cmap.atom1.idx == k or cmap.atom2.idx == k or cmap.atom3.idx == k or cmap.atom5.idx == k:
                                                    cmap.atom4 = atm_new
                                            elif cmap.atom5.idx == j:
                                                if cmap.atom1.idx == k or cmap.atom2.idx == k or cmap.atom3.idx == k or cmap.atom4.idx == k:
                                                    cmap.atom5 = atm_new

        self.parm.atoms.changed = True
        if nremove > 0:
            self.parm.strip(remove_str)
        new_sc_atm1 = []
        new_sc_atm2 = []
        new_sc_atm1_int = []
        new_sc_atm2_int = []
        for i in range(natom):
            if sel1[i] or molsel1N[i]:
                new_sc_atm1_int.append(remove_map[i])
                new_sc_atm1.append('%d' % (remove_map[i] + 1))
            elif sel2[i] or molsel2N[i]:
                new_sc_atm2_int.append(remove_map[i])
                new_sc_atm2.append('%d' % (remove_map[i] + 1))

        for dihed in self.parm.dihedrals:
            if dihed.improper:
                pass
            else:
                atmi = dihed.atom1.idx
                atmj = dihed.atom2.idx
                atmk = dihed.atom3.idx
                atml = dihed.atom4.idx
                if (atmj in new_sc_atm1_int or atmk in new_sc_atm1_int or atmj in new_sc_atm2_int or atmk in new_sc_atm2_int) and atmi not in new_sc_atm1_int and atmi not in new_sc_atm2_int and atml not in new_sc_atm1_int and atml not in new_sc_atm2_int:
                    raise TiMergeError('Cannot have dihedral cross through softcore region. (DIHED : %d %d %d %d). Usually this means you have defined the softcore region in a way that breaks a ring. Try redefining your softcore region to include the ring or at least three consecutive atoms.' % (
                     atmi + 1, atmj + 1, abs(atmk) + 1, abs(atml) + 1))

        self.sc_mask1 = '@' + ','.join(new_sc_atm1)
        self.sc_mask2 = '@' + ','.join(new_sc_atm2)
        ret_str = 'Merging molecules %s and %s into the same molecule.\n' % (
         self.molmask1, self.molmask2)
        ret_str2 = "Use softcore mask:\ntimask1='%s',\ntimask2='%s'," % (
         self.sc_mask1, self.sc_mask2)
        ret_str3 = "\nscmask1='%s',\nscmask2='%s'," % (
         self.sc_mask1, self.sc_mask2)
        self.output.write('%s%s%s\n' % (ret_str, ret_str2, ret_str3))


class source(Action):
    __doc__ = '\n    Sources a file with a list of parmed commands\n    '
    usage = '<file>'
    needs_parm = False

    def init(self, arg_list):
        self.filename = arg_list.get_next_string()

    def __str__(self):
        return 'Sourcing %s' % self.filename

    def execute(self):
        """
        This is a no-op, since a separate command interpreter for this file is
        launched inside parmed_cmd.py
        """
        pass


class parm(Action):
    __doc__ = "\n    Either adds a new parm to the list of available parms to edit in ParmEd, or\n    it sets a new 'active' parm to edit by default with new commands\n    "
    usage = '<filename> [<filename> [<filename> ...]] || parm copy <filename>|<index> || parm select <filename>|<index>'
    needs_parm = False

    def init(self, arg_list):
        from glob import glob
        self.new_active_parm = arg_list.get_key_string('select', None)
        self.copied_parm = arg_list.get_key_string('copy', None)
        self.new_parm = None
        new_parm = len(arg_list.unmarked()) or None
        if self.new_active_parm is None:
            if self.copied_parm is None:
                if new_parm is None:
                    raise ParmError("Improper usage of `parm' command")
        opts = (
         self.new_active_parm, self.copied_parm, new_parm)
        nnone = 0
        for opt in opts:
            if opt is None:
                nnone += 1

        if nnone != 2:
            raise ParmError("Improper usage of `parm' -- choose one behavior")
        if self.new_active_parm is not None:
            try:
                self.new_active_parm = int(self.new_active_parm)
            except ValueError:
                pass

        else:
            if self.copied_parm is not None:
                try:
                    self.copied_parm = int(self.copied_parm)
                except ValueError:
                    pass

            else:
                self.new_parm = []
                new_parm = arg_list.get_next_string(optional=True)
                while new_parm is not None:
                    listparms = glob(new_parm)
                    if not listparms:
                        raise ParmFileNotFound('No files matching %s' % new_parm)
                    self.new_parm.extend(glob(new_parm))
                    new_parm = arg_list.get_next_string(optional=True)

        assert self.new_parm, 'No matching parm files? should not happen'

    def __str__(self):
        if self.new_active_parm is not None:
            try:
                idx = self.parm_list.index(self.new_active_parm)
            except IndexError:
                return '%s not in parm list. Doing nothing' % self.new_active_parm
            else:
                return 'Setting new active parm [%s]' % self.parm_list[idx]
        else:
            if self.new_parm is not None:
                return 'Adding prmtop %s to parm list. %s is the active parm.' % (
                 ', '.join(self.new_parm), self.new_parm[(-1)])
            if self.copied_parm is not None:
                try:
                    idx = self.parm_list.index(self.copied_parm)
                except IndexError:
                    return '%s not in parm list. Doing nothing' % self.new_active_parm
                else:
                    return "Copying prmtop %s to parm list. %s's copy is the active parm." % (
                     self.parm_list[idx], self.parm_list[idx])
        raise AssertionError('Should not be here')

    def execute(self):
        """ Either set the new active parm or add the new parm """
        from copy import copy
        if self.new_parm is not None:
            for new_parm in self.new_parm:
                try:
                    self.parm_list.add_parm(new_parm)
                except IOError:
                    warnings.warn('Could not open %s for reading' % new_parm, SeriousParmWarning)

        else:
            if self.new_active_parm is not None:
                try:
                    self.parm_list.set_new_active(self.new_active_parm)
                except IndexError:
                    warnings.warn('%s is not in the parm list!' % self.new_active_parm, SeriousParmWarning)

        if self.copied_parm is not None:
            try:
                self.parm_list.add_parm(copy(self.parm_list[self.copied_parm]))
            except IndexError:
                warnings.warn('%s is not in the parm list!' % self.copied_parm, SeriousParmWarning)


class ls(Action):
    __doc__ = "\n    Lists directory contents. Like UNIX 'ls'\n    "
    usage = '[Unix ls options]'
    needs_parm = False

    def init(self, arg_list):
        from glob import glob
        self.args = []
        while True:
            try:
                arg = arg_list.get_next_string()
                if not arg.startswith('-'):
                    globarg = glob(arg)
                    if len(globarg) > 0:
                        self.args.extend(globarg)
                    else:
                        self.args.append(arg)
                else:
                    self.args.append(arg)
            except NoArgument:
                break

    def __str__(self):
        from subprocess import Popen, PIPE
        process = Popen((['/bin/ls', '-C'] + self.args), stdout=PIPE, stderr=PIPE)
        out, err = process.communicate('')
        process.wait()
        return (out + err).decode('UTF-8')


class cd(Action):
    __doc__ = "\n    Changes to a new directory like UNIX 'cd'\n    "
    usage = '<directory>'
    needs_parm = False

    def init(self, arg_list):
        from glob import glob
        from os.path import expanduser, expandvars
        mydir = expanduser(expandvars(arg_list.get_next_string()))
        self.directory = glob(mydir)

    def __str__(self):
        if len(self.directory) != 1:
            return 'Change directory failed'
        else:
            if not os.path.isdir(self.directory[0]):
                return '%s does not exist. cd failed.' % self.directory[0]
            return 'New working directory: %s' % self.directory[0]

    def execute(self):
        if len(self.directory) < 1:
            warnings.warn('No recognized directories given to cd', SeriousParmWarning)
            return
        else:
            if len(self.directory) > 1:
                warnings.warn('More than one file/directory given to cd', SeriousParmWarning)
                return
            else:
                os.path.isdir(self.directory[0]) or warnings.warn('%s is not a directory' % self.directory[0], SeriousParmWarning)
                return
        os.chdir(self.directory[0])


class listParms(Action):
    __doc__ = '\n    Lists all of the loaded topology files\n    '
    needs_parm = False

    def init(self, arg_list):
        pass

    def __repr__(self):
        if self.parm_list.empty():
            return 'No topology files are loaded'
        else:
            retstr = 'Loaded topology files:'
            for i, parm in enumerate(self.parm_list):
                retstr += '\n[%d]\t%s' % (i, parm)
                if parm is self.parm_list.parm:
                    retstr += ' (active)'

            return retstr

    __str__ = __repr__


class interpolate(Action):
    __doc__ = "\n    Interpolates between two topology files (VDW and electrostatic terms only).\n    If [eleconly] is present, only the charges will be interpolated. <nparm> is\n    the number of 'interpolated' topology files you want (in addition to the two\n    end-points). The second prmtop must be specified if there are more than 2\n    parms currently loaded in the ParmEd parm list. startnum has no effect on\n    the generated prmtops, but it can be used to control the names of the\n    outputted topology files.\n\n        - <nparm> : Number of topology files that will be generated\n        - <other_parm> : The other parm object used in interpolation if more\n                         than 2 parms are present (first parm is active one)\n        - eleconly : Only do charge interpolation\n        - <prefix> : Generated parm objects will be written as <prefix>.#, where\n                     # starts from <num> and increases by 1\n        - <num> : Starting number for file names (see <prefix> above)\n    "
    usage = '<nparm> [parm2 <other_parm>] [eleconly] [prefix <prefix>] [startnum <num>]'
    strictly_supported = (
     AmberParm, ChamberParm)

    def init(self, arg_list):
        if len(self.parm_list) < 2:
            raise NonexistentParm('Must have 2 topology files to interpolate!')
        else:
            parm2 = arg_list.get_key_string('parm2', None)
            if parm2 is None:
                if len(self.parm_list) == 2:
                    self.parm2 = self.parm_list[1]
                    if self.parm_list[0] is not self.parm:
                        self.parm2 = self.parm_list[0]
                else:
                    if parm2 is None:
                        raise AmbiguousParmError('You must identify parm2 if more than 2 parm instances exist!')
                    else:
                        try:
                            parm2 = int(parm2)
                        except ValueError:
                            pass

            else:
                self.parm2 = self.parm_list[parm2]
            self.startnum = arg_list.get_key_int('startnum', 1)
            self.prefix = arg_list.get_key_string('prefix', str(self.parm))
            self.eleconly = arg_list.has_key('eleconly')
            self.nparm = arg_list.get_next_int()
            if self.nparm <= 0:
                raise ArgumentError('Must have >= 1 prmtop')
        self.diff_vdw = False
        self._check_parms()

    def __str__(self):
        extra = ''
        if self.eleconly:
            if self.diff_vdw:
                extra = ' [only interpolating charges]'
        return 'Creating %d interpolated prmtops between %s and %s' % (
         self.nparm, self.parm, self.parm2) + extra

    def _check_parms(self):
        """ Makes sure that the atoms in both parms are all the same """
        parm1, parm2 = self.parm, self.parm2
        if len(parm1.atoms) != len(parm2.atoms):
            raise IncompatibleParmsError('%s and %s have different #s of atoms!' % (
             parm1, parm2))
        ndiff = 0
        for atom1, atom2 in zip(parm1.atoms, parm2.atoms):
            if atom1.name != atom2.name:
                ndiff += 1

        if ndiff > 0:
            warnings.warn('%d atoms have different names b/w %s and %s' % (
             ndiff, parm1, parm2), SeriousParmWarning)
        for atm1, atm2 in zip(parm1.atoms, parm2.atoms):
            i1, i2 = atm1.nb_idx - 1, atm2.nb_idx - 1
            if parm1.LJ_radius[i1] != parm2.LJ_radius[i2] or parm1.LJ_depth[i1] != parm2.LJ_radius[i2]:
                self.diff_vdw = True

    def execute(self):
        """ Interpolates the prmtops """
        if self.diff_vdw:
            if not self.eleconly:
                raise NotImplementedError('No support for scaling vdW parameters yet!')
        parm1, parm2 = self.parm, self.parm2
        orig_chg1 = parm1.parm_data['CHARGE']
        chg1 = np.array(parm1.parm_data['CHARGE'])
        chg2 = np.array(parm2.parm_data['CHARGE'])
        diff = chg2 - chg1
        diff *= 1 / (self.nparm + 1)
        for i in range(self.nparm):
            new_chg = chg1 + diff * (i + 1)
            parm1.parm_data['CHARGE'] = new_chg.tolist()
            parm1.load_atom_info()
            newname = '%s.%d' % (self.prefix, i + self.startnum)
            print('Printing %s' % newname)
            parm1.write_parm(newname)

        parm1.parm_data['CHARGE'] = orig_chg1
        parm1.load_atom_info()


def _split_range(chunksize, start, stop):
    """split a given range to n_chunks. taken from pytraj.

    Examples
    --------
    [(0, 3), (3, 6), (6, 10)]
    """
    n_chunks = (stop - start) // chunksize
    if (stop - start) % chunksize != 0:
        n_chunks += 1
    for i in range(n_chunks):
        if i < n_chunks - 1:
            _stop = start + (i + 1) * chunksize
        else:
            _stop = stop
        yield (
         start + i * chunksize, _stop)


def _reformat_long_sentence(long_sentence, title, n_words=6):
    words = long_sentence.split(', ')
    empty = '\n' + ' ' * len(title)
    lines = [words[slice(*idx)] for idx in _split_range(n_words, 0, len(words))]
    sentences = [', '.join(line) for line in lines]
    sentences[0] = title[:] + sentences[0]
    return empty.join(sentences)


class summary(Action):
    __doc__ = '\n    Prints out a summary of prmtop contents\n    '

    def init(self, arg_list):
        pass

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        """ Collect statistics """
        nnuc = namin = ncion = naion = nwat = nunk = 0
        for res in self.parm.residues:
            if RNAResidue.has(res.name) or DNAResidue.has(res.name):
                nnuc += 1
            elif res.name in AminoAcidResidue._all_residues_by_abbr:
                namin += 1
            elif res.name in SOLVENT_NAMES:
                nwat += 1
            else:
                if res.name in ANION_NAMES:
                    naion += 1
                else:
                    if res.name in CATION_NAMES:
                        ncion += 1
                    else:
                        nunk += 1

        tmass = sum(atom.mass for atom in self.parm.atoms)
        tchg = sum(atom.charge for atom in self.parm.atoms)
        retval = [
         'Amino Acid Residues:   %d\nNucleic Acid Residues: %d\nNumber of cations:     %d\nNumber of anions:      %d\nNum. of solvent mols:  %d\nNum. of unknown res:   %d\nTotal charge (e-):     %.4f\nTotal mass (amu):      %.4f\nNumber of atoms:       %d\nNumber of residues:    %d' % (
          namin, nnuc, ncion, naion, nwat, nunk, tchg, tmass,
          len(self.parm.atoms), len(self.parm.residues))]
        rset = ', '.join(sorted(set(res.name for res in self.parm.residues)))
        retval.append(_reformat_long_sentence(rset, 'Residue set:           ', n_words=7))
        rcount = ','.join('%s: %d' % (x, y) for x, y in iteritems(Counter(res.name for res in self.parm.residues)))
        retval.append(_reformat_long_sentence((', '.join(sorted(rcount.split(',')))), 'Residue count:         ',
          n_words=7))
        if self.parm.box is not None:
            if set(self.parm.box[3:]) == set([90]):
                a, b, c = self.parm.box[:3]
                v = a * b * c
                retval.append('System volume (ang^3): %.2f\nSystem density (g/mL): %f' % (
                 v, tmass / (v * 0.602204)))
        if self.parm.box is not None:
            a, b, c, alpha, beta, gamma = self.parm.box[:]
            cosa = math.cos(alpha * math.pi / 180)
            cosb = math.cos(beta * math.pi / 180)
            cosg = math.cos(gamma * math.pi / 180)
            v = a * b * c * math.sqrt(1 - cosa * cosa - cosb * cosb - cosg * cosg + 2 * cosa * cosb * cosg)
            retval.append('System volume (ang^3): %.2f\nSystem density (g/mL): %f' % (
             v, tmass / (v * 0.602204)))
        return '%s\n' % '\n'.join(retval)


class scale(Action):
    __doc__ = '\n    Multiplies all values in a particular section of an Amber prmtop by a scalar\n    factor\n    '
    usage = '<FLAG> <factor>'
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        self.flag = arg_list.get_next_string().upper()
        self.factor = arg_list.get_next_float()
        if self.flag not in self.parm.flag_list:
            raise ArgumentError('%s is not a valid prmtop flag!' % self.flag)

    def __str__(self):
        return 'Scaling data in %s by %f' % (self.flag, self.factor)

    def execute(self):
        try:
            for i in range(len(self.parm.parm_data[self.flag])):
                self.parm.parm_data[self.flag][i] *= self.factor

        except TypeError:
            raise ArgumentError('Cannot scale data in %%FLAG %s' % self.flag)
        else:
            self.parm.load_structure()


class lmod(Action):
    __doc__ = '\n    Adjusts Lennard Jones parameters to work with the LMOD code in Amber\n    (changes LJ A coefficients that are 0 to 1000).\n    '
    strictly_supported = (AmberParm, ChamberParm)

    def init(self, arg_list):
        pass

    def __str__(self):
        return 'Making adjustments for LMOD (LJ A-coef. for H atoms bonded to O)'

    def execute(self):
        for i, val in enumerate(self.parm.parm_data['LENNARD_JONES_ACOEF']):
            self.parm.parm_data['LENNARD_JONES_ACOEF'][i] = val or 1000.0


class addPDB(Action):
    __doc__ = "\n    Adds PDB information to new flags in an Amber topology file to enable\n    analyses based on the original residue information in the PDB file,\n    <filename>. It adds the flags:\n\n    Residue Properties\n    ------------------\n        - RESIDUE_CHAINID: The chain ID of each residue (* if LEaP added it)\n        - RESIDUE_ICODE: Insertion code, if it exists\n        - RESIDUE_NUMBER: Original residue serial number in the PDB\n\n    Atom Properties\n    ---------------\n        - ATOM_ELEMENT: Atomic element (redundant now, not printed by default)\n        - ATOM_OCCUPANCY: The occupancy of each atom\n        - ATOM_BFACTOR: The temperature factor of each atom\n        - ATOM_NUMBER: The original atom serial number in the PDB\n\n    The 'strict' keyword turns residue mismatches (NOT solvent) into errors\n    The 'elem' keyword will force printing of the element names.\n    The 'allicodes' keyword forces insertion codes to be printed, even if every\n    one will be blank (so that parsers can count on that section existing).\n\n    Residues *not* in the PDB will be assigned a CHAINID of '*' and\n    RESIDUE_NUMBER of 0. Any occupancy or temperature (B) factor that is not\n    present in the input PDB file is assigned a number of 0\n\n    Historical info:\n        This action is based on, and reproduces the key results of, the\n        historical 'add_pdb' program. It is a bit more flexible, though.\n    "
    usage = '<filename> [elem] [strict] [allicodes]'
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        self.pdbfile = arg_list.get_next_string()
        self.elements = arg_list.has_key('elem')
        self.printicodes = arg_list.has_key('allicodes')
        if arg_list.has_key('strict'):
            warnings.filterwarnings('error', category=AddPDBWarning)
        else:
            warnings.filterwarnings('always', category=AddPDBWarning)
        self.pdbpresent = 'RESIDUE_NUMBER' in self.parm.flag_list or 'RESIDUE_CHAINID' in self.parm.flag_list or 'RESIDUE_ICODE' in self.parm.flag_list or 'ATOM_ELEMENT' in self.parm.flag_list or 'ATOM_OCCUPANCY' in self.parm.flag_list or 'ATOM_BFACTOR' in self.parm.flag_list or 'ATOM_NUMBER' in self.parm.flag_list

    def __str__(self):
        if self.pdbpresent:
            return 'PDB information already present in %s. Doing nothing'
        else:
            retstr = 'Adding PDB information from %s' % self.pdbfile
            if self.elements:
                retstr += '\n\t[printing elements from prmtop]'
            return retstr

    def execute(self):
        from parmed import read_PDB
        if self.pdbpresent:
            return
        else:
            pdb = read_PDB(self.pdbfile)
            resnums = [0 for res in self.parm.residues]
            chainids = ['*' for res in self.parm.residues]
            icodes = ['' for res in self.parm.residues]
            tempfac = [0.0 for atom in self.parm.atoms]
            occupancies = [0.0 for atom in self.parm.atoms]
            atomnums = [-1 for atom in self.parm.atoms]
            for res in self.parm.residues:
                res.number = 0
                res.chain = '*'
                res.insertion_code = ''

            for i, res in enumerate(pdb.residues):
                try:
                    parmres = self.parm.residues[i]
                    reslab = parmres.name
                    resname = res.name.strip()
                    if resname != reslab:
                        if resname not in ('WAT', 'HOH') or reslab not in ('WAT', 'HOH'):
                            if resname in ('A', 'C', 'G', 'U', 'DA', 'DG', 'DC', 'DT'):
                                if reslab[(-1)] in '35':
                                    reslab = reslab[:-1]
                            if reslab != resname:
                                needs_warn = True
                                if reslab in ('ASP', 'ASH', 'AS4'):
                                    if resname in ('ASP', 'ASH', 'AS4'):
                                        needs_warn = False
                                if reslab in ('GLU', 'GLH', 'GL4'):
                                    if resname in ('GLU', 'GLH', 'GL4'):
                                        needs_warn = False
                                if reslab in ('HIP', 'HIS', 'HIE', 'HID'):
                                    if resname in ('HIP', 'HIS', 'HIE', 'HID'):
                                        needs_warn = False
                                if reslab in ('LYS', 'LYN'):
                                    if resname in ('LYS', 'LYN'):
                                        needs_warn = False
                                if reslab in ('CYS', 'CYX', 'CYM'):
                                    if resname in ('CYS', 'CYX', 'CYM'):
                                        needs_warn = False
                                if needs_warn:
                                    warnings.warn('Residue name mismatch [#%d] %s vs. %s' % (
                                     i + 1, resname, reslab), AddPDBWarning)
                    resnums[i] = parmres.number = res.number
                    chainids[i] = parmres.chain = res.chain
                    icodes[i] = parmres.insertion_code = res.insertion_code
                except IndexError:
                    raise AddPDBError('PDB %s has more residues than prmtop %s' % (
                     self.pdbfile, self.parm))

                for atom in parmres:
                    for pdbatom in res:
                        if atom.name == pdbatom.name:
                            tempfac[atom.idx] = pdbatom.bfactor
                            occupancies[atom.idx] = pdbatom.occupancy
                            atomnums[atom.idx] = pdbatom.number
                            break

            ncmts = [
             'Residue number (resSeq) read from PDB file; DIMENSION(NRES)']
            if self.printicodes or any(icodes):
                haveicodes = True
                ncmts += ['Residue insertion codes (iCode) present in %FLAG RESIDUE_ICODE']
            else:
                haveicodes = False
            ncmts += ['Residue insertion code (iCode) not present in PDB file',
             'If present: %FLAG RESIDUE_ICODE, %FORMAT(20a4)']
        self.parm.add_flag('RESIDUE_NUMBER', '20I4', data=resnums, comments=ncmts)
        self.parm.add_flag('RESIDUE_CHAINID', '20a4', data=chainids, comments=[
         'Residue chain ID (chainId) read from PDB file; DIMENSION(NRES)'])
        if haveicodes:
            self.parm.add_flag('RESIDUE_ICODE', '20a4', data=icodes, comments=[
             'Residue insertion code (iCode) read from PDB file; DIMENSION(NRES)'])
        if self.elements:
            self.parm.add_flag('ATOM_ELEMENT', '20a4', data=['%2s' % _Element[atm.atomic_number].upper() for atm in self.parm.atoms],
              comments=[
             'Atom element name read from topology file'])
        self.parm.add_flag('ATOM_OCCUPANCY', '10F8.2', data=occupancies, comments=[
         'Atom occupancies read from the PDB file'])
        self.parm.add_flag('ATOM_BFACTOR', '10F8.2', data=tempfac, comments=[
         'Atom temperature factor from the PDB file'])
        self.parm.add_flag('ATOM_NUMBER', '10I8', data=atomnums, comments=[
         'Atom serial number from the PDB file'])
        self.parm.load_atom_info()


class deletePDB(Action):
    __doc__ = '\n    This action deletes the flags added by addPDB if they are present.\n    '
    supported_subclasses = (AmberParm,)

    def init(self, arg_list):
        self.pdbpresent = 'RESIDUE_NUMBER' in self.parm.flag_list or 'RESIDUE_CHAINID' in self.parm.flag_list or 'RESIDUE_ICODE' in self.parm.flag_list or 'ATOM_ELEMENT' in self.parm.flag_list or 'ATOM_BFACTOR' in self.parm.flag_list or 'ATOM_OCCUPANCY' in self.parm.flag_list or 'ATOM_NUMBER' in self.parm.flag_list

    def __str__(self):
        if self.pdbpresent:
            return 'Deleting PDB info from %s' % self.parm
        else:
            return 'No PDB information present in %s. Doing nothing' % self.parm

    def execute(self):
        if not self.pdbpresent:
            return
        self.parm.delete_flag('RESIDUE_NUMBER')
        self.parm.delete_flag('RESIDUE_CHAINID')
        self.parm.delete_flag('RESIDUE_ICODE')
        self.parm.delete_flag('ATOM_ELEMENT')
        self.parm.delete_flag('ATOM_BFACTOR')
        self.parm.delete_flag('ATOM_OCCUPANCY')
        self.parm.delete_flag('ATOM_NUMBER')


class add12_6_4(Action):
    __doc__ = '\n    Adds the LENNARD_JONES_CCOEF term for the new divalent metal ion 12-6-4\n    Lennard-Jones potential term. If provided, the mask will allow you to\n    specify which ions are divalent. The C4 parameter between the metal ion and\n    water can either be taken from Ref. [1] for the requested [watermodel]\n    (TIP3P, TIP4PEW, or SPCE) or provided in the file specified by the c4file\n    keyword.  The polarizabilities must be present in the the polfile file. The\n    chemical symbol of the element will be used to determine the atom type.\n    Parameters are expected in a file with 2 columns:\n        <atom type>   <parameter>\n\n    All defaults come from Ref. [1], [2] and [3]\n\n    [1] Pengfei Li and Kenneth M. Merz, J. Chem. Theory Comput., 2014, 10,\n        289-297\n    [2] Pengfei Li, Lin F. Song and Kenneth M. Merz, J. Phys. Chem. B, 2015,\n        119, 883-895\n    [3] Pengfei Li, Lin F. Song and Kenneth M. Merz, J. Chem. Theory Comput.,\n        2015, 11, 1645-1657.\n    '
    usage = '[<divalent ion mask>] [c4file <C4 Param. File> | watermodel <water model>] [polfile <Pol. Param File> [tunfactor <tunfactor>]'
    strictly_supported = (
     AmberParm, ChamberParm)
    _supported_wms = ('TIP3P', 'TIP4PEW', 'SPCE')

    def init(self, arg_list):
        self.mask = AmberMask(self.parm, arg_list.get_next_mask(optional=True, default=':ZN'))
        self.c4file = arg_list.get_key_string('c4file', None)
        self.watermodel = arg_list.get_key_string('watermodel', None)
        self.polfile = arg_list.get_key_string('polfile', os.path.join(os.getenv('AMBERHOME') or '', 'dat', 'leap', 'parm', 'lj_1264_pol.dat'))
        self.tunfactor = arg_list.get_key_float('tunfactor', 1.0)
        if self.c4file is None:
            if self.watermodel is None:
                self.watermodel = 'TIP3P'
            else:
                self.watermodel = self.watermodel.upper()
                if self.watermodel not in self._supported_wms:
                    raise LJ12_6_4Error('Unrecognized water model %s; pick one of the following: %s' % (
                     self.watermodel,
                     ', '.join(self._supported_wms)))
        elif self.watermodel is not None:
            raise LJ12_6_4Error('c4file and watermodel are mutually exclusive')

    def __str__(self):
        retstr = 'Adding Lennard-Jones C-coefficient for 12-6-4 potential. Polarizabilities read from [%s]. ' % self.polfile
        if self.c4file is None:
            retstr += 'Using default C4 parameters for water model [%s].' % self.watermodel
        else:
            retstr += 'Reading C4 parameters from [%s].' % self.c4file
        return retstr

    def execute(self):
        from parmed.tools.add1264 import params1264 as params
        self.parm.delete_flag('LENNARD_JONES_CCOEF')
        self.parm.add_flag('LENNARD_JONES_CCOEF', '5E16.8', num_items=(len(self.parm.parm_data['LENNARD_JONES_ACOEF'])),
          comments=[
         'For 12-6-4 potential used for divalent metal ions'])
        for i, param in enumerate(params(self.parm, self.mask, self.c4file, self.watermodel, self.polfile, self.tunfactor)):
            self.parm.parm_data['LENNARD_JONES_CCOEF'][i] = param


class HMassRepartition(Action):
    __doc__ = "\n    This action implements hydrogen mass repartitioning in the system by\n    changing the mass of each hydrogen to the desired value (the default new\n    hydrogen mass is 3.024 daltons) and adjusting the mass of the atom to which\n    it is bonded by the amount required to leave the total mass unchanged. By\n    default, water hydrogen masses are unchanged (the SETTLE algorithm for\n    implementing constraints on water molecules is analytical). Water masses can\n    be repartitioned as well with the 'dowater' keyword.\n    "
    usage = '[<mass>] [dowater]'

    def init(self, arg_list):
        self.changewater = arg_list.has_key('dowater')
        self.new_h_mass = arg_list.get_next_float(optional=True, default=3.024)

    def __str__(self):
        retstr = 'Repartitioning hydrogen masses to %s daltons. ' % self.new_h_mass
        if self.changewater:
            return retstr + 'Also changing water hydrogen masses.'
        else:
            return retstr + 'Not changing water hydrogen masses.'

    def execute(self):
        original_masses = [atom.mass for atom in self.parm.atoms]
        water = SOLVENT_NAMES
        for i, atom in enumerate(self.parm.atoms):
            if atom.atomic_number != 1:
                pass
            else:
                if not self.changewater:
                    if atom.residue.name in water:
                        continue
                heteroatom = None
                heteroidx = 0
                bondeds = list(atom.bond_partners)
                while heteroidx < len(bondeds):
                    if bondeds[heteroidx].atomic_number != 1:
                        heteroatom = bondeds[heteroidx]
                        break
                    heteroidx += 1

            if heteroatom is None:
                warnings.warn('H atom detected not bound to heteroatom. Ignoring.', ParmWarning)
            else:
                transfermass = self.new_h_mass - atom.mass
                atom.mass = self.new_h_mass
                heteroatom.mass -= transfermass
                if isinstance(self.parm, AmberParm):
                    self.parm.parm_data['MASS'][i] = self.new_h_mass
                    self.parm.parm_data['MASS'][heteroatom.idx] -= transfermass

        for atom in self.parm.atoms:
            if atom.mass <= 0 and atom.atomic_number > 0:
                for i, atom in enumerate(self.parm.atoms):
                    atom.mass = original_masses[i]
                    if isinstance(self.parm, AmberParm):
                        self.parm.parm_data['MASS'][i] = original_masses[i]

                raise HMassRepartitionError('Too much mass removed from atom %d. Hydrogen masses must be smaller.' % i)


class OpenMM(Action):
    __doc__ = "\n    This class will read a sander/pmemd input file and run an equivalent\n    simulation using the OpenMM Python API. It uses a topology file that has\n    been defined (and/or modified) here. The command-line flags are identical to\n    those used for sander and pmemd (described in the Amber manual). You can\n    additionally specify a computational platform available through OpenMM such\n    as CUDA, OpenCL, Reference, and CPU.\n\n    The default prmtop will be the 'active' parm. The prmtop can be changed\n    using either the 'parm' keyword or the '-p' flag, but it must resolve to one\n    of the stored topology files. Any parm given with the '-p' flag has\n    precedence. If present, the 'dcd' keyword triggers writting DCD-formatted\n    trajectory files instead of NetCDF when ioutfm=1. The DCD trajectory writing\n    offers binary trajectory support without requiring a NetCDF-Python library.\n\n    The 'progress' keyword triggers printing of ParmEd's progress in setting up\n    and starting the calculation.\n\n    The 'script' keyword provides a file to write an OpenMM script that performs\n    the same calculation requested by this ParmEd command. The 'norun' command\n    will prevent anything from actually being run and can only be used when a\n    script file is provided.\n    "
    usage = '[-p <parm>|<parm index>] [sander/pmemd options] [-platform <platform>] [-precision <precision model>] [dcd] [progress] [script <script_file.py>] [norun]'
    not_supported = (
     AmoebaParm,)

    def init(self, arg_list):
        parm = arg_list.get_key_string('-p', default=None)
        if parm is not None:
            self.parm = self.parm_list[parm]
        self.arg_list = ArgumentList(arg_list)

    def __str__(self):
        return 'Running Amber-style simulation with OpenMM using the command string:\n\t%s\nThis may take awhile...' % self.arg_list

    def execute(self):
        """ Runs the OpenMM simulation """
        from parmed.tools.simulations.openmm import simulate, HAS_OPENMM
        if not HAS_OPENMM:
            raise SimulationError('OpenMM could not be imported. Skipping.')
        inptraj = self.arg_list.has_key('-y', mark=False)
        has_inpcrd = self.arg_list.has_key('-c', mark=False)
        if self.parm.coordinates is None:
            if not inptraj:
                if not has_inpcrd:
                    raise SimulationError('No input coordinates provided.')
        simulate(self.parm, self.arg_list)


class energy(Action):
    __doc__ = "\n    This action will compute a single-point energy for the loaded structure (you\n    must use 'loadRestart' prior to this command to load coordinates). The\n    following options and keywords are supported:\n\n    Options\n    -------\n\n        - cutoff <cut> : The size of the non-bonded cutoff, in Angstroms.\n                         Default 8 A for periodic systems or infinite for\n                         nonperiodic systems\n\n    For systems with no periodic box information\n    --------------------------------------------\n\n        - igb <IGB> : An integer corresponding to the desired GB model. May be\n                      1, 2, 5, 7, or 8 as described by the sander and pmemd\n                      manual. Default 5.\n        - saltcon <conc> : The salt concentration, in mol/L, modeled by a Debye\n                           screening parameter. Default 0.0\n\n    For periodic systems\n    --------------------\n\n        - Ewald : Use an Ewald sum to compute long-range electrostatics instead\n                  of PME\n        - nodisper : Do not use a long-range vdW dispersion correction\n\n    OpenMM-specific options\n    -----------------------\n\n        - omm : If present, this keyword will instruct ParmEd to use OpenMM to\n                compute the energies (and optionally forces) using OpenMM\n                instead of sander.\n        - platform <platform> : OpenMM compute platform to use. Options are\n                CUDA, OpenCL, Reference, and CPU. Consult the OpenMM manual for\n                details (only used if 'omm' is provided)\n        - precision <precision model> : Precision model to use. Options are\n                single, double, and mixed. Reference platform is always double\n                and CPU platform is always single. Mixed (default) uses single\n                precision for calculations and double for accumulation (only\n                used if 'omm' is provided)\n        - decompose : Print bond, angle, dihedral, and nonbonded energies\n                      separately\n        - applayer : Use OpenMM's class to compute the energy\n\n    Examples\n    --------\n\n        # Using AMBER\n        import parmed as pmd\n        parm = pmd.load_file('prmtop', xyz='rst7')\n        pmd.tools.energy(parm, 'igb 8').execute()\n\n        # Using Openmm\n        pmd.tools.energy(parm, 'igb 5 omm').execute()\n    "
    usage = '[cutoff <cut>] [[igb <IGB>] [saltcon <conc>] | [Ewald]] [nodisper] [omm] [applayer] [platform <platform>] [precision <precision model>] [decompose]'
    output = sys.stdout

    def init(self, arg_list):
        self.use_openmm = arg_list.has_key('omm') or not isinstance(self.parm, AmberParm)
        self.arg_list = ArgumentList(arg_list)
        if self.use_openmm:
            if isinstance(self.parm, AmoebaParm):
                raise NotImplementedError('Amoeba prmtops can only get energies from sander')

    def __str__(self):
        return 'Computing a single-point energy for %s' % self.parm

    def execute(self):
        if self.use_openmm:
            from parmed.tools.simulations.openmm import energy, HAS_OPENMM
            if not HAS_OPENMM:
                raise SimulationError('OpenMM could not be imported. Skipping.')
            energy(self.parm, self.arg_list, self.output)
        else:
            from parmed.tools.simulations.sanderapi import energy, HAS_SANDER
            if not HAS_SANDER:
                raise SimulationError('sander could not be imported. Skipping.')
            self.arg_list.get_key_string('platform', None)
            self.arg_list.get_key_string('precision', None)
            self.arg_list.has_key('decompose')
            self.arg_list.has_key('applayer')
            energy(self.parm, self.arg_list, self.output)


class deleteBond(Action):
    __doc__ = '\n    This action deletes any bonds that occur between the atoms in two masks.\n\n        - <mask1> : Amber mask defining one of the atoms in a bond\n        - <mask2> : Amber mask defining the other atom in the bond\n        - [verbose] : Print out every bond that is deleted as well as the\n                      number of other valence terms that were eliminated.\n\n    All bonds will be matched in which one atom comes from <mask1> and the other\n    atom comes from <mask2>. This action will also delete any other valence term\n    (like angles and dihedrals) that would get severed by the deletion of one of\n    the bonds.\n    '
    usage = '<mask1> <mask2>'

    def init(self, arg_list):
        self.mask1 = AmberMask(self.parm, arg_list.get_next_mask())
        self.mask2 = AmberMask(self.parm, arg_list.get_next_mask())
        self.verbose = arg_list.has_key('verbose')
        bonds_to_delete = set()
        self.del_bonds = set()
        self.del_angles = set()
        self.del_dihedrals = set()
        self.del_rbtorsions = set()
        self.del_urey_bradleys = set()
        self.del_impropers = set()
        self.del_cmaps = set()
        self.del_trigonal_angles = set()
        self.del_oopbends = set()
        self.del_pi_torsions = set()
        self.del_strbnds = set()
        self.del_tortors = set()
        for i in self.mask1.Selected():
            ai = self.parm.atoms[i]
            for j in self.mask2.Selected():
                aj = self.parm.atoms[j]
                if ai is aj:
                    pass
                else:
                    for bond in ai.bonds:
                        if aj not in bond:
                            pass
                        else:
                            bonds_to_delete.add(bond)

        for i, bond in enumerate(self.parm.bonds):
            if bond in bonds_to_delete:
                self.del_bonds.add(i)

        for bond in bonds_to_delete:
            for i, angle in enumerate(self.parm.angles):
                if bond in angle:
                    self.del_angles.add(i)

            for i, dihed in enumerate(self.parm.dihedrals):
                if bond in dihed:
                    self.del_dihedrals.add(i)

            for i, dihed in enumerate(self.parm.rb_torsions):
                if bond in dihed:
                    self.del_rbtorsions.add(i)

            for i, urey in enumerate(self.parm.urey_bradleys):
                if bond in urey:
                    self.del_urey_bradleys.add(i)

            for i, improper in enumerate(self.parm.impropers):
                if bond in improper:
                    self.del_impropers.add(i)

            for i, cmap in enumerate(self.parm.cmaps):
                if bond in cmap:
                    self.del_cmaps.add(i)

            for i, trigonal_angle in enumerate(self.parm.trigonal_angles):
                if bond in trigonal_angle:
                    self.del_trigonal_angles.add(i)

            for i, oopbend in enumerate(self.parm.out_of_plane_bends):
                if bond in oopbend:
                    self.del_oopbends.add(i)

            for i, pitor in enumerate(self.parm.pi_torsions):
                if bond in pitor:
                    self.del_pi_torsions.add(i)

            for i, strbnd in enumerate(self.parm.stretch_bends):
                if bond in strbnd:
                    self.del_strbnds.add(i)

            for i, tortor in enumerate(self.parm.torsion_torsions):
                if bond in tortor:
                    self.del_tortors.add(i)

    def __str__(self):
        if not self.del_bonds:
            return 'No bonds to delete'
        else:
            if not self.verbose:
                return 'Deleting the %d bonds found between %s and %s' % (
                 len(self.del_bonds), self.mask1, self.mask2)
            else:
                retstr = 'Deleting %d bonds between %s and %s:\n' % (
                 len(self.del_bonds), self.mask1, self.mask2)
                for bond in self.del_bonds:
                    a1, a2 = self.parm.bonds[bond].atom1, self.parm.bonds[bond].atom2
                    retstr += '\t%d [%s %d] %s --- %d [%s %d] %s\n' % (a1.idx + 1,
                     a1.residue.name, a1.residue.idx + 1, a1.name, a2.idx + 1,
                     a2.residue.name, a2.residue.idx + 1, a2.name)

                retstr += 'Deleting %d angles, ' % len(self.del_angles)
                if self.parm.trigonal_angles or self.parm.out_of_plane_bends or self.parm.stretch_bends or self.parm.torsion_torsions:
                    retstr += '%d Urey-Bradleys, %d trigonal angles,\n         %d dihedrals, %d out-of-plane bends, %d stretch-bends\n         and %d torsion-torsions' % (
                     len(self.del_urey_bradleys),
                     len(self.del_trigonal_angles),
                     len(self.del_dihedrals) + len(self.del_rbtorsions),
                     len(self.del_oopbends), len(self.del_strbnds),
                     len(self.del_tortors))
                else:
                    if self.parm.urey_bradleys or self.parm.impropers or self.parm.cmaps:
                        retstr += '%d Urey-Bradleys, %d impropers,\n         %d dihedrals and %d CMAPs' % (
                         len(self.del_urey_bradleys), len(self.del_impropers),
                         len(self.del_dihedrals) + len(self.del_rbtorsions),
                         len(self.del_cmaps))
                    else:
                        retstr += 'and %d dihedrals' % (len(self.del_dihedrals) + len(self.del_rbtorsions))
            return retstr

    def execute(self):
        if not self.del_bonds:
            return
        for i in sorted((self.del_bonds), reverse=True):
            self.parm.bonds[i].delete()
            del self.parm.bonds[i]

        for i in sorted((self.del_angles), reverse=True):
            self.parm.angles[i].delete()
            del self.parm.angles[i]

        for i in sorted((self.del_dihedrals), reverse=True):
            self.parm.dihedrals[i].delete()
            del self.parm.dihedrals[i]

        for i in sorted((self.del_rbtorsions), reverse=True):
            self.parm.rb_torsions[i].delete()
            del self.parm.rb_torsions[i]

        for i in sorted((self.del_urey_bradleys), reverse=True):
            self.parm.urey_bradleys[i].delete()
            del self.parm.urey_bradleys[i]

        for i in sorted((self.del_impropers), reverse=True):
            self.parm.impropers[i].delete()
            del self.parm.impropers[i]

        for i in sorted((self.del_cmaps), reverse=True):
            self.parm.cmaps[i].delete()
            del self.parm.cmaps[i]

        for i in sorted((self.del_trigonal_angles), reverse=True):
            del self.parm.trigonal_angles[i]

        for i in sorted((self.del_oopbends), reverse=True):
            del self.parm.out_of_plane_bends[i]

        for i in sorted((self.del_tortors), reverse=True):
            self.parm.torsion_torsions[i].delete()
            del self.parm.torsion_torsions[i]

        for i in sorted((self.del_strbnds), reverse=True):
            del self.parm.stretch_bends[i]

        try:
            self.parm.remake_parm()
        except AttributeError:
            self.parm.prune_empty_terms()


class chamber(Action):
    __doc__ = "\n    This action will read CHARMM parameter, topology (RTF), and stream (STR)\n    files and apply those parameters to a structure defined in a CHARMM PSF\n    (protein structure file). XPLOR, CHARMM, and VMD-generated PSF files are all\n    supported. You may specify -top, -param, and -str as many times as you want\n    to provide multiple parameter files. All topology files are read first (in\n    the order they are specified), followed by all parameter files, and finally\n    all stream files are read in.  Topology files are only necessary if the\n    parameter files do not define the atom types (newer CHARMM force fields\n    define atom types directly in the parameter file. Environment variables and\n    shell wild-cards (* and ?), as well as the home shortcut character ~ are\n    properly expanded when looking for files.\n\n    Options\n    -------\n        - -top        CHARMM topology, or Residue Topology File (RTF) file\n        - -param      CHARMM parameter file\n        - -str        CHARMM stream file. Only RTF and parameter sections read\n        - -toppar     CHARMM topology, parameter, and/or stream file(s). File\n                      type is detected from extension (or in the case of .inp\n                      files, the presence of 'top', 'par' in the name)\n        - -psf        CHARMM PSF file\n        - -crd        Coordinate file (PDB, CHARMM CRD, Amber restart, etc.)\n        - -nocmap     Do not use any CMAP parameters\n        - -box        Box dimensions. If no angles are defined, they are assumed\n                      to be 90 degrees (orthorhombic box). Alternatively, you\n                      can use the word 'bounding' to define a box that encloses\n                      the centers of all atoms.\n        - -radii      Implicit solvent solvation radii. <radiusset> can be\n                      amber6, bondi, mbondi, mbondi2, mbondi3\n                      Same effect as the changeRadii command. Default is mbondi.\n        - nosettle    This avoids changing the names of the water residue and\n                      oxygen atoms from TIP3 and OH2 to WAT and O\n\n    If the PDB file has a CRYST1 record, the box information will be set from\n    there. Any box info given on the command-line will override the box found in\n    the crd file.\n    "
    usage = '-top <RTF> -param <PAR> [-str <STR>] -psf <PSF> [-crd <CRD>] [-nocmap] [-box a,b,c[,alpha,beta,gamma]|bounding] [-radii <radiusset>] [nosettle]'
    needs_parm = False

    def init(self, arg_list):
        from os.path import expandvars, expanduser
        import glob
        self.topfiles, self.paramfiles, self.streamfiles = [], [], []
        while arg_list.has_key('-top', mark=False):
            topfile = expanduser(arg_list.get_key_string('-top', None))
            topfile = expandvars(topfile)
            topfiles = glob.glob(topfile)
            if not topfiles:
                raise FileDoesNotExist('CHARMM RTF file %s does not exist' % topfile)
            self.topfiles.extend(topfiles)

        while arg_list.has_key('-param', mark=False):
            param = expanduser(arg_list.get_key_string('-param', None))
            param = expandvars(param)
            params = glob.glob(param)
            if not params:
                raise FileDoesNotExist('CHARMM parameter file %s does not exist' % param)
            self.paramfiles.extend(params)

        while arg_list.has_key('-str', mark=False):
            stream = expanduser(arg_list.get_key_string('-str', None))
            stream = expandvars(stream)
            streams = glob.glob(stream)
            if not streams:
                raise FileDoesNotExist('CHARMM stream file %s does not exist' % stream)
            self.streamfiles.extend(streams)

        while arg_list.has_key('-toppar', mark=False):
            toppar = expanduser(arg_list.get_key_string('-toppar', None))
            toppar = expandvars(toppar)
            toppars = glob.glob(toppar)
            if not toppars:
                raise FileDoesNotExist('CHARMM toppar file %s does not exist' % toppar)
            for fname in toppars:
                base = os.path.split(fname)[1]
                if base.endswith('.rtf') or base.endswith('.top'):
                    self.topfiles.append(fname)
                else:
                    if base.endswith('.par') or base.endswith('.prm'):
                        self.paramfiles.append(fname)
                    else:
                        if base.endswith('.str'):
                            self.streamfiles.append(fname)
                        else:
                            if base.endswith('.inp'):
                                if 'par' in base:
                                    self.paramfiles.append(fname)
                                else:
                                    if 'top' in base:
                                        self.topfiles.append(fname)
                                    else:
                                        raise InputError('Cannot detect filetype of %s' % fname)
                            else:
                                raise InputError('Cannot detect filetype of %s' % fname)

        crdfile = arg_list.get_key_string('-crd', None)
        if crdfile is not None:
            crdfiles = glob.glob(expanduser(expandvars(crdfile)))
            if not crdfiles:
                raise FileDoesNotExist('Coordinate file %s does not exist' % crdfile)
            if len(crdfiles) > 1:
                raise InputError('Too many coordinate files selected through globbing')
            self.crdfile = crdfiles[0]
        else:
            self.crdfile = None
        self.cmap = not arg_list.has_key('-nocmap')
        psf = arg_list.get_key_string('-psf', None)
        if psf is None:
            raise InputError('chamber requires a PSF file')
        self.psf = glob.glob(expanduser(expandvars(psf)))
        if not self.psf:
            raise FileDoesNotExist('chamber PSF file %s cannot be found' % psf)
        elif len(self.psf) > 1:
            raise InputError('Too many PSF files selected through globbing')
        else:
            self.psf = self.psf[0]
            box = arg_list.get_key_string('-box', None)
            if box is None:
                self.box = None
            else:
                if box.lower() != 'bounding':
                    try:
                        self.box = [float(w) for w in box.replace(',', ' ').split()]
                    except ValueError:
                        raise InputError('Box info must be comma-delimited floats')

                    if len(self.box) == 3:
                        self.box += [90.0, 90.0, 90.0]
                    else:
                        if len(self.box) != 6:
                            raise InputError('Box must be 3 lengths or 3 lengths and 3 angles!')
                else:
                    self.box = 'bounding'
        self.radii = arg_list.get_key_string('-radii', 'mbondi')
        if not self.paramfiles:
            if not self.streamfiles:
                raise InputError('No parameter files were provided!')
        if self.radii not in GB_RADII:
            raise InputError('Illegal radius set %s -- must be one of %s' % (
             self.radii, ', '.join(GB_RADII)))
        arg_list.has_key('nocondense')
        self.nosettle = arg_list.has_key('nosettle')

    def __str__(self):
        retstr = 'Creating chamber topology file from PSF %s, ' % self.psf
        if self.topfiles:
            retstr += 'RTF files [%s], ' % ', '.join(self.topfiles)
            if not self.streamfiles or not self.paramfiles:
                retstr += 'and '
        if self.paramfiles:
            retstr += 'PAR files [%s]' % ', '.join(self.paramfiles)
            if self.streamfiles:
                retstr += ', and '
        if self.streamfiles:
            retstr += 'STR files [%s].' % ', '.join(self.streamfiles)
        else:
            if self.crdfile is not None:
                retstr += ' Coords from %s.' % self.crdfile
            if self.cmap:
                retstr += ' Using CMAP.'
            else:
                retstr += ' NO CMAP.'
        if self.box == 'bounding':
            retstr += ' Defining a bounding box.'
        else:
            if self.box is not None:
                retstr += ' Box info %s.' % self.box
        retstr += ' GB Radius set %s.' % self.radii
        if self.nosettle:
            retstr += ' Not changing water names.'
        return retstr

    def execute(self):
        parmset = CharmmParameterSet()
        for tfile in self.topfiles:
            parmset.read_topology_file(tfile)

        for pfile in self.paramfiles:
            parmset.read_parameter_file(pfile)

        for sfile in self.streamfiles:
            parmset.read_stream_file(sfile)

        psf = CharmmPsfFile(self.psf)
        if self.crdfile is not None:
            crdbox = None
            crd = load_file(self.crdfile)
            try:
                if len(crd.coordinates.shape) == 3:
                    coords = crd.coordinates[0]
                else:
                    coords = crd.coordinates
            except (AttributeError, TypeError):
                raise ChamberError('No coordinates in %s' % self.crdfile)

            if hasattr(crd, 'box'):
                if crd.box is not None:
                    if len(crd.box.shape) == 1:
                        crdbox = crd.box
                    else:
                        crdbox = crd.box[0]
            if coords.shape != (len(psf.atoms), 3):
                raise ChamberError('Mismatch in number of coordinates (%d) and 3*number of atoms (%d)' % (
                 len(coords),
                 3 * len(psf.atoms)))
            psf.coordinates = coords
            if self.box is None:
                if crdbox is not None:
                    if len(crdbox) == 3:
                        psf.box = list(crdbox) + [90.0, 90.0, 90.0]
                    else:
                        if len(crdbox) == 6:
                            psf.box = list(crdbox)
                        else:
                            raise ValueError('Unexpected box array shape')
            if self.box == 'bounding':
                extent = coords.max(axis=0) - coords.min(axis=0)
                psf.box = list(extent) + [90.0, 90.0, 90.0]
            else:
                if self.box is not None:
                    if len(self.box) == 3:
                        psf.box = list(self.box) + [90.0, 90.0, 90.0]
                    else:
                        if len(self.box) == 6:
                            psf.box = copy.copy(self.box)
                        else:
                            raise ValueError('Unexpected box array shape')
                else:
                    psf.box = None
        else:
            if self.box is None:
                psf.box = None
            else:
                if len(self.box) == 3:
                    psf.box = list(self.box) + [90.0, 90.0, 90.0]
                else:
                    if len(self.box) == 6:
                        psf.box = self.box[:]
                    else:
                        raise ValueError('Unexpected box array shape')
                nsets = len(parmset.parametersets)
                if nsets > 0:
                    frcfield = []
                    for pset in parmset.parametersets:
                        frcfield.extend([nsets, pset])

                else:
                    frcfield = [
                     1, 'No FF information parsed...']
            if not self.cmap:
                psf.clear_cmap()
            try:
                psf.load_parameters(parmset)
            except ParmedError as e:
                raise ChamberError('Problem assigning parameters to PSF: %s' % e)

            parm = ConvertFromPSF(psf, parmset)
            parm.name = self.psf
            changeRadii(parm, self.radii).execute()
            self.parm_list.add_parm(parm)
            self.parm = parm
        if not self.nosettle:
            for res, nam in zip(parm.residues, parm.parm_data['RESIDUE_LABEL']):
                if nam != 'TIP3':
                    pass
                else:
                    res.name = parm.parm_data['RESIDUE_LABEL'][res.idx] = 'WAT'
                    for atom in res:
                        if atom.name == 'OH2':
                            atom.name = parm.parm_data['ATOM_NAME'][atom.idx] = 'O'


class minimize(Action):
    __doc__ = '\n    This action takes a structure and minimizes the energy using either\n    scipy.optimize.minimize (with BFGS) and the sander API *or* OpenMM.\n    Following this action, the coordinates stored in the topology will be the\n    minimized structure\n\n    General Options\n    ---------------\n        - omm                 Use OpenMM instead of sander+scipy to minimize\n        - cutoff <cutoff>     Nonbonded cutoff in Angstroms\n        - tol <tolerance>     The largest energy difference between successive\n                              steps in the minimization allow the minimization\n                              to stop (Default 0.001)\n        - maxcyc <cycles>     The maximum number of minimization cycles\n                              permitted.  No limit by default (minimization\n                              stops when tolerance is satisfied)\n\n    Implicit Solvent options\n    ------------------------\n        - igb <IGB>           GB model to use (0=No GB, 1,2,5,7,8 correspond to\n                              Amber models)\n        - saltcon <conc>      Salt concentration for GB in Molarity\n\n    OpenMM-specific options\n    -----------------------\n        - restrain <mask>     Selection of atoms to restrain\n        - weight <k>          Weight of positional restraints (kcal/mol/A^2)\n        - norun               Do not run the calculation\n        - script <script>     Name of the Python script to write to run this\n                              calculation\n        - platform <platform> Which compute platform to use. Options are CUDA,\n                              OpenCL, CPU, and Reference. Consult OpenMM docs\n                              for more information\n        - precision <precision_model> Which precision model to use. Can be\n                              "single", "double", or "mixed", and only has an\n                              effect on the CUDA and OpenCL platforms.\n\n    The implicit solvent options will be ignored for systems with periodic\n    boundary conditions. The precision option will be ignored for platforms that\n    do not support user-specified precision. The platform, precision, and script\n    arguments will be ignored unless ``omm`` is specified.\n    '
    usage = '[cutoff <cut>] [[igb <IGB>] [saltcon <conc>]] [[restrain <mask>] [weight <k>]] [norun] [script <script_file.py>] [platform <platform>] [precision <precision model>] [tol <tolerance>] [maxcyc <cycles>] [omm]'
    not_supported = (
     AmoebaParm,)

    def init(self, arg_list):
        self.use_openmm = arg_list.has_key('omm')
        self.cutoff = arg_list.get_key_float('cutoff', None)
        mask = arg_list.get_key_mask('restrain', None)
        self.igb = arg_list.get_key_int('igb', 0)
        self.saltcon = arg_list.get_key_float('saltcon', 0.0)
        self.weight = arg_list.get_key_float('weight', 0.0)
        self.norun = arg_list.has_key('norun')
        self.script = arg_list.get_key_string('script', None)
        self.platform = arg_list.get_key_string('platform', None)
        self.precision = arg_list.get_key_string('precision', 'mixed')
        self.tol = arg_list.get_key_float('tol', 0.001)
        self.maxcyc = arg_list.get_key_int('maxcyc', None)
        if self.parm.ptr('ifbox') == 0:
            if self.cutoff is None or self.cutoff > 500:
                self.cutoff = None
        else:
            if self.cutoff is None:
                self.cutoff = 8.0
            else:
                if self.cutoff < 7:
                    raise InputError('Cutoff unreasonably small.')
        if self.parm.ptr('ifbox') == 0:
            if self.saltcon < 0:
                raise InputError('Salt concentration must be non-negative')
        else:
            if mask is not None:
                self.restrain = AmberMask(self.parm, mask)
                if not self.use_openmm:
                    raise InputError('Restraints only permitted with omm option')
                if self.weight <= 0:
                    raise InputError('Restraints require a restraint stiffness larger than 0 kcal/mol/A^2')
            else:
                self.restrain = None
        if self.platform not in ('CUDA', 'OpenCL', 'CPU', 'Reference', None):
            raise InputError('platform must be CUDA, OpenCL, CPU or Reference (NOT %s)' % self.platform)
        if self.precision not in ('mixed', 'single', 'double'):
            raise InputError('precision must be single, double, or mixed.')
        if self.parm.ptr('ifbox') == 0:
            if self.igb not in (0, 1, 2, 5, 6, 7, 8):
                raise InputError('Illegal igb value (%d). Must be 0, 1, 2, 5, 6, 7, or 8' % self.igb)
        if self.maxcyc is not None:
            if self.maxcyc <= 0:
                raise InputError('maxcyc must be a positive integer')
        if self.tol < 0:
            raise InputError('tolerance must be positive')
        if self.tol == 0:
            if self.maxcyc is None:
                raise InputError('tolerance must be > 0 if maxcyc is not set.')
        if self.norun:
            if not self.use_openmm:
                raise InputError('norun only makes sense with the script and omm options')

    def __str__(self):
        retstr = 'Minimizing %s ' % self.parm
        if self.parm.ptr('ifbox'):
            retstr += 'with PME '
        else:
            if self.igb == 0 or self.igb == 6:
                retstr += 'in gas phase '
            else:
                if self.igb == 1:
                    retstr += 'with GB(HCT) '
                else:
                    if self.igb == 2:
                        retstr += 'with GB(OBC1) '
                    else:
                        if self.igb == 5:
                            retstr += 'with GB(OBC2) '
                        else:
                            if self.igb == 7:
                                retstr += 'with GB(GBneck) '
                            else:
                                if self.igb == 8:
                                    retstr += 'with GB(GBneck2) '
            if self.cutoff is None:
                retstr += 'and no cutoff '
            else:
                retstr += 'and a cutoff of %.2f Angstroms ' % self.cutoff
        retstr += 'to a tolerance of %s. ' % self.tol
        if self.restrain is not None:
            retstr += 'Restraining %s with weights %f. ' % (self.restrain,
             self.weight)
        if self.maxcyc is not None:
            retstr += 'Using at most %d minimization steps.' % self.maxcyc
        return retstr.strip()

    def execute(self):
        from parmed.tools.simulations.openmm import minimize as omm_min
        from parmed.tools.simulations.sanderapi import minimize as san_min
        if self.parm.coordinates is None:
            raise SimulationError('You must load coordinates before "minimize"')
        else:
            if self.use_openmm:
                omm_min(self.parm, self.igb, self.saltcon, self.cutoff, self.restrain, self.weight, self.script, self.platform, self.precision, self.norun, self.tol, self.maxcyc)
            else:
                san_min(self.parm, self.igb, self.saltcon, self.cutoff, self.tol, self.maxcyc)


class outPDB(Action):
    __doc__ = '\n    Write a PDB file from the currently active system to <file>\n\n        - <file>: The PDB file to write\n        - [norenumber]: Use the original atom and residue numbering if available\n        - [charmm]: Put the SEGID, if available, in columns 72 to 76\n        - [anisou]: Write anisotropic B-factors if available\n    '
    usage = '<file> [norenumber] [charmm] [anisou]'

    def init(self, arg_list):
        self.renumber = not arg_list.has_key('norenumber')
        self.charmm = arg_list.has_key('charmm')
        self.anisou = arg_list.has_key('anisou')
        self.filename = arg_list.get_next_string()
        if self.parm.coordinates is None:
            raise InputError('Parm %s does not have loaded coordinates' % self.parm)

    def __str__(self):
        retstr = 'Writing PDB file %s' % self.filename
        if self.renumber:
            retstr += ' renumbering atoms and residues'
        else:
            retstr += ' not renumbering atoms and residues'
        if self.charmm:
            retstr += ' and adding CHARMM SEGIDs'
        if self.anisou:
            retstr += ' and adding anisotropic B-factors'
        return retstr

    def execute(self):
        self.parm.write_pdb((self.filename), renumber=(self.renumber), charmm=(self.charmm),
          write_anisou=(self.anisou))


class outCIF(Action):
    __doc__ = '\n    Write a PDBx/mmCIF file from the currently active system to <file>\n\n        - <file>: The PDBx/mmCIF file to write\n        - [norenumber]: Use the original atom and residue numbering if available\n        - [anisou]: Write anisotropic B-factors if available\n    '
    usage = '<file> [norenumber] [charmm] [anisou]'

    def init(self, arg_list):
        self.renumber = not arg_list.has_key('norenumber')
        self.anisou = arg_list.has_key('anisou')
        self.filename = arg_list.get_next_string()
        if self.parm.coordinates is None:
            raise InputError('Parm %s does not have loaded coordinates' % self.parm)

    def __str__(self):
        retstr = 'Writing PDB file %s' % self.filename
        if self.renumber:
            retstr += ' renumbering atoms and residues'
        else:
            retstr += ' not renumbering atoms and residues'
        if self.anisou:
            retstr += ' and adding anisotropic B-factors'
        return retstr

    def execute(self):
        self.parm.write_cif((self.filename), renumber=(self.renumber), write_anisou=(self.anisou))


class gromber(Action):
    __doc__ = '\n    Load a Gromacs topology file with parameters as an Amber-formatted system.\n    Note, if your Gromacs topology file requires any include topology files, you\n    will need to have Gromacs installed for this to work.\n\n        - <top_file>: The Gromacs topology file to load\n        - <coord_file>: The coordinate file to load into the system. Can be any\n                        recognized format (GRO, PDB, mmCIF, inpcrd, etc.)\n        - define <DEFINE[=VAR]>: Preprocessor defines that control the\n                        processing of the Gromacs topology file.\n        - topdir <directory>: The directory containing all Gromacs include\n                        topology files. This is only necessary if Gromacs is not\n                        installed in a location that ParmEd can find.\n        - radii <radiusset>: The GB radius set to use. Can be \'mbondi\', \'bondi\',\n                        \'mbondi2\', or \'amber6\'. Default is mbondi\n\n    Gromacs topology files do not store the unit cell information. Therefore, in\n    order to make sure that unit cell information is properly assigned to the\n    resulting system, the provided ``<coord_file>`` should contain unit cell\n    information (e.g., GRO, PDB, PDBx/mmCIF, and inpcrd files can all store box\n    information).\n\n    ParmEd will try to locate the Gromacs topology directory using either the\n    GMXDATA or GMXBIN environment variables (which should point to the\n    $PREFIX/share/gromacs or $PREFIX/bin directories, respectively, where\n    $PREFIX is the install prefix). If neither is set, the topology directory is\n    located relative to the location of the ``gmx`` (Gromacs 5+) or ``pdb2gmx``\n    (Gromacs 4 or older) in the user\'s PATH. If none of the above is true, the\n    default installation location (/usr/local/gromacs/share/gromacs/top) is\n    used. Any provided ``topdir`` will override default choices (but only for\n    this particular command -- future ``gromber`` actions will use the default\n    location again).\n\n    You can provide as many defines as you wish, and the ordering you specify\n    them is preserved. The default value assigned to each define is "1". To\n    provide multiple defines, use the ``define`` keyword multiple times, for\n    example:\n\n    define MYVAR=something define MYVAR2=something_else ...\n    '
    usage = '<top_file> [<coord_file>] [define <DEFINE[=VAR]>] [topdir <directory>] [radii <radiusset>]'
    needs_parm = False

    def init(self, arg_list):
        self.topfile = arg_list.get_next_string()
        defines = OrderedDict()
        current_define = arg_list.get_key_string('define', None)
        while current_define is not None:
            if '=' in current_define:
                parts = current_define.split('=')
                if len(parts) != 2:
                    raise InputError('Illegal define: %s' % current_define)
                key, val = parts
                defines[key] = val
            else:
                defines[current_define] = '1'
            current_define = arg_list.get_key_string('define', None)

        self.defines = defines or None
        self.orig_topdir = gromacs.GROMACS_TOPDIR
        topdir = arg_list.get_key_string('topdir', gromacs.GROMACS_TOPDIR)
        gromacs.GROMACS_TOPDIR = topdir
        self.coordinate_file = arg_list.get_next_string(optional=True)
        self.radii = arg_list.get_key_string('radii', 'mbondi')

    def __str__(self):
        retstr = [
         'Converting Gromacs topology %s to Amber. ' % self.topfile]
        if self.defines:
            retstr.append('Using the following defines:\n')
            for key, val in iteritems(self.defines):
                retstr.append('\t%s=%s\n' % (key, val))

        else:
            retstr.append('Using topology directory [%s]. ' % gromacs.GROMACS_TOPDIR)
            if self.coordinate_file is None:
                retstr.append('No coordinates provided.')
            else:
                retstr.append('Getting coordinates (and box) from %s.' % self.coordinate_file)
        return ''.join(retstr)

    def execute(self):
        try:
            top = gromacs.GromacsTopologyFile((self.topfile), defines=(self.defines))
        finally:
            gromacs.GROMACS_TOPDIR = self.orig_topdir

        if self.coordinate_file is not None:
            crd = load_file(self.coordinate_file)
            if isinstance(crd, Structure):
                if len(top.atoms) != len(crd.atoms):
                    raise InputError('Coordinate/topology file size mismatch')
                for a1, a2 in zip(top.atoms, crd.atoms):
                    try:
                        a1.xx = a2.xx
                        a1.xy = a2.xy
                        a1.xz = a2.xz
                    except AttributeError:
                        raise InputError('%s does not contain coordinates' % self.coordinate_file)

                    try:
                        a1.vx = a2.vx
                        a1.vy = a2.vy
                        a1.vz = a2.vz
                    except AttributeError:
                        pass

            else:
                if hasattr(crd, 'coordinates'):
                    if not callable(crd.coordinates):
                        it = iter(crd.coordinates)
                        for a, x, y, z in zip(top.atoms, it, it, it):
                            a.xx, a.xy, a.xz = x, y, z

                    elif hasattr(crd, 'coordinates') and callable(crd.coordinates):
                        it = iter(crd.coordinates(0))
                        for a, x, y, z in zip(top.atoms, it, it, it):
                            a.xx, a.xy, a.xz = x, y, z

                    else:
                        if hasattr(crd, 'positions'):
                            pos = crd.positions.value_in_unit(u.angstroms)
                            for a, xyz in zip(top.atoms, pos):
                                a.xx, a.xy, a.xz = pos

                        else:
                            raise InputError('Cannot find coordinates in %s' % self.coordinate_file)
                else:
                    if hasattr(crd, 'box') and callable(crd.box):
                        top.box = copy.copy(crd.box(0))
                top.box = copy.copy(crd.box)
        try:
            if top.impropers or top.urey_bradleys or top.cmaps:
                self.parm = ChamberParm.from_structure(top)
            else:
                self.parm = AmberParm.from_structure(top)
        except TypeError as err:
            raise InputError(str(err))

        self.parm.name = self.topfile
        changeRadii(self.parm, self.radii).execute()
        self.parm_list.add_parm(self.parm)


def _change_lj_pair(parm, atom_1, atom_2, rmin, eps, one_4=False):
    if one_4:
        key = 'LENNARD_JONES_14'
    else:
        key = 'LENNARD_JONES'
    a1, a2 = sorted([atom_1, atom_2])
    ntypes = parm.pointers['NTYPES']
    term_idx = parm.parm_data['NONBONDED_PARM_INDEX'][(ntypes * (a1 - 1) + a2 - 1)] - 1
    parm.parm_data[('%s_ACOEF' % key)][term_idx] = eps * rmin ** 12
    parm.parm_data[('%s_BCOEF' % key)][term_idx] = 2 * eps * rmin ** 6
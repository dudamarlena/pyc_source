# uncompyle6 version 3.7.4
# Python bytecode 2.7 (62211)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /tmp/pip-install-n_sfyb/Django/django/core/management/commands/makemessages.py
# Compiled at: 2019-02-14 00:35:17
from __future__ import unicode_literals
import fnmatch, glob, io, os, re, sys
from functools import total_ordering
from itertools import dropwhile
import django
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.files.temp import NamedTemporaryFile
from django.core.management.base import BaseCommand, CommandError
from django.core.management.utils import find_command, handle_extensions, popen_wrapper
from django.utils._os import upath
from django.utils.encoding import DEFAULT_LOCALE_ENCODING, force_str
from django.utils.functional import cached_property
from django.utils.jslex import prepare_js_for_gettext
from django.utils.text import get_text_list
from django.utils.translation import templatize
plural_forms_re = re.compile(b'^(?P<value>"Plural-Forms.+?\\\\n")\\s*$', re.MULTILINE | re.DOTALL)
STATUS_OK = 0
NO_LOCALE_DIR = object()

def check_programs(*programs):
    for program in programs:
        if find_command(program) is None:
            raise CommandError(b"Can't find %s. Make sure you have GNU gettext tools 0.15 or newer installed." % program)

    return


@total_ordering
class TranslatableFile(object):

    def __init__(self, dirpath, file_name, locale_dir):
        self.file = file_name
        self.dirpath = dirpath
        self.locale_dir = locale_dir

    def __repr__(self):
        return b'<%s: %s>' % (
         self.__class__.__name__,
         os.sep.join([self.dirpath, self.file]))

    def __eq__(self, other):
        return self.path == other.path

    def __lt__(self, other):
        return self.path < other.path

    @property
    def path(self):
        return os.path.join(self.dirpath, self.file)


class BuildFile(object):
    """
    Represents the state of a translatable file during the build process.
    """

    def __init__(self, command, domain, translatable):
        self.command = command
        self.domain = domain
        self.translatable = translatable

    @cached_property
    def is_templatized(self):
        if self.domain == b'djangojs':
            return self.command.gettext_version < (0, 18, 3)
        if self.domain == b'django':
            file_ext = os.path.splitext(self.translatable.file)[1]
            return file_ext != b'.py'
        return False

    @cached_property
    def path(self):
        return self.translatable.path

    @cached_property
    def work_path(self):
        """
        Path to a file which is being fed into GNU gettext pipeline. This may
        be either a translatable or its preprocessed version.
        """
        if not self.is_templatized:
            return self.path
        extension = {b'djangojs': b'c', b'django': b'py'}.get(self.domain)
        filename = b'%s.%s' % (self.translatable.file, extension)
        return os.path.join(self.translatable.dirpath, filename)

    def preprocess(self):
        """
        Preprocess (if necessary) a translatable file before passing it to
        xgettext GNU gettext utility.
        """
        if not self.is_templatized:
            return
        encoding = settings.FILE_CHARSET if self.command.settings_available else b'utf-8'
        with io.open(self.path, b'r', encoding=encoding) as (fp):
            src_data = fp.read()
        if self.domain == b'djangojs':
            content = prepare_js_for_gettext(src_data)
        elif self.domain == b'django':
            content = templatize(src_data, origin=self.path[2:], charset=encoding)
        with io.open(self.work_path, b'w', encoding=b'utf-8') as (fp):
            fp.write(content)

    def postprocess_messages(self, msgs):
        """
        Postprocess messages generated by xgettext GNU gettext utility.

        Transform paths as if these messages were generated from original
        translatable files rather than from preprocessed versions.
        """
        if not self.is_templatized:
            return msgs
        if os.name == b'nt':
            old_path = self.work_path
            new_path = self.path
        else:
            old_path = self.work_path[2:]
            new_path = self.path[2:]
        return re.sub(b'^(#: .*)(' + re.escape(old_path) + b')', lambda match: match.group().replace(old_path, new_path), msgs, flags=re.MULTILINE)

    def cleanup(self):
        """
        Remove a preprocessed copy of a translatable file (if any).
        """
        if self.is_templatized:
            if os.path.exists(self.work_path):
                os.unlink(self.work_path)


def normalize_eols(raw_contents):
    """
    Take a block of raw text that will be passed through str.splitlines() to
    get universal newlines treatment.

    Return the resulting block of text with normalized `
` EOL sequences ready
    to be written to disk using current platform's native EOLs.
    """
    lines_list = raw_contents.splitlines()
    if lines_list and lines_list[(-1)]:
        lines_list.append(b'')
    return (b'\n').join(lines_list)


def write_pot_file(potfile, msgs):
    """
    Write the :param potfile: POT file with the :param msgs: contents,
    previously making sure its format is valid.
    """
    pot_lines = msgs.splitlines()
    if os.path.exists(potfile):
        lines = dropwhile(len, pot_lines)
    else:
        lines = []
        found, header_read = False, False
        for line in pot_lines:
            if not found and not header_read:
                found = True
                line = line.replace(b'charset=CHARSET', b'charset=UTF-8')
            if not line and not found:
                header_read = True
            lines.append(line)

    msgs = (b'\n').join(lines)
    with io.open(potfile, b'a', encoding=b'utf-8') as (fp):
        fp.write(msgs)


class Command(BaseCommand):
    help = b'Runs over the entire source tree of the current directory and pulls out all strings marked for translation. It creates (or updates) a message file in the conf/locale (in the django tree) or locale (for projects and applications) directory.\n\nYou must run this command with one of either the --locale, --exclude, or --all options.'
    translatable_file_class = TranslatableFile
    build_file_class = BuildFile
    requires_system_checks = False
    leave_locale_alone = True
    msgmerge_options = [
     b'-q', b'--previous']
    msguniq_options = [b'--to-code=utf-8']
    msgattrib_options = [b'--no-obsolete']
    xgettext_options = [b'--from-code=UTF-8', b'--add-comments=Translators']

    def add_arguments(self, parser):
        parser.add_argument(b'--locale', b'-l', default=[], dest=b'locale', action=b'append', help=b'Creates or updates the message files for the given locale(s) (e.g. pt_BR). Can be used multiple times.')
        parser.add_argument(b'--exclude', b'-x', default=[], dest=b'exclude', action=b'append', help=b'Locales to exclude. Default is none. Can be used multiple times.')
        parser.add_argument(b'--domain', b'-d', default=b'django', dest=b'domain', help=b'The domain of the message files (default: "django").')
        parser.add_argument(b'--all', b'-a', action=b'store_true', dest=b'all', default=False, help=b'Updates the message files for all existing locales.')
        parser.add_argument(b'--extension', b'-e', dest=b'extensions', action=b'append', help=b'The file extension(s) to examine (default: "html,txt,py", or "js" if the domain is "djangojs"). Separate multiple extensions with commas, or use -e multiple times.')
        parser.add_argument(b'--symlinks', b'-s', action=b'store_true', dest=b'symlinks', default=False, help=b'Follows symlinks to directories when examining source code and templates for translation strings.')
        parser.add_argument(b'--ignore', b'-i', action=b'append', dest=b'ignore_patterns', default=[], metavar=b'PATTERN', help=b'Ignore files or directories matching this glob-style pattern. Use multiple times to ignore more.')
        parser.add_argument(b'--no-default-ignore', action=b'store_false', dest=b'use_default_ignore_patterns', default=True, help=b"Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.")
        parser.add_argument(b'--no-wrap', action=b'store_true', dest=b'no_wrap', default=False, help=b"Don't break long message lines into several lines.")
        parser.add_argument(b'--no-location', action=b'store_true', dest=b'no_location', default=False, help=b"Don't write '#: filename:line' lines.")
        parser.add_argument(b'--no-obsolete', action=b'store_true', dest=b'no_obsolete', default=False, help=b'Remove obsolete message strings.')
        parser.add_argument(b'--keep-pot', action=b'store_true', dest=b'keep_pot', default=False, help=b'Keep .pot file after making messages. Useful when debugging.')

    def handle(self, *args, **options):
        locale = options[b'locale']
        exclude = options[b'exclude']
        self.domain = options[b'domain']
        self.verbosity = options[b'verbosity']
        process_all = options[b'all']
        extensions = options[b'extensions']
        self.symlinks = options[b'symlinks']
        ignore_patterns = options[b'ignore_patterns']
        if options[b'use_default_ignore_patterns']:
            ignore_patterns += [b'CVS', b'.*', b'*~', b'*.pyc']
        self.ignore_patterns = list(set(ignore_patterns))
        if options[b'no_wrap']:
            self.msgmerge_options = self.msgmerge_options[:] + [b'--no-wrap']
            self.msguniq_options = self.msguniq_options[:] + [b'--no-wrap']
            self.msgattrib_options = self.msgattrib_options[:] + [b'--no-wrap']
            self.xgettext_options = self.xgettext_options[:] + [b'--no-wrap']
        if options[b'no_location']:
            self.msgmerge_options = self.msgmerge_options[:] + [b'--no-location']
            self.msguniq_options = self.msguniq_options[:] + [b'--no-location']
            self.msgattrib_options = self.msgattrib_options[:] + [b'--no-location']
            self.xgettext_options = self.xgettext_options[:] + [b'--no-location']
        self.no_obsolete = options[b'no_obsolete']
        self.keep_pot = options[b'keep_pot']
        if self.domain not in ('django', 'djangojs'):
            raise CommandError(b"currently makemessages only supports domains 'django' and 'djangojs'")
        if self.domain == b'djangojs':
            exts = extensions if extensions else [b'js']
        else:
            exts = extensions if extensions else [b'html', b'txt', b'py']
        self.extensions = handle_extensions(exts)
        if locale is None and not exclude and not process_all or self.domain is None:
            raise CommandError(b"Type '%s help %s' for usage information." % (
             os.path.basename(sys.argv[0]), sys.argv[1]))
        if self.verbosity > 1:
            self.stdout.write(b'examining files with the extensions: %s\n' % get_text_list(list(self.extensions), b'and'))
        self.invoked_for_django = False
        self.locale_paths = []
        self.default_locale_path = None
        if os.path.isdir(os.path.join(b'conf', b'locale')):
            self.locale_paths = [
             os.path.abspath(os.path.join(b'conf', b'locale'))]
            self.default_locale_path = self.locale_paths[0]
            self.invoked_for_django = True
        else:
            if self.settings_available:
                self.locale_paths.extend(settings.LOCALE_PATHS)
            if os.path.isdir(b'locale'):
                self.locale_paths.append(os.path.abspath(b'locale'))
            if self.locale_paths:
                self.default_locale_path = self.locale_paths[0]
                if not os.path.exists(self.default_locale_path):
                    os.makedirs(self.default_locale_path)
        locale_dirs = filter(os.path.isdir, glob.glob(b'%s/*' % self.default_locale_path))
        all_locales = map(os.path.basename, locale_dirs)
        if process_all:
            locales = all_locales
        else:
            locales = locale or all_locales
            locales = set(locales) - set(exclude)
        if locales:
            check_programs(b'msguniq', b'msgmerge', b'msgattrib')
        check_programs(b'xgettext')
        try:
            potfiles = self.build_potfiles()
            for locale in locales:
                if self.verbosity > 0:
                    self.stdout.write(b'processing locale %s\n' % locale)
                for potfile in potfiles:
                    self.write_po_file(potfile, locale)

        finally:
            if not self.keep_pot:
                self.remove_potfiles()

        return

    @cached_property
    def gettext_version(self):
        out, err, status = popen_wrapper([
         b'xgettext', b'--version'], stdout_encoding=DEFAULT_LOCALE_ENCODING)
        m = re.search(b'(\\d+)\\.(\\d+)\\.?(\\d+)?', out)
        if m:
            return tuple(int(d) for d in m.groups() if d is not None)
        raise CommandError(b'Unable to get gettext version. Is it installed?')

    @cached_property
    def settings_available(self):
        try:
            settings.LOCALE_PATHS
        except ImproperlyConfigured:
            if self.verbosity > 1:
                self.stderr.write(b'Running without configured settings.')
            return False

        return True

    def build_potfiles(self):
        """
        Build pot files and apply msguniq to them.
        """
        file_list = self.find_files(b'.')
        self.remove_potfiles()
        self.process_files(file_list)
        potfiles = []
        for path in self.locale_paths:
            potfile = os.path.join(path, b'%s.pot' % str(self.domain))
            if not os.path.exists(potfile):
                continue
            args = [
             b'msguniq'] + self.msguniq_options + [potfile]
            msgs, errors, status = popen_wrapper(args)
            if errors:
                if status != STATUS_OK:
                    raise CommandError(b'errors happened while running msguniq\n%s' % errors)
                elif self.verbosity > 0:
                    self.stdout.write(errors)
            msgs = normalize_eols(msgs)
            with io.open(potfile, b'w', encoding=b'utf-8') as (fp):
                fp.write(msgs)
            potfiles.append(potfile)

        return potfiles

    def remove_potfiles(self):
        for path in self.locale_paths:
            pot_path = os.path.join(path, b'%s.pot' % str(self.domain))
            if os.path.exists(pot_path):
                os.unlink(pot_path)

    def find_files(self, root):
        """
        Helper method to get all files in the given root. Also check that there
        is a matching locale dir for each file.
        """

        def is_ignored(path, ignore_patterns):
            """
            Check if the given path should be ignored or not.
            """
            filename = os.path.basename(path)

            def ignore(pattern):
                return fnmatch.fnmatchcase(filename, pattern) or fnmatch.fnmatchcase(path, pattern)

            return any(ignore(pattern) for pattern in ignore_patterns)

        ignore_patterns = [ os.path.normcase(p) for p in self.ignore_patterns ]
        dir_suffixes = {b'%s*' % path_sep for path_sep in {b'/', os.sep}}
        norm_patterns = []
        for p in ignore_patterns:
            for dir_suffix in dir_suffixes:
                if p.endswith(dir_suffix):
                    norm_patterns.append(p[:-len(dir_suffix)])
                    break
            else:
                norm_patterns.append(p)

        all_files = []
        ignored_roots = []
        if self.settings_available:
            ignored_roots = [ os.path.normpath(p) for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT) if p ]
        for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=self.symlinks):
            for dirname in dirnames[:]:
                if is_ignored(os.path.normpath(os.path.join(dirpath, dirname)), norm_patterns) or os.path.join(os.path.abspath(dirpath), dirname) in ignored_roots:
                    dirnames.remove(dirname)
                    if self.verbosity > 1:
                        self.stdout.write(b'ignoring directory %s\n' % dirname)
                elif dirname == b'locale':
                    dirnames.remove(dirname)
                    self.locale_paths.insert(0, os.path.join(os.path.abspath(dirpath), dirname))

            for filename in filenames:
                file_path = os.path.normpath(os.path.join(dirpath, filename))
                file_ext = os.path.splitext(filename)[1]
                if file_ext not in self.extensions or is_ignored(file_path, self.ignore_patterns):
                    if self.verbosity > 1:
                        self.stdout.write(b'ignoring file %s in %s\n' % (filename, dirpath))
                else:
                    locale_dir = None
                    for path in self.locale_paths:
                        if os.path.abspath(dirpath).startswith(os.path.dirname(path)):
                            locale_dir = path
                            break

                    if not locale_dir:
                        locale_dir = self.default_locale_path
                    if not locale_dir:
                        locale_dir = NO_LOCALE_DIR
                    all_files.append(self.translatable_file_class(dirpath, filename, locale_dir))

        return sorted(all_files)

    def process_files(self, file_list):
        """
        Group translatable files by locale directory and run pot file build
        process for each group.
        """
        file_groups = {}
        for translatable in file_list:
            file_group = file_groups.setdefault(translatable.locale_dir, [])
            file_group.append(translatable)

        for locale_dir, files in file_groups.items():
            self.process_locale_dir(locale_dir, files)

    def process_locale_dir(self, locale_dir, files):
        """
        Extract translatable literals from the specified files, creating or
        updating the POT file for a given locale directory.

        Uses the xgettext GNU gettext utility.
        """
        build_files = []
        for translatable in files:
            if self.verbosity > 1:
                self.stdout.write(b'processing file %s in %s\n' % (
                 translatable.file, translatable.dirpath))
            if self.domain not in ('djangojs', 'django'):
                continue
            build_file = self.build_file_class(self, self.domain, translatable)
            try:
                build_file.preprocess()
            except UnicodeDecodeError as e:
                self.stdout.write(b'UnicodeDecodeError: skipped file %s in %s (reason: %s)' % (
                 translatable.file, translatable.dirpath, e))
                continue

            build_files.append(build_file)

        if self.domain == b'djangojs':
            is_templatized = build_file.is_templatized
            args = [
             b'xgettext',
             b'-d', self.domain,
             b'--language=%s' % (b'C' if is_templatized else b'JavaScript',),
             b'--keyword=gettext_noop',
             b'--keyword=gettext_lazy',
             b'--keyword=ngettext_lazy:1,2',
             b'--keyword=pgettext:1c,2',
             b'--keyword=npgettext:1c,2,3',
             b'--output=-']
        else:
            if self.domain == b'django':
                args = [b'xgettext',
                 b'-d', self.domain,
                 b'--language=Python',
                 b'--keyword=gettext_noop',
                 b'--keyword=gettext_lazy',
                 b'--keyword=ngettext_lazy:1,2',
                 b'--keyword=ugettext_noop',
                 b'--keyword=ugettext_lazy',
                 b'--keyword=ungettext_lazy:1,2',
                 b'--keyword=pgettext:1c,2',
                 b'--keyword=npgettext:1c,2,3',
                 b'--keyword=pgettext_lazy:1c,2',
                 b'--keyword=npgettext_lazy:1c,2,3',
                 b'--output=-']
            else:
                return
            input_files = [ bf.work_path for bf in build_files ]
            with NamedTemporaryFile(mode=b'w+') as (input_files_list):
                input_files_list.write(force_str((b'\n').join(input_files), encoding=DEFAULT_LOCALE_ENCODING))
                input_files_list.flush()
                args.extend([b'--files-from', input_files_list.name])
                args.extend(self.xgettext_options)
                msgs, errors, status = popen_wrapper(args)
            if errors:
                if status != STATUS_OK:
                    for build_file in build_files:
                        build_file.cleanup()

                    raise CommandError(b'errors happened while running xgettext on %s\n%s' % (
                     (b'\n').join(input_files), errors))
                elif self.verbosity > 0:
                    self.stdout.write(errors)
            if msgs:
                if locale_dir is NO_LOCALE_DIR:
                    file_path = os.path.normpath(build_files[0].path)
                    raise CommandError(b'Unable to find a locale path to store translations for file %s' % file_path)
                for build_file in build_files:
                    msgs = build_file.postprocess_messages(msgs)

                potfile = os.path.join(locale_dir, b'%s.pot' % str(self.domain))
                write_pot_file(potfile, msgs)
            for build_file in build_files:
                build_file.cleanup()

    def write_po_file(self, potfile, locale):
        """
        Creates or updates the PO file for self.domain and :param locale:.
        Uses contents of the existing :param potfile:.

        Uses msgmerge, and msgattrib GNU gettext utilities.
        """
        basedir = os.path.join(os.path.dirname(potfile), locale, b'LC_MESSAGES')
        if not os.path.isdir(basedir):
            os.makedirs(basedir)
        pofile = os.path.join(basedir, b'%s.po' % str(self.domain))
        if os.path.exists(pofile):
            args = [
             b'msgmerge'] + self.msgmerge_options + [pofile, potfile]
            msgs, errors, status = popen_wrapper(args)
            if errors:
                if status != STATUS_OK:
                    raise CommandError(b'errors happened while running msgmerge\n%s' % errors)
                elif self.verbosity > 0:
                    self.stdout.write(errors)
        else:
            with io.open(potfile, b'r', encoding=b'utf-8') as (fp):
                msgs = fp.read()
            if not self.invoked_for_django:
                msgs = self.copy_plural_forms(msgs, locale)
        msgs = normalize_eols(msgs)
        msgs = msgs.replace(b'#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\n' % self.domain, b'')
        with io.open(pofile, b'w', encoding=b'utf-8') as (fp):
            fp.write(msgs)
        if self.no_obsolete:
            args = [
             b'msgattrib'] + self.msgattrib_options + [b'-o', pofile, pofile]
            msgs, errors, status = popen_wrapper(args)
            if errors:
                if status != STATUS_OK:
                    raise CommandError(b'errors happened while running msgattrib\n%s' % errors)
                elif self.verbosity > 0:
                    self.stdout.write(errors)

    def copy_plural_forms(self, msgs, locale):
        """
        Copies plural forms header contents from a Django catalog of locale to
        the msgs string, inserting it at the right place. msgs should be the
        contents of a newly created .po file.
        """
        django_dir = os.path.normpath(os.path.join(os.path.dirname(upath(django.__file__))))
        if self.domain == b'djangojs':
            domains = ('djangojs', 'django')
        else:
            domains = ('django', )
        for domain in domains:
            django_po = os.path.join(django_dir, b'conf', b'locale', locale, b'LC_MESSAGES', b'%s.po' % domain)
            if os.path.exists(django_po):
                with io.open(django_po, b'r', encoding=b'utf-8') as (fp):
                    m = plural_forms_re.search(fp.read())
                if m:
                    plural_form_line = force_str(m.group(b'value'))
                    if self.verbosity > 1:
                        self.stdout.write(b'copying plural forms: %s\n' % plural_form_line)
                    lines = []
                    found = False
                    for line in msgs.splitlines():
                        if not found and (not line or plural_forms_re.search(line)):
                            line = plural_form_line
                            found = True
                        lines.append(line)

                    msgs = (b'\n').join(lines)
                    break

        return msgs
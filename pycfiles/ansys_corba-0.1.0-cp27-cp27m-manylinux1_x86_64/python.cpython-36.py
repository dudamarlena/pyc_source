# uncompyle6 version 3.7.4
# Python bytecode 3.6 (3379)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: ./python.py
# Compiled at: 2018-07-20 10:03:27
# Size of source mod 2**32: 87264 bytes
"""omniORB Python bindings"""
from omniidl import idlast, idltype, idlutil, idlvisitor, output, main
import sys, os.path, keyword
cpp_args = [
 '-D__OMNIIDL_PYTHON__']
usage_string = '  -Wbstdout       Send generated stubs to stdout rather than a file\n  -Wbinline       Output stubs for #included files in line with the main file\n  -Wbfactories    Register value factories for all valuetypes\n  -Wbpackage=p    Put both Python modules and stub files in package p\n  -Wbmodules=p    Put Python modules in package p\n  -Wbstubs=p      Put stub files in package p\n  -Wbextern=f:p   Assume Python stub file for file f is in package p.\n  -Wbglobal=g     Module to use for global IDL scope (default _GlobalIDL)\n  -Wbami          Generate code for AMI'
pymodule_template = '# DO NOT EDIT THIS FILE!\n#\n# Python module @module@ generated by omniidl\n\nimport omniORB\nomniORB.updateModule("@package@@module@")\n\n# ** 1. Stub files contributing to this module\n\n# ** 2. Sub-modules\n\n# ** 3. End'
file_start = '# Python stubs generated by omniidl from @filename@\n# DO NOT EDIT THIS FILE!\n\nimport omniORB, _omnipy\nfrom omniORB import CORBA, PortableServer\n_0_CORBA = CORBA\n@ami_import@\n\n_omnipy.checkVersion(4,2, __file__, 1)\n\ntry:\n    property\nexcept NameError:\n    def property(*args):\n        return None\n'
file_end = '_exported_modules = ( @export_string@)\n\n# The end.'
module_start = '\n#\n# Start of module "@sname@"\n#\n__name__ = "@package@@sname@"\n_0_@sname@ = omniORB.openModule("@package@@sname@", r"@filename@")\n_0_@s_sname@ = omniORB.openModule("@package@@s_sname@", r"@filename@")\n'
module_end = '\n#\n# End of module "@sname@"\n#\n__name__ = "@package@@modname@"\n'
import_idl_file = '\n# #include "@idlfile@"\nimport @ifilename@'
open_imported_module_name = '_0_@imodname@ = omniORB.openModule("@package@@imodname@")\n_0_@s_imodname@ = omniORB.openModule("@package@@s_imodname@")'
forward_interface = '\n# forward @abstract@interface @ifid@;\n_0_@modname@._d_@ifid@ = (omniORB.tcInternal.@tvkind@, "@repoId@", "@ifid@")\nomniORB.typeMapping["@repoId@"] = _0_@modname@._d_@ifid@'
interface_class = '\n# @abstract@interface @ifid@\n_0_@modname@._d_@ifid@ = (omniORB.tcInternal.@tvkind@, "@repoId@", "@ifid@")\nomniORB.typeMapping["@repoId@"] = _0_@modname@._d_@ifid@\n_0_@modname@.@ifid@ = omniORB.newEmptyClass()\nclass @ifid@ @inherits@:\n    _NP_RepositoryId = _0_@modname@._d_@ifid@[1]\n\n    def __init__(self, *args, **kw):\n        raise RuntimeError("Cannot construct objects of this type.")\n\n    _nil = CORBA.Object._nil\n'
interface_descriptor = '\n_0_@modname@.@ifid@ = @ifid@\n_0_@modname@._tc_@ifid@ = omniORB.tcInternal.createTypeCode(_0_@modname@._d_@ifid@)\nomniORB.registerType(@ifid@._NP_RepositoryId, _0_@modname@._d_@ifid@, _0_@modname@._tc_@ifid@)'
callables_header = '\n# @ifid@ operations and attributes'
attribute_get_descriptor = '@ifid@._d__get_@attr@ = ((),(@descr@,),None)'
attribute_set_descriptor = '@ifid@._d__set_@attr@ = ((@descr@,),(),None)'
operation_descriptor = '@ifid@._d_@opname@ = (@inds@, @outds@, @excs@@options@)'
objref_class = '\n# @ifid@ object reference\nclass _objref_@ifid@ (@inherits@):\n    _NP_RepositoryId = @ifid@._NP_RepositoryId\n\n    def __init__(self, obj):'
objref_inherit_init = '        @inclass@.__init__(self, obj)'
objref_object_init = '        CORBA.Object.__init__(self, obj)'
objref_attribute_get = '\n    def _get_@attr@(self, *args):\n        return self._obj.invoke("_get_@attr@", _0_@modname@.@ifid@._d__get_@attr@, args)'
objref_attribute_set = '\n    def _set_@attr@(self, *args):\n        return self._obj.invoke("_set_@attr@", _0_@modname@.@ifid@._d__set_@attr@, args)'
objref_attribute_property = '\n    @attr@ = property(_get_@attr@, _set_@attr@)\n'
objref_readonly_attribute_property = '\n    @attr@ = property(_get_@attr@)\n'
objref_operation = '\n    def @opname@(self, *args):\n        return self._obj.invoke("@r_opname@", _0_@modname@.@ifid@._d_@opname@, args)'
objref_ami_sendc = '\n    def @ami_opname@(self, ami_handler, *args):\n        return self._obj.invoke_sendc("@r_opname@", _0_@modname@.@ifid@._d_@opname@, args, "@excep_name@", ami_handler)'
objref_ami_sendp = '\n    def @ami_opname@(self, *args):\n        return _0_@modname@._impl_@poller_class@(self._obj.invoke_sendp("@r_opname@", _0_@modname@.@ifid@._d_@opname@, args, "@excep_name@"))'
objref_register = '\nomniORB.registerObjref(@ifid@._NP_RepositoryId, _objref_@ifid@)\n_0_@modname@._objref_@ifid@ = _objref_@ifid@\ndel @ifid@, _objref_@ifid@'
skeleton_class = '\n# @ifid@ skeleton\n__name__ = "@package@@s_modname@"\nclass @ifid@ (@inherits@):\n    _NP_RepositoryId = _0_@modname@.@ifid@._NP_RepositoryId\n'
skeleton_methodmap = '\n    _omni_op_d = @methodmap@'
skeleton_inheritmap = '    _omni_op_d.update(@inheritclass@._omni_op_d)'
skeleton_end = '\n@ifid@._omni_skeleton = @ifid@\n_0_@s_modname@.@ifid@ = @ifid@\nomniORB.registerSkeleton(@ifid@._NP_RepositoryId, @ifid@)\ndel @ifid@\n__name__ = "@package@@modname@"'
skeleton_set_skel = '\n@ifid@._omni_skeleton = @ifid@\n'
constant_at_module_scope = '_0_@modname@.@cname@ = @value@'
constant = '@cname@ = @value@'
typedef_header = '\n# typedef ... @tdname@\nclass @tdname@:\n    _NP_RepositoryId = "@repoId@"\n    def __init__(self, *args, **kw):\n        raise RuntimeError("Cannot construct objects of this type.")'
typedef_struct_union_header = '\n# typedef ... @tdname@\nclass @tdname@ (@parent@):\n    _NP_RepositoryId = "@repoId@"\n'
typedef_fixed_header = '# typedef ... @tdname@\n@tdname@ = omniORB.fixedConstructor("@repoId@", @digits@, @scale@)'
typedef_at_module_scope = '_0_@modname@.@tdname@ = @tdname@\n_0_@modname@._d_@tdname@  = @desc@\n_0_@modname@._ad_@tdname@ = (omniORB.tcInternal.tv_alias, @tdname@._NP_RepositoryId, "@tdname@", @tddesc@)\n_0_@modname@._tc_@tdname@ = omniORB.tcInternal.createTypeCode(_0_@modname@._ad_@tdname@)\nomniORB.registerType(@tdname@._NP_RepositoryId, _0_@modname@._ad_@tdname@, _0_@modname@._tc_@tdname@)\ndel @tdname@'
typedef = '_d_@tdname@  = @desc@\n_ad_@tdname@ = (omniORB.tcInternal.tv_alias, @tdname@._NP_RepositoryId, "@tdname@", @tddesc@)\n_tc_@tdname@ = omniORB.tcInternal.createTypeCode(_ad_@tdname@)\nomniORB.registerType(@tdname@._NP_RepositoryId, _ad_@tdname@, _tc_@tdname@)'
forward_struct_descr_at_module_scope = '\n# Forward struct @sname@\n_0_@modname@._d_@sname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\nomniORB.typeMapping["@repoId@"] = _0_@modname@._d_@sname@'
forward_struct_descr = '\n# Forward struct @sname@\n_d_@sname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\nomniORB.typeMapping["@repoId@"] = _d_@sname@'
recursive_struct_descr_at_module_scope = '\n# Recursive struct @sname@\n_0_@modname@._d_@sname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\nomniORB.typeMapping["@repoId@"] = _0_@modname@._d_@sname@'
recursive_struct_descr = '\n# Recursive struct @sname@\n_d_@sname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\n_0_@scope@._d_@sname@ = _d_@sname@\nomniORB.typeMapping["@repoId@"] = _d_@sname@'
struct_class = '\n# struct @sname@\n_0_@scopedname@ = omniORB.newEmptyClass()\nclass @sname@ (omniORB.StructBase):\n    _NP_RepositoryId = "@repoId@"\n'
struct_class_name = '    _NP_ClassName = "@cname@"\n'
struct_class_init = '    def __init__(self@mnames@):'
struct_init_member = '        self.@mname@ = @mname@'
struct_descriptor_at_module_scope = '\n_0_@modname@.@sname@ = @sname@\n_0_@modname@._d_@sname@  = (omniORB.tcInternal.tv_struct, @sname@, @sname@._NP_RepositoryId, "@sname@"@mdescs@)'
struct_register_at_module_scope = '_0_@modname@._tc_@sname@ = omniORB.tcInternal.createTypeCode(_0_@modname@._d_@sname@)\nomniORB.registerType(@sname@._NP_RepositoryId, _0_@modname@._d_@sname@, _0_@modname@._tc_@sname@)\ndel @sname@'
struct_descriptor = '\n_d_@sname@  = _0_@scope@._d_@sname@ = (omniORB.tcInternal.tv_struct, @sname@, @sname@._NP_RepositoryId, "@sname@"@mdescs@)'
struct_register = '_tc_@sname@ = omniORB.tcInternal.createTypeCode(_d_@sname@)\nomniORB.registerType(@sname@._NP_RepositoryId, _d_@sname@, _tc_@sname@)'
struct_module_descriptors = '\n_0_@modname@._d_@sname@  = _d_@sname@\n_0_@modname@._tc_@sname@ = _tc_@sname@\ndel @sname@, _d_@sname@, _tc_@sname@'
exception_class = '\n# exception @sname@\n_0_@scopedname@ = omniORB.newEmptyClass()\nclass @sname@ (CORBA.UserException):\n    _NP_RepositoryId = "@repoId@"\n'
exception_class_init = '    def __init__(self@mnames@):\n        CORBA.UserException.__init__(self@mnames@)'
exception_init_member = '        self.@mname@ = @mname@'
exception_descriptor_at_module_scope = '\n_0_@modname@.@sname@ = @sname@\n_0_@modname@._d_@sname@  = (omniORB.tcInternal.tv_except, @sname@, @sname@._NP_RepositoryId, "@sname@"@mdescs@)\n_0_@modname@._tc_@sname@ = omniORB.tcInternal.createTypeCode(_0_@modname@._d_@sname@)\nomniORB.registerType(@sname@._NP_RepositoryId, _0_@modname@._d_@sname@, _0_@modname@._tc_@sname@)\ndel @sname@'
exception_descriptor = '\n_d_@sname@  = (omniORB.tcInternal.tv_except, @sname@, @sname@._NP_RepositoryId, "@sname@"@mdescs@)\n_tc_@sname@ = omniORB.tcInternal.createTypeCode(_d_@sname@)\nomniORB.registerType(@sname@._NP_RepositoryId, _d_@sname@, _tc_@sname@)'
forward_union_descr_at_module_scope = '\n# Forward union @uname@\n_0_@modname@._d_@uname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\nomniORB.typeMapping["@repoId@"] = _0_@modname@._d_@uname@'
forward_union_descr = '\n# Forward union @uname@\n_d_@uname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\nomniORB.typeMapping["@repoId@"] = _d_@uname@'
recursive_union_descr_at_module_scope = '\n# Recursive union @uname@\n_0_@modname@._d_@uname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\nomniORB.typeMapping["@repoId@"] = _0_@modname@._d_@uname@'
recursive_union_descr = '\n# Recursive union @uname@\n_d_@uname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\n_0_@scope@._d_@uname@ = _d_@uname@\nomniORB.typeMapping["@repoId@"] = _d_@uname@'
union_class = '\n# union @uname@\n_0_@scopedname@ = omniORB.newEmptyClass()\nclass @uname@ (omniORB.Union):\n    _NP_RepositoryId = "@repoId@"'
union_class_name = '    _NP_ClassName = "@cname@"\n'
union_descriptor_at_module_scope = '\n_0_@modname@.@uname@ = @uname@\n\n@uname@._m_to_d = {@m_to_d@}\n@uname@._d_to_m = {@d_to_m@}\n@uname@._def_m  = @def_m@\n@uname@._def_d  = @def_d@\n\n_0_@modname@._m_@uname@  = (@m_un@,)\n_0_@modname@._d_@uname@  = (omniORB.tcInternal.tv_union, @uname@, @uname@._NP_RepositoryId, "@uname@", @stype@, @defpos@, _0_@modname@._m_@uname@, @m_def@, {@d_map@})'
union_register_at_module_scope = '_0_@modname@._tc_@uname@ = omniORB.tcInternal.createTypeCode(_0_@modname@._d_@uname@)\nomniORB.registerType(@uname@._NP_RepositoryId, _0_@modname@._d_@uname@, _0_@modname@._tc_@uname@)\ndel @uname@'
union_descriptor = '\n@uname@._m_to_d = {@m_to_d@}\n@uname@._d_to_m = {@d_to_m@}\n@uname@._def_m  = @def_m@\n@uname@._def_d  = @def_d@\n\n_m_@uname@  = (@m_un@,)\n_d_@uname@  = _0_@scope@._d_@uname@ = (omniORB.tcInternal.tv_union, @uname@, @uname@._NP_RepositoryId, "@uname@", @stype@, @defpos@, _m_@uname@, @m_def@, {@d_map@})'
union_register = '_tc_@uname@ = omniORB.tcInternal.createTypeCode(_d_@uname@)\nomniORB.registerType(@uname@._NP_RepositoryId, _d_@uname@, _tc_@uname@)'
enum_start = '\n# enum @ename@'
enum_item_at_module_scope = '_0_@modname@.@eitem@ = omniORB.EnumItem("@item@", @eval@)'
enum_object_and_descriptor_at_module_scope = '_0_@modname@.@ename@ = omniORB.Enum("@repoId@", (@eitems@,))\n\n_0_@modname@._d_@ename@  = (omniORB.tcInternal.tv_enum, _0_@modname@.@ename@._NP_RepositoryId, "@ename@", _0_@modname@.@ename@._items)\n_0_@modname@._tc_@ename@ = omniORB.tcInternal.createTypeCode(_0_@modname@._d_@ename@)\nomniORB.registerType(_0_@modname@.@ename@._NP_RepositoryId, _0_@modname@._d_@ename@, _0_@modname@._tc_@ename@)'
enum_item = '@eitem@ = omniORB.EnumItem("@item@", @eval@)'
enum_object_and_descriptor = '@ename@ = omniORB.Enum("@repoId@", (@eitems@,))\n\n_d_@ename@  = (omniORB.tcInternal.tv_enum, @ename@._NP_RepositoryId, "@ename@", @ename@._items)\n_tc_@ename@ = omniORB.tcInternal.createTypeCode(_d_@ename@)\nomniORB.registerType(@ename@._NP_RepositoryId, _d_@ename@, _tc_@ename@)'
value_forward_at_module_scope = '\n# forward valuetype @vname@\n_0_@modname@._d_@vname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\nomniORB.typeMapping["@repoId@"] = _0_@modname@._d_@vname@\n'
value_class = '\n# valuetype @vname@\n_0_@modname@._d_@vname@ = (omniORB.tcInternal.tv__indirect, ["@repoId@"])\nomniORB.typeMapping["@repoId@"] = _0_@modname@._d_@vname@\n_0_@modname@.@vname@ = omniORB.newEmptyClass()\n\nclass @vname@ (@inherits@):\n    _NP_RepositoryId = "@repoId@"\n\n    def __init__(self, *args, **kwargs):\n        if args:\n            if len(args) != @arglen@:\n                raise TypeError("@vname@() takes @arglen@ argument@s@ "\n                                "(%d given)" % len(args))\n            @set_args@\n        if kwargs:\n            self.__dict__.update(kwargs)\n'
valueabs_class = '\n# abstract valuetype @vname@\nclass @vname@ (@inherits@):\n    _NP_RepositoryId = "@repoId@"\n\n    def __init__(self, *args, **kwargs):\n        raise RuntimeError("Cannot construct objects of this type.")\n'
value_register_factory = 'omniORB.registerValueFactory(@vname@._NP_RepositoryId, @vname@)\n'
value_descriptor_at_module_scope = '_0_@modname@.@vname@ = @vname@\n_0_@modname@._d_@vname@  = (omniORB.tcInternal.tv_value, @vname@, @vname@._NP_RepositoryId, "@vname@", @modifier@, @tbaseids@, @basedesc@, @mdescs@)\n_0_@modname@._tc_@vname@ = omniORB.tcInternal.createTypeCode(_0_@modname@._d_@vname@)\nomniORB.registerType(@vname@._NP_RepositoryId, _0_@modname@._d_@vname@, _0_@modname@._tc_@vname@)\ndel @vname@\n'
value_objref_register = '\nomniORB.registerObjref(@ifid@._NP_RepositoryId, _objref_@ifid@)\n_0_@modname@._objref_@ifid@ = _objref_@ifid@\ndel _objref_@ifid@'
valuebox = '\n# valuebox @boxname@\nclass @boxname@:\n    _NP_RepositoryId = "@repoId@"\n    def __init__(self, *args, **kw):\n        raise RuntimeError("Cannot construct objects of this type.")\n\n_0_@modname@.@boxname@ = @boxname@\n_0_@modname@._d_@boxname@  = (omniORB.tcInternal.tv_value_box, @boxname@, @boxname@._NP_RepositoryId, "@boxname@", @boxdesc@)\n_0_@modname@._tc_@boxname@ = omniORB.tcInternal.createTypeCode(_0_@modname@._d_@boxname@)\nomniORB.registerType(@boxname@._NP_RepositoryId, _0_@modname@._d_@boxname@, _0_@modname@._tc_@boxname@)\nomniORB.registerValueFactory(@boxname@._NP_RepositoryId, @boxname@)\ndel @boxname@\n'
ami_poller_impl = '\n# Implementation of @vname@\nclass _impl_@vname@ (@vname@, omniORB.ami.PollerImpl):\n    def __init__(self, poller):\n        omniORB.ami.PollerImpl.__init__(self, poller)\n'
ami_poller_op = '    def @poller_opname@(self, ami_timeout):\n        return self._poller.poll("@opname@", ami_timeout)\n'
ami_poller_register = '\n_0_@modname@._impl_@vname@ = _impl_@vname@\nomniORB.registerValueFactory(@vname@._NP_RepositoryId, _impl_@vname@)\ndel _impl_@vname@\n'
example_start = '#!/usr/bin/env python\n\n# Python example implementations generated from @filename@\n\nimport CORBA, PortableServer\n\n# Import the Python stub modules so type definitions are available.\n'
example_import_skels = '\n# Import the Python Skeleton modules so skeleton base classes are available.\n'
example_import = 'import @module@'
example_classdef = '\n\n# Implementation of interface @ccname@\n\nclass @ifname@_i (@skname@):\n@inheritance_note@\n    def __init__(self):\n        # Initialise member variables here\n        pass\n'
example_opdef = '    # @signature@\n    def @opname@(self@args@):\n        raise CORBA.NO_IMPLEMENT(0, CORBA.COMPLETED_NO)\n        # *** Implement me\n        # Must return: @returnspec@\n'
example_end = '\ndef main():\n    import sys\n    \n    # Initialise the ORB\n    orb = CORBA.ORB_init(sys.argv)\n    \n    # As an example, we activate an object in the Root POA\n    poa = orb.resolve_initial_references("RootPOA")\n\n    # Create an instance of a servant class\n    servant = @ifname@_i()\n\n    # Activate it in the Root POA\n    poa.activate_object(servant)\n\n    # Get the object reference to the object\n    objref = servant._this()\n    \n    # Print a stringified IOR for it\n    print orb.object_to_string(objref)\n\n    # Activate the Root POA\'s manager\n    poa._get_the_POAManager().activate()\n\n    # Run the ORB, blocking this thread\n    orb.run()\n\n\nif __name__ == "__main__":\n    main()\n'
imported_files = {}
exported_modules = {}
output_inline = 0
global_module = '_GlobalIDL'
module_package = ''
stub_package = ''
stub_directory = ''
all_factories = 0
example_impl = 0
extern_stub_pkgs = {}
generate_ami = 0

def error_exit(message):
    sys.stderr.write(main.cmdname + ': ' + message + '\n')
    sys.exit(1)


def run(tree, args):
    global all_factories
    global example_impl
    global exported_modules
    global extern_stub_pkgs
    global generate_ami
    global global_module
    global imported_files
    global main_idl_file
    global module_package
    global output_inline
    global stub_directory
    global stub_package
    imported_files.clear()
    exported_modules.clear()
    use_stdout = 0
    create_package = 1
    for arg in args:
        if arg == 'stdout':
            use_stdout = 1
            create_package = 0
        elif arg == 'no_package':
            create_package = 0
        elif arg == 'inline':
            output_inline = 1
        elif arg == 'factories':
            all_factories = 1
        elif arg[:8] == 'modules=':
            module_package = arg[8:]
            if module_package != '':
                module_package = module_package + '.'
        elif arg[:6] == 'stubs=':
            stub_package = arg[6:]
            stub_directory = (os.path.join)(*stub_package.split('.'))
            if stub_package != '':
                stub_package = stub_package + '.'
        elif arg[:8] == 'package=':
            module_package = stub_package = arg[8:]
            stub_directory = (os.path.join)(*stub_package.split('.'))
            if module_package != '':
                module_package = stub_package = module_package + '.'
        elif arg[:7] == 'global=':
            global_module = arg[7:]
            if global_module == '':
                error_exit('You may not have an unnamed global module.')
        elif arg == 'example':
            example_impl = 1
        else:
            if arg[:7] == 'extern=':
                f_p = arg[7:].split(':', 1)
                if len(f_p) == 1:
                    extern_stub_pkgs[f_p[0]] = None
                else:
                    extern_stub_pkgs[f_p[0]] = f_p[1]
            else:
                if arg == 'ami':
                    generate_ami = 1
                else:
                    sys.stderr.write(main.cmdname + ': Warning: Python back-end does not understand argument: ' + arg + '\n')

    main_idl_file = tree.file()
    outpybasename = outputFileName(main_idl_file)
    outpymodule = stub_package + outpybasename
    outpyname = os.path.join(stub_directory, outpybasename + '.py')
    imported_files[outpybasename] = 1
    if create_package:
        checkStubPackage(stub_package)
    else:
        if use_stdout:
            st = output.Stream(sys.stdout, 4)
        else:
            try:
                st = output.Stream(open(outpyname, 'w'), 4)
            except IOError:
                error_exit('Cannot open "%s" for writing.' % outpyname)

        if generate_ami:
            ami_import = 'import omniORB.ami'
            imported_files['messaging_idl'] = 1
            from omniidl_be import ami
            tree.accept(ami.AMIVisitor())
        else:
            ami_import = ''
    st.out(file_start, filename=main_idl_file, ami_import=ami_import)
    pv = PythonVisitor(st, outpymodule)
    tree.accept(pv)
    dv = DocstringVisitor(st)
    tree.accept(dv)
    dv.output()
    exports = sorted(exported_modules.keys())
    export_list = ['"%s%s"' % (module_package, s) for s in exports]
    if len(export_list) == 1:
        export_list.append('')
    export_string = ', '.join(export_list)
    st.out(file_end, export_string=export_string)
    if create_package:
        updateModules(exports, outpymodule)
    if example_impl:
        implname = os.path.join(stub_directory, outpybasename + '_example.py')
        exst = output.Stream(open(implname, 'w'), 4)
        exst.out(example_start, filename=main_idl_file)
        for mod in exports:
            exst.out(example_import, module=mod)

        exst.out(example_import_skels)
        for mod in exports:
            exst.out(example_import, module=(skeletonModuleName(mod)))

        ev = ExampleVisitor(exst)
        tree.accept(ev)
        exst.out(example_end, ifname=(ev.first))


class PythonVisitor:

    def __init__(self, st, outpymodule):
        self.st = st
        self.outpymodule = outpymodule

    def handleImported(self, node):
        if node.mainFile() or output_inline:
            return 0
        else:
            ifilename = outputFileName(node.file())
            if ifilename not in imported_files:
                imported_files[ifilename] = 1
                ibasename, ext = os.path.splitext(os.path.basename(node.file()))
                if ibasename in extern_stub_pkgs:
                    ipackage = extern_stub_pkgs[ibasename]
                    if ipackage:
                        fn = ipackage + '.' + ifilename
                    else:
                        fn = ifilename
                else:
                    fn = stub_package + ifilename
                self.st.out(import_idl_file, idlfile=(node.file()),
                  ifilename=fn)
            return 1

    def visitAST(self, node):
        self.at_module_scope = 1
        self.at_global_scope = 1
        self.currentScope = ['_0_' + global_module]
        decls_in_global_module = 0
        for n in node.declarations():
            if not isinstance(n, idlast.Module):
                decls_in_global_module = 1
                break

        if decls_in_global_module:
            self.modname = global_module
            self.st.out(module_start, sname=global_module,
              s_sname=(skeletonModuleName(global_module)),
              filename=(node.file()),
              package=module_package)
        else:
            self.modname = self.outpymodule
        for n in node.declarations():
            n.accept(self)

        if decls_in_global_module:
            exported_modules[global_module] = 1
            self.st.out(module_end, modname=(self.outpymodule), sname=global_module,
              package='')

    def visitModule(self, node):
        if self.handleImported(node):
            imodname = dotName(node.scopedName())
            ibasename, ext = os.path.splitext(os.path.basename(node.file()))
            if ibasename in extern_stub_pkgs:
                package = extern_stub_pkgs[ibasename]
                if package is None:
                    package = ''
                else:
                    package = package + '.'
            else:
                package = module_package
            self.st.out(open_imported_module_name, imodname=imodname,
              s_imodname=(skeletonModuleName(imodname)),
              package=package)
        else:
            if not self.at_module_scope:
                raise AssertionError
            else:
                sname = dotName(node.scopedName())
                if node.mainFile() or output_inline:
                    self.st.out(module_start, sname=sname,
                      s_sname=(skeletonModuleName(sname)),
                      filename=(node.file()),
                      package=module_package)
                parentmodname = self.modname
                self.modname = dotName(node.scopedName())
                ags = self.at_global_scope
                if ags:
                    self.currentScope = [
                     '_0_' + node.identifier()]
                else:
                    self.currentScope.append(node.identifier())
                self.at_global_scope = 0
                for n in node.definitions():
                    n.accept(self)

                if ags:
                    self.currentScope = [
                     '_0_' + global_module]
                else:
                    self.currentScope.pop()
            self.at_global_scope = ags
            self.modname = parentmodname
            if node.mainFile() or output_inline:
                exported_modules[sname] = 1
                if parentmodname == self.outpymodule:
                    end_package = ''
                else:
                    end_package = module_package
                self.st.out(module_end, modname=parentmodname, sname=sname, package=end_package)

    def visitForward(self, node):
        if self.handleImported(node):
            return
        else:
            assert self.at_module_scope
            ifid = mangle(node.identifier())
            repoId = node.repoId()
            if node.abstract():
                tvkind = 'tv_abstract_interface'
                abstract = 'abstract '
            else:
                tvkind = 'tv_objref'
            abstract = ''
        self.st.out(forward_interface, ifid=ifid, tvkind=tvkind, repoId=repoId,
          abstract=abstract,
          modname=(self.modname))

    def visitInterface(self, node):
        if self.handleImported(node):
            return
        else:
            if not self.at_module_scope:
                raise AssertionError
            else:
                ifid = mangle(node.identifier())
                if len(node.inherits()) > 0:
                    inheritl = []
                    for i in node.inherits():
                        i = i.fullDecl()
                        inheritl.append(dotName(fixupScopedName(i.scopedName())))

                    inherits = '(' + ', '.join(inheritl) + ')'
                else:
                    inherits = ''
                if node.abstract():
                    tvkind = 'tv_abstract_interface'
                    abstract = 'abstract '
                else:
                    tvkind = 'tv_objref'
                    abstract = ''
                self.st.out(interface_class, ifid=ifid, tvkind=tvkind, inherits=inherits,
                  repoId=(node.repoId()),
                  abstract=abstract,
                  modname=(self.modname))
                if len(node.declarations()) > 0:
                    self.st.inc_indent()
                    self.at_module_scope = 0
                    self.currentScope.append(node.identifier())
                    for d in node.declarations():
                        d.accept(self)

                    self.currentScope.pop()
                    self.at_module_scope = 1
                    self.st.dec_indent()
                    self.st.out('')
                self.st.out(interface_descriptor, modname=(self.modname),
                  ifid=ifid)
                if len(node.callables()) > 0:
                    self.st.out(callables_header, ifid=ifid)
                for c in node.callables():
                    if isinstance(c, idlast.Attribute):
                        descr = typeToDescriptor(c.attrType())
                        for attr in c.identifiers():
                            self.st.out(attribute_get_descriptor, attr=attr,
                              descr=descr,
                              ifid=ifid)
                            if not c.readonly():
                                self.st.out(attribute_set_descriptor, attr=attr,
                                  descr=descr,
                                  ifid=ifid)

                    else:
                        inds, outds, excs, ctxts, cv = operationToDescriptors(c)
                        options = ''
                        if cv:
                            ctxts = ctxts or 'None'
                        if ctxts:
                            options = ', ' + ctxts
                        if cv:
                            options = options + ', 1'
                        self.st.out(operation_descriptor, opname=(mangle(c.identifier())),
                          inds=inds,
                          outds=outds,
                          excs=excs,
                          options=options,
                          ifid=ifid)

                if node.inherits():
                    inheritl = []
                    for i in node.inherits():
                        i = i.fullDecl()
                        sn = fixupScopedName(i.scopedName())
                        inheritl.append(dotName(sn[:-1] + ['_objref_' + sn[(-1)]]))

                    inherits = ', '.join(inheritl)
                else:
                    inherits = 'CORBA.Object'
                self.st.out(objref_class, ifid=ifid, inherits=inherits)
                if node.inherits():
                    for inclass in inheritl:
                        self.st.out(objref_inherit_init, inclass=inclass)

                else:
                    self.st.out(objref_object_init)
                for c in node.callables():
                    if isinstance(c, idlast.Attribute):
                        for attr in c.identifiers():
                            self.st.out(objref_attribute_get, attr=attr,
                              ifid=ifid,
                              modname=(self.modname))
                            if c.readonly():
                                self.st.out(objref_readonly_attribute_property, attr=attr)
                            else:
                                self.st.out(objref_attribute_set, attr=attr,
                                  ifid=ifid,
                                  modname=(self.modname))
                                self.st.out(objref_attribute_property, attr=attr)

                    else:
                        opname = mangle(c.identifier())
                        self.st.out(objref_operation, opname=opname,
                          r_opname=(c.identifier()),
                          ifid=ifid,
                          modname=(self.modname))

                for c in getattr(node, '_ami_ops', []):
                    ami_opname = mangle(c.identifier())
                    ami_from = c._ami_from
                    from_ident = ami_from.identifier()
                    if isinstance(ami_from, idlast.Declarator):
                        if c._ami_setter:
                            from_op = '_set_' + from_ident
                            excep_op = ami_from._ami_set_handler_excep.identifier()
                        else:
                            from_op = '_get_' + from_ident
                            excep_op = ami_from._ami_get_handler_excep.identifier()
                    else:
                        from_op = from_ident
                        excep_op = ami_from._ami_handler_excep.identifier()
                    send = c.identifier().split('_')[0]
                    if send == 'sendc':
                        self.st.out(objref_ami_sendc, ami_opname=ami_opname,
                          opname=(mangle(from_op)),
                          r_opname=from_op,
                          excep_name=excep_op,
                          ifid=ifid,
                          modname=(self.modname))
                    else:
                        poller_class = node._ami_poller.identifier()
                        self.st.out(objref_ami_sendp, ami_opname=ami_opname,
                          opname=(mangle(from_op)),
                          r_opname=from_op,
                          excep_name=excep_op,
                          ifid=ifid,
                          modname=(self.modname),
                          poller_class=poller_class)

                self.st.out(objref_register, ifid=ifid, modname=(self.modname))
                if node.inherits():
                    inheritl = []
                    for i in node.inherits():
                        i = i.fullDecl()
                        fsn = fixupScopedName(i.scopedName())
                        dsn = dotName(fsn)
                        ssn = skeletonModuleName(dsn)
                        inheritl.append(ssn)

                    inherits = ', '.join(inheritl)
                else:
                    inherits = 'PortableServer.Servant'
            self.st.out(skeleton_class, ifid=ifid,
              inherits=inherits,
              modname=(self.modname),
              s_modname=(skeletonModuleName(self.modname)),
              package=module_package)
            methodl = []
            for c in node.callables():
                if isinstance(c, idlast.Attribute):
                    for attr in c.identifiers():
                        methodl.append('"_get_' + attr + '": ' + '_0_' + self.modname + '.' + ifid + '.' + '_d__get_' + attr)
                        if not c.readonly():
                            methodl.append('"_set_' + attr + '": ' + '_0_' + self.modname + '.' + ifid + '.' + '_d__set_' + attr)

                else:
                    opname = c.identifier()
                    m_opname = mangle(opname)
                    methodl.append('"' + opname + '": ' + '_0_' + self.modname + '.' + ifid + '.' + '_d_' + m_opname)

            methodmap = '{' + ', '.join(methodl) + '}'
            self.st.out(skeleton_methodmap, methodmap=methodmap)
            if node.inherits():
                for inheritclass in inheritl:
                    self.st.out(skeleton_inheritmap, inheritclass=inheritclass)

        self.st.out(skeleton_end, ifid=ifid,
          modname=(self.modname),
          s_modname=(skeletonModuleName(self.modname)),
          package=module_package)

    def visitConst(self, node):
        if self.handleImported(node):
            return
        else:
            cname = mangle(node.identifier())
            if self.at_module_scope:
                value = valueToString(node.value(), node.constKind(), [])
            else:
                value = valueToString(node.value(), node.constKind(), self.currentScope)
            if self.at_module_scope:
                self.st.out(constant_at_module_scope, cname=cname,
                  value=value,
                  modname=(self.modname))
            else:
                self.st.out(constant, cname=cname,
                  value=value)

    def visitTypedef(self, node):
        if self.handleImported(node):
            return
        if node.constrType():
            node.aliasType().decl().accept(self)
        for decl in node.declarators():
            tdname = mangle(decl.identifier())
            if self.at_module_scope:
                desc = typeAndDeclaratorToDescriptor(node.aliasType(), decl, [])
                tddesc = typeAndDeclaratorToDescriptor(node.aliasType(), decl, [], 1)
                unaliased_type = node.aliasType().unalias()
                if len(decl.sizes()) == 0:
                    if unaliased_type.kind() in [idltype.tk_struct,
                     idltype.tk_union]:
                        parent = dotName(fixupScopedName(unaliased_type.decl().scopedName()))
                        self.st.out(typedef_struct_union_header, tdname=tdname,
                          repoId=(decl.repoId()),
                          parent=parent)
                if len(decl.sizes()) == 0 and unaliased_type.kind() == idltype.tk_fixed:
                    self.st.out(typedef_fixed_header, tdname=tdname,
                      repoId=(decl.repoId()),
                      digits=(unaliased_type.digits()),
                      scale=(unaliased_type.scale()))
                else:
                    self.st.out(typedef_header, tdname=tdname,
                      repoId=(decl.repoId()))
                self.st.out(typedef_at_module_scope, tdname=tdname,
                  desc=desc,
                  tddesc=tddesc,
                  modname=(self.modname))
            else:
                desc = typeAndDeclaratorToDescriptor(node.aliasType(), decl, self.currentScope)
                tddesc = typeAndDeclaratorToDescriptor(node.aliasType(), decl, self.currentScope, 1)
                unaliased_type = node.aliasType().unalias()
                if len(decl.sizes()) == 0:
                    if unaliased_type.kind() in [idltype.tk_struct,
                     idltype.tk_union]:
                        psname = unaliased_type.decl().scopedName()
                        myscope = decl.scopedName()[:-1]
                        if psname[:len(myscope)] == myscope:
                            parent = dotName(psname[len(myscope):])
                        else:
                            parent = dotName(fixupScopedName(psname))
                        self.st.out(typedef_struct_union_header, tdname=tdname,
                          repoId=(decl.repoId()),
                          parent=parent)
                else:
                    self.st.out(typedef_header, tdname=tdname,
                      repoId=(decl.repoId()))
                self.st.out(typedef, tdname=tdname,
                  desc=desc,
                  tddesc=tddesc)

    def visitStruct(self, node):
        if self.handleImported(node):
            return
        else:
            sname = mangle(node.identifier())
            fscopedName = fixupScopedName(node.scopedName(), '')
            if node.recursive():
                if self.at_module_scope:
                    self.st.out(recursive_struct_descr_at_module_scope, sname=sname,
                      repoId=(node.repoId()),
                      modname=(self.modname))
                else:
                    self.st.out(recursive_struct_descr, sname=sname,
                      repoId=(node.repoId()),
                      scope=(dotName(fscopedName[:-1])))
            self.st.out(struct_class, sname=sname,
              repoId=(node.repoId()),
              scopedname=(dotName(fscopedName)))
            if not self.at_module_scope:
                self.st.out(struct_class_name, cname=(dotName(fscopedName)))
            mnamel = []
            mdescl = []
            for mem in node.members():
                if mem.constrType():
                    self.st.inc_indent()
                    ams = self.at_module_scope
                    self.at_module_scope = 0
                    self.currentScope.append(node.identifier())
                    mem.memberType().decl().accept(self)
                    self.currentScope.pop()
                    self.at_module_scope = ams
                    self.st.dec_indent()
                    self.st.out('')
                for decl in mem.declarators():
                    mnamel.append(mangle(decl.identifier()))
                    mdescl.append('"' + mangle(decl.identifier()) + '"')
                    if self.at_module_scope:
                        mdescl.append(typeAndDeclaratorToDescriptor(mem.memberType(), decl, []))
                    else:
                        mdescl.append(typeAndDeclaratorToDescriptor(mem.memberType(), decl, self.currentScope))

            if len(mnamel) > 0:
                mnames = ', ' + ', '.join(mnamel)
                self.st.out(struct_class_init, mnames=mnames)
                for mname in mnamel:
                    self.st.out(struct_init_member, mname=mname)

            if len(mdescl) > 0:
                mdescs = ', ' + ', '.join(mdescl)
            else:
                mdescs = ''
            if self.at_module_scope:
                self.st.out(struct_descriptor_at_module_scope, sname=sname,
                  mdescs=mdescs,
                  modname=(self.modname))
                self.st.out(struct_register_at_module_scope, sname=sname,
                  modname=(self.modname))
            else:
                self.st.out(struct_descriptor, sname=sname,
                  mdescs=mdescs,
                  scope=(dotName(fscopedName[:-1])))
                self.st.out(struct_register, sname=sname)

    def visitStructForward(self, node):
        if self.handleImported(node):
            return
        else:
            sname = mangle(node.identifier())
            if self.at_module_scope:
                self.st.out(forward_struct_descr_at_module_scope, sname=sname,
                  repoId=(node.repoId()),
                  modname=(self.modname))
            else:
                self.st.out(forward_struct_descr, sname=sname,
                  repoId=(node.repoId()),
                  modname=(self.modname))

    def visitException(self, node):
        if self.handleImported(node):
            return
        else:
            sname = mangle(node.identifier())
            fscopedName = fixupScopedName(node.scopedName(), '')
            self.st.out(exception_class, sname=sname,
              repoId=(node.repoId()),
              scopedname=(dotName(fscopedName)))
            if not self.at_module_scope:
                self.st.out(struct_class_name, cname=(dotName(fscopedName)))
            mnamel = []
            mdescl = []
            for mem in node.members():
                if mem.constrType():
                    self.st.inc_indent()
                    ams = self.at_module_scope
                    self.at_module_scope = 0
                    self.currentScope.append(node.identifier())
                    mem.memberType().decl().accept(self)
                    self.currentScope.pop()
                    self.at_module_scope = ams
                    self.st.dec_indent()
                    self.st.out('')
                for decl in mem.declarators():
                    mnamel.append(mangle(decl.identifier()))
                    mdescl.append('"' + mangle(decl.identifier()) + '"')
                    if self.at_module_scope:
                        mdescl.append(typeAndDeclaratorToDescriptor(mem.memberType(), decl, []))
                    else:
                        mdescl.append(typeAndDeclaratorToDescriptor(mem.memberType(), decl, self.currentScope))

            if len(mnamel) > 0:
                mnames = ', ' + ', '.join(mnamel)
            else:
                mnames = ''
            self.st.out(exception_class_init, mnames=mnames)
            for mname in mnamel:
                self.st.out(exception_init_member, mname=mname)

            if len(mdescl) > 0:
                mdescs = ', ' + ', '.join(mdescl)
            else:
                mdescs = ''
            if self.at_module_scope:
                self.st.out(exception_descriptor_at_module_scope, sname=sname,
                  mdescs=mdescs,
                  modname=(self.modname))
            else:
                self.st.out(exception_descriptor, sname=sname, mdescs=mdescs)

    def visitUnion(self, node):
        if self.handleImported(node):
            return
        else:
            uname = mangle(node.identifier())
            if self.at_module_scope:
                stype = typeToDescriptor(node.switchType(), [])
            else:
                stype = typeToDescriptor(node.switchType(), self.currentScope)
            fscopedName = fixupScopedName(node.scopedName(), '')
            if node.recursive():
                if self.at_module_scope:
                    self.st.out(recursive_union_descr_at_module_scope, uname=uname,
                      repoId=(node.repoId()),
                      modname=(self.modname))
                else:
                    self.st.out(recursive_union_descr, uname=uname,
                      repoId=(node.repoId()),
                      scope=(dotName(fscopedName[:-1])))
            self.st.out(union_class, uname=uname,
              repoId=(node.repoId()),
              scopedname=(dotName(fscopedName)))
            if not self.at_module_scope:
                self.st.out(union_class_name, cname=(dotName(fscopedName)))
            if node.constrType():
                self.st.inc_indent()
                ams = self.at_module_scope
                self.at_module_scope = 0
                self.currentScope.append(node.identifier())
                node.switchType().decl().accept(self)
                self.currentScope.pop()
                self.at_module_scope = ams
                self.st.dec_indent()
            def_m = 'None'
            def_d = 'None'
            m_def = 'None'
            defpos = '-1'
            m_to_d_l = []
            d_to_m_l = []
            m_un_l = []
            d_map_l = []
            i = 0
            for case in node.cases():
                if case.constrType():
                    self.st.inc_indent()
                    ams = self.at_module_scope
                    self.at_module_scope = 0
                    self.currentScope.append(node.identifier())
                    case.caseType().decl().accept(self)
                    self.currentScope.pop()
                    self.at_module_scope = ams
                    self.st.dec_indent()
                    self.st.out('')
                else:
                    if self.at_module_scope:
                        ctype = typeAndDeclaratorToDescriptor(case.caseType(), case.declarator(), [])
                    else:
                        ctype = typeAndDeclaratorToDescriptor(case.caseType(), case.declarator(), self.currentScope)
                cname = mangle(case.declarator().identifier())
                for label in case.labels():
                    if label.default():
                        def_m = '"' + cname + '"'
                        defpos = str(i)
                        if self.at_module_scope:
                            def_d = valueToString(label.value(), label.labelKind(), [])
                            m_def = '_0_' + self.modname + '._m_' + uname + '[' + defpos + ']'
                        else:
                            def_d = valueToString(label.value(), label.labelKind(), self.currentScope)
                            m_def = '_m_' + uname + '[' + defpos + ']'
                        m_un_l.append('(' + def_d + ', "' + cname + '", ' + ctype + ')')
                    else:
                        if self.at_module_scope:
                            slabel = valueToString(label.value(), label.labelKind(), [])
                        else:
                            slabel = valueToString(label.value(), label.labelKind(), self.currentScope)
                        m_to_d_l.append('"' + cname + '": ' + slabel)
                        d_to_m_l.append(slabel + ': "' + cname + '"')
                        m_un_l.append('(' + slabel + ', "' + cname + '", ' + ctype + ')')
                        if self.at_module_scope:
                            d_map_l.append(slabel + ': ' + '_0_' + self.modname + '._m_' + uname + '[' + str(i) + ']')
                        else:
                            d_map_l.append(slabel + ': ' + '_m_' + uname + '[' + str(i) + ']')
                    i = i + 1

            m_to_d = ', '.join(m_to_d_l)
            d_to_m = ', '.join(d_to_m_l)
            m_un = ', '.join(m_un_l)
            d_map = ', '.join(d_map_l)
            if self.at_module_scope:
                self.st.out(union_descriptor_at_module_scope, uname=uname,
                  m_to_d=m_to_d,
                  d_to_m=d_to_m,
                  def_m=def_m,
                  def_d=def_d,
                  m_un=m_un,
                  stype=stype,
                  defpos=defpos,
                  m_def=m_def,
                  d_map=d_map,
                  modname=(self.modname))
                self.st.out(union_register_at_module_scope, uname=uname,
                  modname=(self.modname))
            else:
                self.st.out(union_descriptor, uname=uname,
                  m_to_d=m_to_d,
                  d_to_m=d_to_m,
                  def_m=def_m,
                  def_d=def_d,
                  m_un=m_un,
                  stype=stype,
                  defpos=defpos,
                  m_def=m_def,
                  d_map=d_map,
                  scope=(dotName(fscopedName[:-1])))
                self.st.out(union_register, uname=uname)

    def visitUnionForward(self, node):
        if self.handleImported(node):
            return
        else:
            uname = mangle(node.identifier())
            if self.at_module_scope:
                self.st.out(forward_union_descr_at_module_scope, uname=uname,
                  repoId=(node.repoId()),
                  modname=(self.modname))
            else:
                self.st.out(forward_union_descr, uname=uname,
                  repoId=(node.repoId()),
                  modname=(self.modname))

    def visitEnum(self, node):
        if self.handleImported(node):
            return
        else:
            ename = mangle(node.identifier())
            self.st.out(enum_start, ename=ename)
            i = 0
            elist = []
            for item in node.enumerators():
                eval = str(i)
                if self.at_module_scope:
                    self.st.out(enum_item_at_module_scope, item=(item.identifier()),
                      eitem=(mangle(item.identifier())),
                      eval=eval,
                      modname=(self.modname))
                else:
                    self.st.out(enum_item, item=(item.identifier()),
                      eitem=(mangle(item.identifier())),
                      eval=eval)
                if self.at_module_scope:
                    elist.append(dotName(fixupScopedName(item.scopedName())))
                else:
                    elist.append(mangle(item.identifier()))
                i = i + 1

            eitems = ', '.join(elist)
            if self.at_module_scope:
                self.st.out(enum_object_and_descriptor_at_module_scope, ename=ename,
                  repoId=(node.repoId()),
                  eitems=eitems,
                  modname=(self.modname))
            else:
                self.st.out(enum_object_and_descriptor, ename=ename,
                  repoId=(node.repoId()),
                  eitems=eitems)

    def visitNative(self, node):
        if self.handleImported(node):
            return
        sys.stderr.write(main.cmdname + ': Warning: ignoring declaration of native ' + node.identifier() + '\n')

    def visitValueForward(self, node):
        if self.handleImported(node):
            return
        vname = mangle(node.identifier())
        self.st.out(value_forward_at_module_scope, vname=vname,
          repoId=(node.repoId()),
          modname=(self.modname))

    def visitValueBox(self, node):
        if self.handleImported(node):
            return
        boxname = mangle(node.identifier())
        boxdesc = typeToDescriptor(node.boxedType())
        self.st.out(valuebox, boxname=boxname, repoId=(node.repoId()), boxdesc=boxdesc,
          modname=(self.modname))

    def visitValueAbs(self, node):
        if self.handleImported(node):
            return
        else:
            vname = mangle(node.identifier())
            fscopedName = fixupScopedName(node.scopedName(), '')
            scopedname = dotName(fscopedName)
            if node.inherits():
                inheritl = []
                for i in node.inherits():
                    i = i.fullDecl()
                    inheritl.append(dotName(fixupScopedName(i.scopedName())))

                inherits = ', '.join(inheritl)
            else:
                inherits = '_0_CORBA.ValueBase'
            self.st.out(valueabs_class, vname=vname,
              scopedname=scopedname,
              repoId=(node.repoId()),
              inherits=inherits,
              modname=(self.modname))
            if len(node.declarations()) > 0:
                self.st.inc_indent()
                self.at_module_scope = 0
                self.currentScope.append(node.identifier())
                for d in node.declarations():
                    d.accept(self)

                self.currentScope.pop()
                self.at_module_scope = 1
                self.st.dec_indent()
                self.st.out('')
            if hasattr(node, '_ami_gen'):
                self.st.out(ami_poller_impl, vname=vname)
                for c in node.callables():
                    if isinstance(c._ami_from, idlast.Declarator):
                        opname = '_' + c.identifier()
                    else:
                        opname = c.identifier()
                    self.st.out(ami_poller_op, poller_opname=(c.identifier()),
                      opname=opname)

                self.st.out(ami_poller_register, vname=vname,
                  modname=(self.modname),
                  ifname=(node._ami_from.identifier()))
        basedesc = '_0_CORBA.tcInternal.tv_null'
        self.st.out(value_descriptor_at_module_scope, vname=vname,
          modifier='_0_CORBA.VM_ABSTRACT',
          tbaseids='None',
          basedesc=basedesc,
          mdescs='',
          modname=(self.modname))

    def visitValue(self, node):
        if self.handleImported(node):
            return
        else:
            vname = mangle(node.identifier())
            fscopedName = fixupScopedName(node.scopedName(), '')
            scopedname = dotName(fscopedName)
            if node.inherits():
                inheritl = []
                for i in node.inherits():
                    i = i.fullDecl()
                    inheritl.append(dotName(fixupScopedName(i.scopedName())))

            else:
                inheritl = [
                 '_0_CORBA.ValueBase']
            skeleton_opl = []
            for i in node.supports():
                i = i.fullDecl()
                sn = fixupScopedName(i.scopedName())
                sn[0] = sn[0] + '__POA'
                dn = dotName(sn)
                inheritl.append(dn)
                skeleton_opl.append(dn)

            inherits = ', '.join(inheritl)
            members = []
            ilist = []
            cnode = node
            while True:
                cin = cnode.inherits()
                if not cin:
                    break
                i = cin[0].fullDecl()
                if not isinstance(i, idlast.Value):
                    break
                ilist.append(i)
                cnode = i

            ilist.reverse()
            ilist.append(node)
            for i in ilist:
                members.extend(i.statemembers())

            set_argl = []
            for i in range(len(members)):
                member = members[i]
                for d in member.declarators():
                    set_argl.append('self.%s = args[%d]' % (
                     mangle(d.identifier()), i))

            if set_argl:
                set_args = '\n'.join(set_argl)
            else:
                set_args = 'pass'
            if len(set_argl) == 1:
                s = ''
            else:
                s = 's'
            self.st.out(value_class, vname=vname,
              scopedname=scopedname,
              repoId=(node.repoId()),
              inherits=inherits,
              set_args=set_args,
              arglen=(len(set_argl)),
              s=s,
              modname=(self.modname))
            if len(node.declarations()) > 0:
                self.st.inc_indent()
                self.at_module_scope = 0
                self.currentScope.append(node.identifier())
                for d in node.declarations():
                    d.accept(self)

                self.currentScope.pop()
                self.at_module_scope = 1
                self.st.dec_indent()
                self.st.out('')
            if node.supports():
                self.st.out(skeleton_methodmap, methodmap='{}')
                for i in skeleton_opl:
                    self.st.out(skeleton_inheritmap, inheritclass=i)

                self.st.out(skeleton_set_skel, ifid=vname)
            register_factory = 1
            if not all_factories:
                cnode = node
                while True:
                    if cnode.callables() or cnode.factories() or cnode.supports():
                        register_factory = 0
                        break
                    cin = cnode.inherits()
                    if not cin:
                        break
                    for n in cin:
                        n = n.fullDecl()
                        if not isinstance(n, idlast.Value):
                            register_factory = 0
                            break

                    cnode = cin[0].fullDecl()

            if register_factory:
                self.st.out(value_register_factory, vname=vname)
            if node.supports():
                inheritl = []
                for i in node.supports():
                    i = i.fullDecl()
                    sn = fixupScopedName(i.scopedName())
                    inheritl.append(dotName(sn[:-1] + ['_objref_' + sn[(-1)]]))

                inherits = ', '.join(inheritl)
                self.st.out(objref_class, ifid=vname, inherits=inherits)
                for inclass in inheritl:
                    self.st.out(objref_inherit_init, inclass=inclass)

                self.st.out(value_objref_register, ifid=vname,
                  modname=(self.modname))
            if node.custom():
                modifier = '_0_CORBA.VM_CUSTOM'
            else:
                if node.truncatable():
                    modifier = '_0_CORBA.VM_TRUNCATABLE'
                else:
                    modifier = '_0_CORBA.VM_NONE'
                tbasel = []
                cnode = node
                while True:
                    cin = cnode.inherits()
                    if not cin:
                        break
                    i = cin[0]
                    i = i.fullDecl()
                    if not isinstance(i, idlast.Value):
                        break
                    if cnode.truncatable():
                        sn = fixupScopedName(i.scopedName())
                        tbasel.append(dotName(sn) + '._NP_RepositoryId')
                    else:
                        break
                    cnode = i

                if tbasel:
                    tbaseids = '(%s._NP_RepositoryId, %s)' % (vname, ', '.join(tbasel))
                else:
                    tbaseids = 'None'
            basedesc = None
            if node.inherits():
                i = node.inherits()[0].fullDecl()
                if isinstance(i, idlast.Value):
                    sn = i.scopedName()[:]
                    sn[-1] = '_d_' + sn[(-1)]
                    basedesc = dotName(fixupScopedName(sn))
            if basedesc is None:
                basedesc = '_0_CORBA.tcInternal.tv_null'
        mlist = []
        for m in node.statemembers():
            for d in m.declarators():
                mlist.append('"%s"' % mangle(d.identifier()))
                mlist.append(typeAndDeclaratorToDescriptor(m.memberType(), d, []))
                if m.memberAccess() == 1:
                    mlist.append('_0_CORBA.PRIVATE_MEMBER')
                else:
                    mlist.append('_0_CORBA.PUBLIC_MEMBER')

        mdescs = ', '.join(mlist)
        self.st.out(value_descriptor_at_module_scope, vname=vname,
          modifier=modifier,
          tbaseids=tbaseids,
          basedesc=basedesc,
          mdescs=mdescs,
          modname=(self.modname))


def docConst(node):
    if isinstance(node, idlast.Const):
        if node.constKind() == idltype.tk_string:
            if node.identifier()[-7:] == '__doc__':
                return node.identifier()[:-7]
    return


def nodeId(node):
    if hasattr(node, 'identifier'):
        return node.identifier()
    else:
        return


def docWarning(node):
    sys.stderr.write(main.cmdname + ": Warning: Constant '" + node.identifier() + "' looks like a Python docstring, but there is no declaration named '" + node.identifier()[:-7] + "'.\n")


class DocstringVisitor(idlvisitor.AstVisitor):

    def __init__(self, st):
        self.docs = []
        self.st = st

    def output(self):
        if self.docs:
            self.st.out('#\n# Docstrings\n#\n')
        for nsn, dsn in self.docs:
            nsn = fixupScopedName(nsn)
            dsn = fixupScopedName(dsn)
            self.st.out('@node@.__doc__ = @doc@', node=(dotName(nsn)),
              doc=(dotName(dsn)))

        if self.docs:
            self.st.out('')

    def visitAST(self, node):
        for n in node.declarations():
            if not output_inline:
                if not n.mainFile():
                    continue
            d = docConst(n)
            if d:
                ok = 0
                for o in node.declarations():
                    if nodeId(o) == d:
                        self.docs.append((o.scopedName(), n.scopedName()))
                        if isinstance(o, idlast.Interface):
                            sn = o.scopedName()[:]
                            sn[-1] = '_objref_' + sn[(-1)]
                            self.docs.append((sn, n.scopedName()))
                        ok = 1
                        break

                if not ok:
                    docWarning(n)
            n.accept(self)

    def visitModule(self, node):
        for n in node.definitions():
            d = docConst(n)
            if d:
                if d == node.identifier():
                    self.docs.append((node.scopedName(), n.scopedName()))
                else:
                    ok = 0
                    for o in node.definitions():
                        if nodeId(o) == d:
                            self.docs.append((o.scopedName(), n.scopedName()))
                            if isinstance(o, idlast.Interface):
                                sn = o.scopedName()[:]
                                sn[-1] = '_objref_' + sn[(-1)]
                                self.docs.append((sn, n.scopedName()))
                            ok = 1
                            break

                    if not ok:
                        docWarning(n)
            n.accept(self)

    def visitInterface(self, node):
        for n in node.declarations():
            d = docConst(n)
            if d:
                if d == node.identifier():
                    self.docs.append((node.scopedName(), n.scopedName()))
                    sn = node.scopedName()[:]
                    sn[-1] = '_objref_' + sn[(-1)]
                    self.docs.append((sn, n.scopedName()))
                else:
                    ok = 0
                    for o in node.declarations():
                        if nodeId(o) == d:
                            self.docs.append((o.scopedName(), n.scopedName()))
                            ok = 1
                            break

                    if ok:
                        pass
                    else:
                        for o in node.callables():
                            self.target_id = d
                            self.target_node = n
                            self.ok = 0
                            o.accept(self)
                            if self.ok:
                                break

                        if not self.ok:
                            docWarning(n)

    def visitOperation(self, node):
        if node.identifier() == self.target_id:
            sn = node.scopedName() + ['im_func']
            sn[-3] = '_objref_' + sn[(-3)]
            self.docs.append((sn, self.target_node.scopedName()))
            self.ok = 1

    def visitAttribute(self, node):
        for n in node.declarators():
            if n.identifier() == self.target_id:
                sn = n.scopedName() + ['im_func']
                sn[-3] = '_objref_' + sn[(-3)]
                sn[-2] = '_get_' + sn[(-2)]
                self.docs.append((sn, self.target_node.scopedName()))
                if not node.readonly():
                    sn = sn[:]
                    sn[-2] = '_set_' + n.identifier()
                    self.docs.append((sn, self.target_node.scopedName()))
                self.ok = 1


class ExampleVisitor(idlvisitor.AstVisitor, idlvisitor.TypeVisitor):

    def __init__(self, st):
        self.st = st
        self.first = None

    def visitAST(self, node):
        for n in node.declarations():
            if not output_inline:
                if not n.mainFile():
                    continue
                if isinstance(n, idlast.Module) or isinstance(n, idlast.Interface):
                    n.accept(self)

    def visitModule(self, node):
        for n in node.definitions():
            if not output_inline:
                if not n.mainFile():
                    continue
                if isinstance(n, idlast.Module) or isinstance(n, idlast.Interface):
                    n.accept(self)

    def visitInterface(self, node):
        ifname = mangle(node.identifier())
        sname = node.scopedName()
        ccname = idlutil.ccolonName(sname)
        fsname = fixupScopedName(sname, prefix='')
        dname = dotName(fsname)
        skname = skeletonModuleName(dname)
        if self.first is None:
            self.first = ifname
        else:
            if len(node.inherits()) == 1:
                inheritance_note = '\n    # Note: this interface inherits from another interface. You must\n    # either multiply inherit from the servant class implementing the\n    # base interface, or explicitly implement the inherited operations\n    # here.\n    #\n    # Inherited interface:\n    #\n'
            else:
                if node.inherits():
                    inheritance_note = '\n    # Note: this interface inherits from other interfaces. You must either\n    # multiply inherit from the servant classes implementing the base\n    # interfaces, or explicitly implement the inherited operations here.\n    #\n    # Inherited interfaces:\n    #\n'
                else:
                    inheritance_note = ''
        for inh in node.inherits():
            iname = idlutil.ccolonName(inh.fullDecl().scopedName())
            inheritance_note = inheritance_note + '    #   %s\n' % iname

        self.st.out(example_classdef, ifname=ifname, ccname=ccname,
          skname=skname,
          inheritance_note=inheritance_note)
        for c in node.callables():
            if isinstance(c, idlast.Attribute):
                c.attrType().accept(self)
                attrtype = self._ExampleVisitor__result_type
                for attr in c.identifiers():
                    signature = 'attribute %s %s' % (attrtype, attr)
                    if c.readonly():
                        signature = 'readonly ' + signature
                    if not c.readonly():
                        self.st.out(example_opdef, signature=signature,
                          opname=('_set_' + attr),
                          args=', value',
                          returnspec='None')
                    self.st.out(example_opdef, signature=signature,
                      opname=('_get_' + attr),
                      args='',
                      returnspec='attribute value')

            else:
                innames = []
                outnames = []
                siglist = []
                c.returnType().accept(self)
                rettype = self._ExampleVisitor__result_type
                if c.returnType().kind() != idltype.tk_void:
                    outnames.append('result')
                for p in c.parameters():
                    if p.is_in():
                        innames.append(p.identifier())
                    if p.is_out():
                        outnames.append(p.identifier())
                    direction = {0:'in',  1:'out',  2:'inout'}[p.direction()]
                    p.paramType().accept(self)
                    siglist.append('%s %s %s' % (direction,
                     self._ExampleVisitor__result_type,
                     p.identifier()))

                signature = '%s %s(%s)' % (rettype, c.identifier(),
                 ', '.join(siglist))
                if innames:
                    args = ', ' + ', '.join(innames)
                else:
                    args = ''
                if outnames:
                    returnspec = ', '.join(outnames)
                else:
                    returnspec = 'None'
                self.st.out(example_opdef, signature=signature,
                  opname=(c.identifier()),
                  args=args,
                  returnspec=returnspec)

    ttsMap = {idltype.tk_void: 'void', 
     idltype.tk_short: 'short', 
     idltype.tk_long: 'long', 
     idltype.tk_ushort: 'unsigned short', 
     idltype.tk_ulong: 'unsigned long', 
     idltype.tk_float: 'float', 
     idltype.tk_double: 'double', 
     idltype.tk_boolean: 'boolean', 
     idltype.tk_char: 'char', 
     idltype.tk_octet: 'octet', 
     idltype.tk_any: 'any', 
     idltype.tk_TypeCode: 'CORBA::TypeCode', 
     idltype.tk_Principal: 'CORBA::Principal', 
     idltype.tk_longlong: 'long long', 
     idltype.tk_ulonglong: 'unsigned long long', 
     idltype.tk_longdouble: 'long double', 
     idltype.tk_wchar: 'wchar'}

    def visitBaseType(self, type):
        self._ExampleVisitor__result_type = self.ttsMap[type.kind()]

    def visitStringType(self, type):
        if type.bound() == 0:
            self._ExampleVisitor__result_type = 'string'
        else:
            self._ExampleVisitor__result_type = 'string<' + str(type.bound()) + '>'

    def visitWStringType(self, type):
        if type.bound() == 0:
            self._ExampleVisitor__result_type = 'wstring'
        else:
            self._ExampleVisitor__result_type = 'wstring<' + str(type.bound()) + '>'

    def visitDeclaredType(self, type):
        self._ExampleVisitor__result_type = idlutil.ccolonName(type.decl().scopedName())


def operationToDescriptors(op):
    """Return the descriptors for an operation.

    Returns a tuple containing strings of (in descriptor, out
    descriptor, exception map, context list, contains values)
    """
    indl = []
    outdl = []
    cv = 0
    if op.returnType() is not None:
        if op.returnType().kind() != idltype.tk_void:
            outdl.append(typeToDescriptor(op.returnType()))
            cv = idltype.containsValueType(op.returnType())
    for p in op.parameters():
        if p.is_in():
            indl.append(typeToDescriptor(p.paramType()))
        if p.is_out():
            outdl.append(typeToDescriptor(p.paramType()))
        cv = cv or idltype.containsValueType(p.paramType())

    if len(indl) == 1:
        indl.append('')
    else:
        if len(outdl) == 1:
            outdl.append('')
        else:
            inds = '(' + ', '.join(indl) + ')'
            if op.oneway():
                outds = 'None'
            else:
                outds = '(' + ', '.join(outdl) + ')'
            excl = []
            for e in op.raises():
                sn = fixupScopedName(e.scopedName())
                ename = dotName(sn)
                edesc = dotName(sn[:-1] + ['_d_' + sn[(-1)]])
                excl.append(ename + '._NP_RepositoryId: ' + edesc)

            if len(excl) > 0:
                excs = '{' + ', '.join(excl) + '}'
            else:
                excs = 'None'
        if op.contexts():
            ctxts = '[' + ', '.join(map(repr, op.contexts())) + ']'
        else:
            ctxts = None
    return (
     inds, outds, excs, ctxts, cv)


ttdMap = {idltype.tk_short: 'omniORB.tcInternal.tv_short', 
 idltype.tk_long: 'omniORB.tcInternal.tv_long', 
 idltype.tk_ushort: 'omniORB.tcInternal.tv_ushort', 
 idltype.tk_ulong: 'omniORB.tcInternal.tv_ulong', 
 idltype.tk_float: 'omniORB.tcInternal.tv_float', 
 idltype.tk_double: 'omniORB.tcInternal.tv_double', 
 idltype.tk_boolean: 'omniORB.tcInternal.tv_boolean', 
 idltype.tk_char: 'omniORB.tcInternal.tv_char', 
 idltype.tk_octet: 'omniORB.tcInternal.tv_octet', 
 idltype.tk_any: 'omniORB.tcInternal.tv_any', 
 idltype.tk_TypeCode: 'omniORB.tcInternal.tv_TypeCode', 
 idltype.tk_Principal: 'omniORB.tcInternal.tv_Principal', 
 idltype.tk_longlong: 'omniORB.tcInternal.tv_longlong', 
 idltype.tk_ulonglong: 'omniORB.tcInternal.tv_ulonglong', 
 idltype.tk_wchar: 'omniORB.tcInternal.tv_wchar'}
unsupportedMap = {idltype.tk_longdouble: 'long double'}

def typeToDescriptor(tspec, from_scope=[], is_typedef=0):
    if hasattr(tspec, 'python_desc'):
        return tspec.python_desc
    else:
        if tspec.kind() in ttdMap:
            tspec.python_desc = ttdMap[tspec.kind()]
            return tspec.python_desc
        elif tspec.kind() in unsupportedMap:
            error_exit('omniORBpy does not support the %s type.' % unsupportedMap[tspec.kind()])
        else:
            if tspec.kind() == idltype.tk_string:
                ret = '(omniORB.tcInternal.tv_string,' + str(tspec.bound()) + ')'
            else:
                if tspec.kind() == idltype.tk_wstring:
                    ret = '(omniORB.tcInternal.tv_wstring,' + str(tspec.bound()) + ')'
                else:
                    if tspec.kind() == idltype.tk_sequence:
                        ret = '(omniORB.tcInternal.tv_sequence, ' + typeToDescriptor(tspec.seqType(), from_scope) + ', ' + str(tspec.bound()) + ')'
                    else:
                        if tspec.kind() == idltype.tk_fixed:
                            ret = '(omniORB.tcInternal.tv_fixed, ' + str(tspec.digits()) + ', ' + str(tspec.scale()) + ')'
                        else:
                            if tspec.kind() == idltype.tk_alias:
                                if is_typedef:
                                    return 'omniORB.typeCodeMapping["%s"]._d' % tspec.decl().repoId()
                                else:
                                    return 'omniORB.typeMapping["%s"]' % tspec.decl().repoId()
                            else:
                                ret = 'omniORB.typeMapping["%s"]' % tspec.decl().repoId()
        tspec.python_desc = ret
        return ret


def typeAndDeclaratorToDescriptor(tspec, decl, from_scope, is_typedef=0):
    desc = typeToDescriptor(tspec, from_scope, is_typedef)
    if len(decl.sizes()) > 0:
        sizes = decl.sizes()[:]
        sizes.reverse()
        for size in sizes:
            desc = '(omniORB.tcInternal.tv_array, ' + desc + ', ' + str(size) + ')'

    return desc


def skeletonModuleName(mname):
    """Convert a scoped name string into the corresponding skeleton
module name. e.g. M1.M2.I -> M1__POA.M2.I"""
    l = mname.split('.')
    l[0] = l[0] + '__POA'
    return '.'.join(l)


def dotName(scopedName, our_scope=[]):
    if scopedName[:len(our_scope)] == our_scope:
        l = [mangle(s) for s in scopedName[len(our_scope):]]
    else:
        l = [mangle(s) for s in scopedName]
    return '.'.join(l)


def mangle(name):
    if keyword.iskeyword(name):
        return '_' + name
    else:
        if name == 'None':
            return '_None'
        return name


def fixupScopedName(scopedName, prefix='_0_'):
    """Add a prefix and _GlobalIDL to the front of a ScopedName if necessary"""
    try:
        decl = idlast.findDecl([scopedName[0]])
    except idlast.DeclNotFound:
        decl = None

    if isinstance(decl, idlast.Module):
        scopedName = [
         prefix + mangle(scopedName[0])] + scopedName[1:]
    else:
        scopedName = [
         prefix + global_module] + scopedName
    return scopedName


def valueToString(val, kind, scope=[]):
    if kind == idltype.tk_enum:
        return dotName(fixupScopedName(val.scopedName()), scope)
    else:
        if kind in [idltype.tk_string, idltype.tk_char]:
            return '"' + idlutil.escapifyString(val) + '"'
        else:
            if kind == idltype.tk_wstring:
                return 'u"' + idlutil.escapifyWString(val) + '"'
            else:
                if kind == idltype.tk_wchar:
                    return 'u"' + idlutil.escapifyWString([val]) + '"'
                if kind == idltype.tk_long:
                    if val == -2147483648:
                        return '-2147483647 - 1'
                if kind in [idltype.tk_float, idltype.tk_double, idltype.tk_longdouble]:
                    return idlutil.reprFloat(val)
            if kind == idltype.tk_fixed:
                return "CORBA.fixed('" + val + "')"
        return str(val)


try:
    __translate_table = str.maketrans(' -.,', '____')
except AttributeError:
    import string
    __translate_table = string.maketrans(' -.,', '____')

def outputFileName(idlname):
    return os.path.basename(idlname).translate(__translate_table)


def checkStubPackage(package):
    """Check the given package name for use as a stub directory

    Make sure all fragments of the package name are directories, or
    create them. Make __init__.py files in all directories."""
    if len(package) == 0:
        return
    if package[(-1)] == '.':
        package = package[:-1]
    path = ''
    for name in package.split('.'):
        path = os.path.join(path, name)
        if os.path.exists(path):
            if not os.path.isdir(path):
                error_exit('Output error: "%s" exists and is not a directory.' % path)
        else:
            try:
                os.mkdir(path)
            except:
                error_exit('Cannot create directory "%s".\n' % path)

        initfile = os.path.join(path, '__init__.py')
        if os.path.exists(initfile):
            if not os.path.isfile(initfile):
                error_exit('Output error: "%s" exists and is not a file.' % initfile)
        else:
            try:
                open(initfile, 'w').write('# omniORB stub directory\n')
            except:
                error_exit('Cannot create "%s".' % initfile)


def updateModules(modules, pymodule):
    """Create or update the Python modules corresponding to the IDL
    module names"""
    checkStubPackage(module_package)
    poamodules = [skeletonModuleName(m) for m in modules]
    real_updateModules(modules, pymodule)
    real_updateModules(poamodules, pymodule)


def real_updateModules(modules, pymodule):
    for module in modules:
        modlist = module_package.split('.') + module.split('.')
        modpath = (os.path.join)(*modlist)
        modfile = os.path.join(modpath, '__init__.py')
        tmpfile = os.path.join(modpath, 'new__init__.py')
        if not os.path.exists(modpath):
            try:
                os.makedirs(modpath)
            except:
                error_exit('Cannot create path "%s".' % modpath)

        if not os.path.exists(modfile):
            try:
                f = open(modfile, 'w')
            except:
                error_exit('Cannot create "%s".' % modfile)

            st = output.Stream(f, 4)
            st.out(pymodule_template, module=module, package=module_package)
            f.close()
            del f
            del st
        if not os.path.isfile(modfile):
            error_exit('Output error: "%s" exists but is not a file.' % modfile)
        try:
            inf = open(modfile, 'r')
        except:
            error_exit('Cannot open "%s" for reading.' % modfile)

        try:
            outf = open(tmpfile, 'w')
        except:
            error_exit('Cannot open "%s" for writing.' % tmpfile)

        line = ''
        while line[:7] != '# ** 1.':
            line = inf.readline()
            if line == '':
                error_exit('Output error: "%s" ended before I found a "# ** 1." tag.\nHave you left behind some files from a different Python ORB?' % modfile)
            outf.write(line)

        already = 0
        outputline = 'import ' + pymodule + '\n'
        while line != '\n':
            line = inf.readline()
            if line == '':
                error_exit('Output error: "%s" ended while I was looking at imports.' % modfile)
            if line != '\n':
                outf.write(line)
                if line == outputline:
                    already = 1

        if not already:
            outf.write(outputline)
        outf.write('\n')
        while line != '':
            line = inf.readline()
            outf.write(line)

        inf.close()
        outf.close()
        try:
            os.remove(modfile)
        except:
            error_exit('Cannot remove "%s".' % modfile)

        try:
            os.rename(tmpfile, modfile)
        except:
            error_exit('Cannot rename "%s" to "%s".' % (tmpfile, modfile))

    for module in modules:
        modlist = module.split('.')
        if len(modlist) == 1:
            pass
        else:
            modlist = module_package.split('.') + modlist
            submod = modlist[(-1)]
            modpath = (os.path.join)(*modlist[:-1])
            modfile = os.path.join(modpath, '__init__.py')
            tmpfile = os.path.join(modpath, 'new__init__.py')
            try:
                inf = open(modfile, 'r')
            except:
                error_exit('Cannot open "%s" for reading.' % modfile)

            try:
                outf = open(tmpfile, 'w')
            except:
                error_exit('Cannot open "%s" for writing.' % tmpfile)

            line = ''
            while line[:7] != '# ** 2.':
                line = inf.readline()
                if line == '':
                    error_exit('Output error: "%s" ended before I found a "# ** 1." tag.\nHave you left behind some files from a different Python ORB?' % modfile)
                outf.write(line)

            already = 0
            outputline = 'from . import ' + submod + '\n'
            old_outputline = 'import ' + submod + '\n'
            while line != '\n':
                line = inf.readline()
                if line == '':
                    error_exit('Output error: "%s" ended while I was looking at imports.' % modfile)
                if line != '\n' and line != old_outputline:
                    outf.write(line)
                    if line == outputline:
                        already = 1

            if not already:
                outf.write(outputline)
            outf.write('\n')
            while line != '':
                line = inf.readline()
                outf.write(line)

            inf.close()
            outf.close()
            try:
                os.remove(modfile)
            except:
                error_exit('Cannot remove "%s".' % modfile)

            try:
                os.rename(tmpfile, modfile)
            except:
                error_exit('Cannot rename "%s" to "%s".' % (tmpfile, modfile))
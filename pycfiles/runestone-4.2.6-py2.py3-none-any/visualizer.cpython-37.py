# uncompyle6 version 3.7.4
# Python bytecode 3.7 (3394)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /srv/RunestoneComponents/runestone/codelens/visualizer.py
# Compiled at: 2020-04-16 12:40:55
# Size of source mod 2**32: 7853 bytes
__author__ = 'bmiller'
from docutils import nodes
from docutils.parsers.rst import directives
from .pg_logger import exec_script_str_local
import json, six, requests
from runestone.server.componentdb import addQuestionToDB, addHTMLToDB
from runestone.common.runestonedirective import RunestoneIdDirective

def setup(app):
    app.add_directive('codelens', Codelens)
    app.add_autoversioned_javascript('pytutor-embed.bundle.js')
    app.add_config_value('codelens_div_class', 'alert alert-warning cd_section', 'html')
    app.add_config_value('trace_url', 'http://tracer.runestone.academy:5000', 'html')


VIS = '\n<div class="runestone" style="max-width: none;">\n    <div class="%(divclass)s">\n        <div class="pytutorVisualizer" id="%(divid)s"\n           data-params=\'{"embeddedMode": true, "lang": "%(language)s", "jumpToEnd": false}\'>\n        </div>\n        <p class="runestone_caption"><span class="runestone_caption_text">CodeLens: %(caption)s (%(divid)s)</span> </p>\n    </div>\n'
DATA = '\n<script type="text/javascript">\nvar %(divid)s_vis;\n\nif (allTraceData === undefined) {\n   var allTraceData = {};\n}\n\nallTraceData["%(divid)s"] = %(tracedata)s;\n</script>\n</div>\n'

class Codelens(RunestoneIdDirective):
    __doc__ = "\n.. codelens:: uniqueid\n   :tracedata: Autogenerated or provided\n   :caption: caption below\n   :showoutput: show stdout from program\n   :question: Text of question to ask on breakline\n   :correct: correct answer to the question\n   :feedback: feedback for incorrect answers\n   :breakline: Line to stop on and pop up a question dialog\n   :python: either py2 or py3\n\n    x = 0\n    for i in range(10):\n       x = x + i\n\n\nconfig values (conf.py):\n\n- codelens_div_class - custom CSS class of the component's outermost div\n    "
    required_arguments = 1
    optional_arguments = 1
    option_spec = RunestoneIdDirective.option_spec.copy()
    option_spec.update({'tracedata':directives.unchanged, 
     'caption':directives.unchanged, 
     'showoutput':directives.flag, 
     'question':directives.unchanged, 
     'correct':directives.unchanged, 
     'feedback':directives.unchanged, 
     'breakline':directives.nonnegative_int, 
     'python':directives.unchanged, 
     'language':directives.unchanged})
    has_content = True

    def run(self):
        super(Codelens, self).run()
        addQuestionToDB(self)
        self.JS_VARNAME = ''
        self.JS_VARVAL = ''

        def raw_dict(input_code, output_trace):
            ret = dict(code=input_code, trace=output_trace)
            return ret

        def js_var_finalizer(input_code, output_trace):
            ret = dict(code=input_code, trace=output_trace)
            json_output = json.dumps(ret, indent=None)
            return json_output

        if self.content:
            source = '\n'.join(self.content)
        else:
            source = '\n'
        CUMULATIVE_MODE = False
        self.JS_VARNAME = self.options['divid'] + '_trace'
        env = self.state.document.settings.env
        self.options['divclass'] = env.config.codelens_div_class
        if 'showoutput' not in self.options:
            self.options['embedded'] = 'true'
        else:
            self.options['embedded'] = 'false'
        if 'language' not in self.options:
            self.options['language'] = 'python'
        else:
            if 'python' not in self.options:
                if six.PY2:
                    self.options['python'] = 'py2'
                else:
                    self.options['python'] = 'py3'
            elif 'tracedata' not in self.options:
                if 'question' in self.options:
                    curTrace = exec_script_str_local(source, None, CUMULATIVE_MODE, None, raw_dict)
                    self.inject_questions(curTrace)
                    json_output = json.dumps(curTrace, indent=None)
                    self.options['tracedata'] = json_output
                else:
                    if self.options['language'] == 'python':
                        self.options['tracedata'] = exec_script_str_local(source, None, CUMULATIVE_MODE, None, js_var_finalizer)
                    else:
                        if self.options['language'] == 'java':
                            self.options['tracedata'] = self.get_trace(source, 'java')
                        else:
                            if self.options['language'] == 'cpp':
                                self.options['tracedata'] = self.get_trace(source, 'cpp')
                            else:
                                if self.options['language'] == 'c':
                                    self.options['tracedata'] = self.get_trace(source, 'c')
                                else:
                                    raise ValueError('language not supported')
            res = VIS
            if 'caption' not in self.options:
                self.options['caption'] = ''
            if 'tracedata' in self.options:
                res += DATA
            else:
                res += '</div>'
        addHTMLToDB(self.options['divid'], self.options['basecourse'], res % self.options)
        raw_node = nodes.raw((self.block_text), (res % self.options), format='html')
        raw_node.source, raw_node.line = self.state_machine.get_source_and_line(self.lineno)
        return [
         raw_node]

    def inject_questions(self, curTrace):
        if 'breakline' not in self.options:
            raise RuntimeError('Must have breakline option')
        breakline = self.options['breakline']
        for frame in curTrace['trace']:
            if frame['line'] == breakline:
                frame['question'] = dict(text=(self.options['question']),
                  correct=(self.options['correct']),
                  div=(self.options['divid'] + '_modal'),
                  feedback=(self.options['feedback']))

    def get_trace(self, src, lang):
        env = self.state.document.settings.env
        url = f"{env.config.trace_url}/trace{lang}"
        try:
            r = requests.post(url, data=dict(src=src), timeout=30)
        except requests.ReadTimeout:
            self.error('The request to the trace server timed out, you will need to rerun the build')
            return ''
        else:
            if r.status_code == 200:
                if lang == 'java':
                    return r.text
                res = r.text[r.text.find('{"code":'):]
                return res
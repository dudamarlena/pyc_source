# uncompyle6 version 3.7.4
# Python bytecode 3.6 (3379)
# Decompiled from: Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
# [GCC 8.4.0]
# Embedded file name: /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/dasscripts/dasconv.py
# Compiled at: 2020-04-16 08:49:47
# Size of source mod 2**32: 7831 bytes
import argparse, sys, logging, pprint, datetime
from obspy import Trace
from .tdms import TDMS
import dasscripts.archive as da, inspect
version = '0.4b4'

def nslc(dataheader):
    """Get a NSLC code from a dictionary with its components

    :param dataheader: Dictionry with components of a NSLC code
    :type dataheader: dict
    :return: NSLC code
    :rtype: str
    """
    return '%s.%s.%s.%s' % (dataheader['network'].upper(), dataheader['station'].upper(),
     dataheader['location'].upper(), dataheader['channel'].upper())


def printmetadata(data):
    """Print the data in a pretty format

    Take into account the special case of a dictionary.
    """
    if isinstance(data, dict):
        pprint.pprint(data)
    else:
        print(data)


def str2date(dStr):
    """Transform a string to a datetime.

    :param dStr: A datetime in ISO format.
    :type dStr: string
    :return: A datetime represented the converted input.
    :rtype: datetime
    """
    if dStr is None or not len(dStr):
        return
    else:
        dateParts = dStr.replace('-', ' ').replace('T', ' ')
        dateParts = dateParts.replace(':', ' ').replace('.', ' ')
        dateParts = dateParts.replace('Z', '').split()
        if len(dateParts) == 7:
            dateParts[6] = dateParts[6] + '0' * (6 - len(dateParts[6]))
        return (datetime.datetime)(*map(int, dateParts))


def main():
    dictArchive = dict()
    for name, obj in inspect.getmembers(da):
        if inspect.isclass(obj) and issubclass(obj, da.Archive) and name != 'Archive':
            dictArchive[name] = obj

    helparchive = 'Available options are [%s]' % ', '.join(dictArchive.keys())
    msg = 'Read, manipulate and convert seismic waveforms generated by a DAS system.'
    parser = argparse.ArgumentParser(description=msg)
    parser.add_argument('-l', '--loglevel', help='Verbosity in the output.',
      choices=[
     'CRITICAL', 'ERROR', 'WARNING', 'INFO',
     'DEBUG'],
      default='WARNING')
    parser.add_argument('-d', '--directory', help='Directory where files are located.',
      default='.')
    parser.add_argument('--start', '--starttime', help='Start of the selected time window.\nFormat: 2019-02-01T00:01:02.123456Z',
      default=None)
    parser.add_argument('--end', '--endtime', help='End of the selected time window.\nFormat: 2019-02-01T00:01:02.123456Z',
      default=None)
    parser.add_argument('--chstart', type=int, help='First channel to export',
      default=0)
    parser.add_argument('--chstop', type=int, help='Last channel to export',
      default=None)
    parser.add_argument('--chstep', type=int, help='Step between channels in the selection',
      default=1)
    parser.add_argument('--decimate', type=int, choices=[1, 5], help='Factor by which the sampling rate is lowered by decimation.',
      default=1)
    parser.add_argument('-o', '--outstruct', type=str, choices=(dictArchive.keys()), help=helparchive,
      default='StreamBased')
    parser.add_argument('--metadata', action='store_true', default=False, help='Read and display the metadata from the TDMS files')
    parser.add_argument('-V', '--version', action='version', version=('dasconv v%s' % version))
    parser.add_argument('filename', help='Experiment to read and process. It is usually the first part of the filenames.')
    args = parser.parse_args()
    if args.metadata:
        logging.basicConfig(level=(args.loglevel), stream=(sys.stdout))
    else:
        logging.basicConfig(level=(args.loglevel))
    logs = logging.getLogger('OpenFile')
    logs.setLevel(args.loglevel)
    dtstart = str2date(args.start)
    dtend = str2date(args.end)
    if dtend is not None:
        if dtstart is not None:
            if dtstart >= dtend:
                logs.error('End time is smaller than Start time.')
                return
    td = TDMS((args.filename), directory=(args.directory), iterate=('M' if args.metadata else 'D'), chstart=(args.chstart),
      chstop=(args.chstop),
      chstep=(args.chstep),
      starttime=dtstart,
      endtime=dtend,
      decimate=(args.decimate))
    klass = dictArchive[args.outstruct]
    archive = klass(root='.', strictcheck=False)
    expectedtimes = dict()
    with td:
        curstream = None
        for data in td:
            if args.metadata:
                printmetadata(data)
            else:
                logs.debug(data[1])
                if curstream != nslc(data[1]):
                    if curstream is not None:
                        archive.archive(tr0)
                        logs.info('Storing channel %s' % curstream)
                    curstream = nslc(data[1])
                    tr0 = Trace(data=(data[0]), header=(data[1]))
                else:
                    if data[1]['starttime'] != expectedtimes[curstream]:
                        archive.archive(tr0)
                        tr0 = Trace(data=(data[0]), header=(data[1]))
                    else:
                        tr0 += Trace(data=(data[0]), header=(data[1]))
                    expectedtimes[curstream] = data[1]['starttime'] + data[1]['npts'] / data[1]['sampling_rate']
        else:
            if not args.metadata:
                logs.info('Storing last part of channel %s' % curstream)
                try:
                    archive.archive(tr0)
                except KeyError:
                    archive.archive(tr0)
                except UnboundLocalError:
                    logs.error('Signal was not processed. Probably too short!')


if __name__ == '__main__':
    main()
{"info": {"author": "Lars Berscheid", "author_email": "lars.berscheid@kit.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)", "Programming Language :: C++", "Topic :: Software Development :: Build Tools"], "description": "<div align=\"center\">\n  <center><img width=\"220\" src=\"https://raw.githubusercontent.com/pantor/frankx/master/doc/logo.png\"></div></center>\n  <h3 align=\"center\"><center><i>frankx</i><br>High-Level Motion Library for the Franka Panda Robot</center></h3>\n</div>\n\n<p align=\"center\">\n  <a href=\"https://github.com/pantor/frankx/actions\">\n    <img src=\"https://github.com/pantor/frankx/workflows/CI/badge.svg\" alt=\"CI\">\n  </a>\n\n  <a href=\"https://github.com/pantor/frankx/actions\">\n    <img src=\"https://github.com/pantor/frankx/workflows/Publish/badge.svg\" alt=\"Publish\">\n  </a>\n\n  <a href=\"https://github.com/pantor/frankx/issues\">\n    <img src=\"https://img.shields.io/github/issues/pantor/frankx.svg\" alt=\"Issues\">\n  </a>\n\n  <a href=\"https://github.com/pantor/frankx/releases\">\n    <img src=\"https://img.shields.io/github/v/release/pantor/frankx.svg?include_prereleases&sort=semver\" alt=\"Releases\">\n  </a>\n\n  <a href=\"https://github.com/pantor/frankx/blob/master/LICENSE\">\n    <img src=\"https://img.shields.io/badge/license-LGPL-green.svg\" alt=\"LGPL\">\n  </a>\n</p>\n\n\nFrankx is a high-level motion library (both C++ and Python) for the Franka Emika Panda robot. It adds a Python wrapper around [libfranka](https://frankaemika.github.io/docs/libfranka.html), while replacing necessary real-time programming with higher-level motion commands. As frankx focuses on making real-time trajectory generation easy, it allows the robot to react to unforeseen events.\n\n\n<!-- <div align=\"center\">\n  <center><img width=\"220\" src=\"https://raw.githubusercontent.com/pantor/frankx/master/doc/example.png\"></div></center>\n</div> -->\n\n\n## Installation\n\nFrankx is based on [libfranka](https://github.com/frankaemika/libfranka), [Reflexxes](http://reflexxes.ws) as a trajectory-generator, [Eigen](https://eigen.tuxfamily.org) for transformation calculations and [pybind11](https://github.com/pybind/pybind11) for the Python bindings. Make sure to have these dependencies installed, then you can build and install frankx via\n\n```bash\nmkdir -p build\ncd build\ncmake -DReflexxes_ROOT_DIR=../RMLTypeII -DREFLEXXES_TYPE=ReflexxesTypeII -DBUILD_TYPE=Release ..\nmake -j4\nmake install\n```\n\nOf course, you need to adapt the Reflexxes directory and type (either `ReflexxesTypeII` or `ReflexxesTypeIV`). We strongly recommend Type IV, as the Panda robot is quite sensitive to acceleration discontinuities. To use frankx, you can also include it as a subproject in your parent CMake via `add_subdirectory(frankx)` and then `target_link_libraries(<target> libfrankx)`. Make sure that the built library can be found from Python by adapting your Python Path.\n\n\n## Tutorial\n\nFrankx comes with both a C++ and Python API that differ only regarding real-time capability. We will introduce both languages next to each other. In your C++ project, just include `include <frankx/frankx.hpp>` and link the library. For Python, just `import frankx`. As a first example, only four lines of code are needed for simple robotic motions.\n\n```c++\n#include <frankx/frankx.hpp>\nusing namespace frankx;\n\n// Connect to the robot with the FCI IP address\nRobot robot(\"172.16.0.2\");\n\n// Reduce velocity and acceleration of the robot\nrobot.setDynamicRel(0.05);\n\n// Move the end-effector 20cm in positive x-direction\nauto motion = LinearRelativeMotion(Affine(0.2, 0.0, 0.0));\n\n// Finally move the robot\nrobot.move(motion);\n```\n\nThe corresponding program in Python is\n```python\nfrom frankx import Affine, LinearRelativeMotion, Robot\n\nrobot = Robot(\"172.16.0.2\")\nrobot.set_dynamic_rel(0.05)\n\nmotion = LinearRelativeMotion(Affine(0.2, 0.0, 0.0))\nrobot.move(motion)\n```\n\nFurthermore, we will introduce methods for geometric calculations, for moving the robot according to different motion types, how to implement real-time reactions and changing waypoints in real time as well as controlling the gripper.\n\n\n### Geometry\n\n`frankx::Affine` is a thin wrapper around [Eigen::Affine3d](https://eigen.tuxfamily.org/dox/group__TutorialGeometry.html). It is used for Cartesian poses, frames and transformation. Frankx simplifies the usage of Euler angles (default ZYX-convention).\n```c++\n// Initiliaze a transformation with an (x, y, z, a=0.0, b=0.0, c=0.0) translation\nAffine z_translation = Affine(0.0, 0.0, 0.5);\n\n// Define a rotation transformation using the (x, y, z, a, b, c) parameter list\nAffine z_rotation = Affine(0.0, 0.0, 0.0, M_PI / 3, 0.0, 0.0);\n\n// Make use of the wonderful Eigen library\nauto combined_transformation = z_translation * z_rotation;\n\n// Get the Euler angles (a, b, c) in a vector representation\nEigen::Vector3d euler_angles = combined_transformation.angles();\n\n// Get the vector representation (x, y, z, a, b, c) of an affine transformation\nfrankx::Vector6d pose = combined_transformation.vector();\n```\n\nIn all cases, distances are in [m] and rotations in [rad]. Additionally, there are several helper functions for conversion between Eigen and libfranka's std::array objects. In python, this translates into\n```python\nz_translation = Affine(0.0, 0.0, 0.5)\nz_rotation = Affine(0.0, 0.0, 0.0, math.pi / 3, 0.0, 0.0)\ncombined_transformation = z_translation * z_rotation\n\n# These two are now numpy arrays\neuler_angles = combined_transformation.angles()\npose = combined_transformation.vector()\n```\n\n### Robot\n\nWe wrapped most of the libfanka API (including the RobotState or ErrorMessage) for Python. Moreover, we added methods to adapt the dynamics of the robot for all motions. The `rel` name denotes that this a factor of the maximum constraints of the Panda robot.\n```python\nrobot = Robot(\"172.16.0.2\")\n\n# Recover from errors\nrobot.recover_from_errors()\n\n# Set velocity, acceleration and jerk to 5% of the maximum\nrobot.set_dynamic_rel(0.05)\n\n# Alternatively, you can define each constraint individually\nrobot.velocity_rel = 0.2\nrobot.acceleration_rel = 0.1\nrobot.jerk_rel = 0.01\n```\n\n\n### Motion Types\n\nFrankx defines five different motion types. In python, you can use them as follows:\n```python\n# A point-to-point motion in the joint space\nm1 = JointMotion([-1.81194, 1.17910, 1.75710, -2.1416, -1.14336, 1.63304, -0.43217])\n\n# A linear motion in cartesian space\nm2 = LinearMotion(Affine(0.2, -0.4, 0.3, math.pi / 2, 0.0, 0.0))\nm3 = LinearMotion(Affine(0.2, -0.4, 0.3, math.pi / 2, 0.0, 0.0), elbow=1.7)  # With target elbow angle\n\n# A linear motion in cartesian space relative to the initial position\nm4 = LinearRelativeMotion(Affine(0.0, 0.1, 0.0))\n\n# A more complex motion by defining multiple waypoints\nm5 = WaypointMotion([\n  Waypoint(Affine(0.2, -0.4, 0.2, 0.3, 0.2, 0.1)),\n  # The following waypoint is relative to the prior one\n  Waypoint(Affine(0.0, 0.1, 0.0, Waypoint.ReferenceType.Relative))\n])\n\n# Hold the position for [s]\nm6 = PositionHold(5.0)\n```\n\nThe real robot can be moved by applying a motion to the robot using `move`:\n```python\nrobot.move(m1)\nrobot.move(m2)\n\n# To use a given frame relative to the end effector\ncamera_frame = Affine(0.1, 0.0, 0.1)\nrobot.move(camera_frame, m3)\n\n# To change the dynamics of the motion, use MotionData\ndata = MotionData(0.2)  # Using a dynamic_rel of 0.2 (eventually multiplied with robot.dynamic_rel)\nrobot.move(m4, data)\n```\n\nUsing MotionData, you can adapt the dynamics (velocity, acceleration and jerk) of a specific motion.\n```python\ndata.velocity_rel = 1.0\ndata.jerk_rel = 0.2\n```\n\n\n### Real-Time Reactions\n\nBy adding reactions to the motion data, the robot can react to unforeseen events. In the Python API, you can define conditions by using a comparison between a robot's value and a given threshold. If the threshold is exceeded, the reaction fires. Following comparisons are currently implemented\n```python\nreaction_motion = LinearRelativeMotion(Affine(0.0, 0.0, 0.01))  # Move up for 1cm\n\n# Stop motion if the overall force is greater than 30N\nd1 = MotionData().with_reaction(Reaction(Measure.ForceXYZNorm, Comparison.Greater, 30.0))\n\n# Apply reaction motion if the force in z-direction is greater than 10N\nd2 = MotionData().with_reaction(Reaction(Measure.ForceZ, Comparison.Greater, 10.0), reaction_motion)\n\n# Stop motion if its duration is above 30s\nd3 = MotionData().with_reaction(Reaction(Measure.Time, Comparison.Greater, 30.0))\n\nrobot.move(m2, d2)\n\n# Check if the reaction was triggered\nif d2.has_fired:\n  robot.recover_from_errors()\n  print('Force exceeded 10N!')\n```\n\nOnce a reaction has fired, it will be neglected furthermore. In C++ you can additionally use lambdas to define more complex behaviours:\n```c++\n// Stop motion if force is over 10N\nauto data = MotionData()\n  .withReaction({\n    Measure::ForceXYZNorm, Comparison::Greater, 10.0  // [N]\n  })\n  .withReaction({\n    [](const franka::RobotState& state, double time) {\n      return (state.current_errors.self_collision_avoidance_violation);\n    }\n  });\n\n// Hold position for 5s\nrobot.move(PositionHold(5.0), data); // [s]\n// e.g. combined with a PositionHold, the robot continues its program after pushing the end effector.\n```\n\n\n### Real-Time Waypoint Motion\n\nWhile the robot moves in a background thread, you can change the waypoints in real-time. This is currently only possible from the C++ API.\n```c++\nrobot.moveAsync(motion_hold);\n\n// Wait for key input from user\nstd::cin.get();\n\nmotion_hold.setNextWaypoint(Waypoint(Affine(0.0, 0.0, 0.1), Waypoint::ReferenceType::Relative);\n```\n\nIf you need this functionality using Python, feel free to make a pull request!\n\n\n### Gripper\n\nIn the `frankx::Gripper` class, the default gripper force and gripper speed can be set. Then, additionally to the libfranka commands, the following helper methods can be used:\n\n```c++\nauto gripper = Gripper(\"172.16.0.2\");\n\n// These are the default values\ngripper.gripper_speed = 0.02; // [m/s]\ngripper.gripper_force = 20.0; // [N]\n\n// Preshape gripper before grasp, use the given speed\ngripper.move(50.0); // [mm]\n\n// Grasp an object of unknown width\nis_grasping = gripper.clamp();\n\n// Do something\nis_grasping &= gripper.isGrasping();\n\n// Release an object and move to a given distance\nif (is_grasping) {\n  gripper.release(50.0);\n}\n```\n\nThe Python API should be very straight-forward for the Gripper class.\n\n\n## Documentation\n\nWe will add a more detailed documentation once frankx reaches v1.0. However, you can find multiple examples for both C++ and Python in the [examples](https://github.com/pantor/frankx/tree/master/examples) directory. We also try to add more examples over time.\n\n\n## Development\n\nFrankx is written in C++17 and Python3. It works well with ROS2. It is currently tested against following versions\n\n- Python v3.6\n- Eigen v3.3.7\n- Libfranka v0.6.0\n- Reflexxes v1.2.7\n- Pybind11 v2.2.4\n- Catch2 v2.9 (only for testing)\n\n\n## License\n\nFor non-commercial applications, this software is licensed under the LGPL v3.0. If you want to use frankx within commercial applications or under a different license, please contact us for individual agreements.\n\nRobot vector created by [freepik](https://www.freepik.com/free-photos-vectors/technology).\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pantor/frankx", "keywords": "robotics,trajectory-generation,motion-control", "license": "LGPL", "maintainer": "", "maintainer_email": "", "name": "frankx", "package_url": "https://pypi.org/project/frankx/", "platform": "", "project_url": "https://pypi.org/project/frankx/", "project_urls": {"Homepage": "https://github.com/pantor/frankx"}, "release_url": "https://pypi.org/project/frankx/0.0.1/", "requires_dist": null, "requires_python": ">=3.6", "summary": "High-Level Motion Library for the Franka Panda Robot", "version": "0.0.1"}, "last_serial": 6008360, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "39245bdde4375b203d069f8456e0b158", "sha256": "ac57894c5e0912a9d71b467c3905d926d6af1277b69f4d07cc39ab6eac548990"}, "downloads": -1, "filename": "frankx-0.0.1-cp36-cp36m-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "39245bdde4375b203d069f8456e0b158", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.6", "size": 1741708, "upload_time": "2019-10-21T17:18:36", "upload_time_iso_8601": "2019-10-21T17:18:36.253776Z", "url": "https://files.pythonhosted.org/packages/45/fe/f06c2490e8550889b32120b723a236349e2a2b66ca4a022f2a8982b3e3c7/frankx-0.0.1-cp36-cp36m-manylinux2010_x86_64.whl"}]}, "urls": [{"comment_text": "", "digests": {"md5": "39245bdde4375b203d069f8456e0b158", "sha256": "ac57894c5e0912a9d71b467c3905d926d6af1277b69f4d07cc39ab6eac548990"}, "downloads": -1, "filename": "frankx-0.0.1-cp36-cp36m-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "39245bdde4375b203d069f8456e0b158", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.6", "size": 1741708, "upload_time": "2019-10-21T17:18:36", "upload_time_iso_8601": "2019-10-21T17:18:36.253776Z", "url": "https://files.pythonhosted.org/packages/45/fe/f06c2490e8550889b32120b723a236349e2a2b66ca4a022f2a8982b3e3c7/frankx-0.0.1-cp36-cp36m-manylinux2010_x86_64.whl"}]}
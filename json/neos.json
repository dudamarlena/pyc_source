{"info": {"author": "Nathan Simpson", "author_email": "nathan.simpson@hep.lu.se", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "# neos\n> nice end-to-end optimized statistics ;)\n\n\n<img src=\"neos_logo.png\" alt=\"logo\" width=\"200\" align=\"middle\">\n\n![](training.gif)\n\n## Install\n`pip install neos`\n\n## How to use (and reproduce the results from the cool animation)\n\n```python\nimport jax\nimport neos.makers as makers\nimport neos.cls as cls\nimport numpy as np\nimport jax.experimental.stax as stax\nimport jax.experimental.optimizers as optimizers\nimport jax.random\nimport time\n```\n\n### Initialise network using `jax.experimental.stax`\n\n```python\ninit_random_params, predict = stax.serial(\n    stax.Dense(1024),\n    stax.Relu,\n    stax.Dense(1024),\n    stax.Relu,\n    stax.Dense(2),\n    stax.Softmax,\n)\n```\n\n### Initialse tools from `neos`:\n\nThe way we initialise in `neos` is to define functions that make a statistical model from histograms, which in turn are themselves made from a predictive model, such as a neural network. Here's some detail on the unctions used below:\n\n- `hists_from_nn_three_blobs(predict)` uses the nn decision function `predict` defined in the cell above to form histograms from signal and background data, all drawn from multivariate normal distributions with different means. Two background distributions are sampled from, which is meant to mimic the situation in particle physics where one has a 'nominal' prediction for a nuisance parameter and then an alternate value (e.g. from varying up/down by one standard deviation), which then modifies the background pdf. Here, we take that effect to be a shift of the mean of the distribution. The value for the background histogram is then the mean of the resulting counts of the two modes, and the uncertainty can be quantified through the count standard deviation.\n- `nn_hepdata_like(hmaker)` uses `hmaker` to construct histograms, then feeds them into the `neos.models.hepdata_like` function that constructs a pyhf-like model. This can then be used to call things like `logpdf` and `expected_data` downstream.\n- `cls_maker` takes a model-making function as it's primary argument, which is fed into functions from `neos.fit` that minimise the `logpdf` of the model in both a constrained (fixed parameter of interest) and a global way. Moreover, these fits are wrapped in a function that allows us to calculate gradients through the fits using *fixed-point differentiation*. This allows for the calculation of both the profile likelihood and its gradient, and then the same for cls :)\n\nAll three of these methods return functions. in particular, `cls_maker` returns a function that differentiably calculates cls values, which is our desired objective to minimise.\n\n```python\nhmaker = makers.hists_from_nn_three_blobs(predict)\nnnm = makers.nn_hepdata_like(hmaker)\nloss = cls.cls_maker(nnm, solver_kwargs=dict(pdf_transform=True))\n```\n\n```python\n_, network = init_random_params(jax.random.PRNGKey(2), (-1, 2))\n```\n\n    /home/phinate/envs/neos/lib/python3.7/site-packages/jax-0.1.59-py3.7.egg/jax/lib/xla_bridge.py:122: UserWarning: No GPU/TPU found, falling back to CPU.\n\n\n### Define training loop!\n\n```python\nopt_init, opt_update, opt_params = optimizers.adam(1e-3)\n\ndef update_and_value(i, opt_state, mu):\n    net = opt_params(opt_state)\n    value, grad = jax.value_and_grad(loss)(net, mu)\n    return opt_update(i, grad, opt_state), value, net\n\ndef train_network(N):\n    cls_vals = []\n    _, network = init_random_params(jax.random.PRNGKey(1), (-1, 2))\n    state = opt_init(network)\n    losses = []\n\n    for i in range(N):\n        start_time = time.time()\n        state, value, network = update_and_value(i,state,1.0)\n        epoch_time = time.time() - start_time\n        losses.append(value)\n        metrics = {\"loss\": losses}\n        yield network, metrics, epoch_time\n```\n\n### Let's run it!!\n\n```python\nmaxN = 20 # make me bigger for better results!\n\n# Training\nfor i, (network, metrics, epoch_time) in enumerate(train_network(maxN)):\n    print(f\"epoch {i}:\", f'CLs = {metrics[\"loss\"][-1]}, took {epoch_time}s') \n```\n\n    epoch 0: CLs = 0.06680655092981347, took 5.355436325073242s\n    epoch 1: CLs = 0.4853891149072429, took 1.5733795166015625s\n    epoch 2: CLs = 0.3379355596004474, took 1.5171947479248047s\n    epoch 3: CLs = 0.1821927415636535, took 1.5081253051757812s\n    epoch 4: CLs = 0.09119136931683047, took 1.5193650722503662s\n    epoch 5: CLs = 0.04530559823843272, took 1.5008423328399658s\n    epoch 6: CLs = 0.022572851867672883, took 1.499192476272583s\n    epoch 7: CLs = 0.013835564056077887, took 1.5843737125396729s\n    epoch 8: CLs = 0.01322058601444187, took 1.520324468612671s\n    epoch 9: CLs = 0.013407422454837725, took 1.5050244331359863s\n    epoch 10: CLs = 0.011836452218993765, took 1.509469985961914s\n    epoch 11: CLs = 0.00948507486266359, took 1.5089364051818848s\n    epoch 12: CLs = 0.007350505632595539, took 1.5106918811798096s\n    epoch 13: CLs = 0.005755974539907838, took 1.5267891883850098s\n    epoch 14: CLs = 0.0046464301411786035, took 1.5851080417633057s\n    epoch 15: CLs = 0.0038756402968267434, took 1.8452086448669434s\n    epoch 16: CLs = 0.003323640670405803, took 1.9116990566253662s\n    epoch 17: CLs = 0.0029133909840759475, took 1.7648999691009521s\n    epoch 18: CLs = 0.002596946123608612, took 1.6314191818237305s\n    epoch 19: CLs = 0.0023454051342963744, took 1.5911424160003662s\n\n\nAnd there we go!! We discovered a new signal (depending on your arbitrary thershold) ;)\n\nIf you want to reproduce the full animation, a version of this code with plotting helpers can be found in `demo_training.ipynb`! :D\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/phinate/neos", "keywords": "inference machine learning particle physics", "license": "Apache Software License 2.0", "maintainer": "", "maintainer_email": "", "name": "neos", "package_url": "https://pypi.org/project/neos/", "platform": "", "project_url": "https://pypi.org/project/neos/", "project_urls": {"Homepage": "https://github.com/phinate/neos"}, "release_url": "https://pypi.org/project/neos/0.0.1/", "requires_dist": ["jax", "jaxlib", "matplotlib", "numpy", "pyhf", "celluloid"], "requires_python": ">=3.6", "summary": "Library for optimally representing data with neural networks with respect to statistical inference in a particle physics context.", "version": "0.0.1"}, "last_serial": 6754380, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "c228b478628f07b2497a3dfd98b35d3a", "sha256": "a6128efa36b0b49088e800a6d1ae4a8db691ea57c827a29ba83d7bcb94cce279"}, "downloads": -1, "filename": "neos-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "c228b478628f07b2497a3dfd98b35d3a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 18055, "upload_time": "2020-03-05T10:16:28", "upload_time_iso_8601": "2020-03-05T10:16:28.416856Z", "url": "https://files.pythonhosted.org/packages/d3/c6/33de4405dd0e85e747d54bc2b16a23d64b0a028bca1a9589c10443219a8f/neos-0.0.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "ee859b84bb1172261d1979194659c2e2", "sha256": "9e07ce206a17220334a56dd7acc84063a9c9ee6d47ae7ee50a3c251262e58421"}, "downloads": -1, "filename": "neos-0.0.1.tar.gz", "has_sig": false, "md5_digest": "ee859b84bb1172261d1979194659c2e2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 14614, "upload_time": "2020-03-05T10:16:31", "upload_time_iso_8601": "2020-03-05T10:16:31.550087Z", "url": "https://files.pythonhosted.org/packages/63/f0/3654153f964c34843398139be22635e608320e8b7a5041a96912d5c8dc20/neos-0.0.1.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "c228b478628f07b2497a3dfd98b35d3a", "sha256": "a6128efa36b0b49088e800a6d1ae4a8db691ea57c827a29ba83d7bcb94cce279"}, "downloads": -1, "filename": "neos-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "c228b478628f07b2497a3dfd98b35d3a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 18055, "upload_time": "2020-03-05T10:16:28", "upload_time_iso_8601": "2020-03-05T10:16:28.416856Z", "url": "https://files.pythonhosted.org/packages/d3/c6/33de4405dd0e85e747d54bc2b16a23d64b0a028bca1a9589c10443219a8f/neos-0.0.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "ee859b84bb1172261d1979194659c2e2", "sha256": "9e07ce206a17220334a56dd7acc84063a9c9ee6d47ae7ee50a3c251262e58421"}, "downloads": -1, "filename": "neos-0.0.1.tar.gz", "has_sig": false, "md5_digest": "ee859b84bb1172261d1979194659c2e2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 14614, "upload_time": "2020-03-05T10:16:31", "upload_time_iso_8601": "2020-03-05T10:16:31.550087Z", "url": "https://files.pythonhosted.org/packages/63/f0/3654153f964c34843398139be22635e608320e8b7a5041a96912d5c8dc20/neos-0.0.1.tar.gz"}]}
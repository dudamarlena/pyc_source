{"info": {"author": "Alexander Kozhevnikov", "author_email": "mentalisttraceur@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.3", "Programming Language :: Python :: 2.4", "Programming Language :: Python :: 2.5", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: IronPython", "Programming Language :: Python :: Implementation :: Jython", "Programming Language :: Python :: Implementation :: PyPy", "Programming Language :: Python :: Implementation :: Stackless"], "description": "compose\n=======\n\nThe classic ``compose``, with all the Pythonic features.\n\nThis ``compose`` follows the lead of ``functools.partial``\nand returns callable ``compose`` objects which:\n\n* have a regular and unambiguous ``repr``,\n* retain correct signature introspection,\n* allow introspection of the composed callables,\n* can be type-checked,\n* can be weakly referenced,\n* can have attributes,\n* will merge when nested, and\n* can be pickled (if all composed callables can be pickled).\n\nThis ``compose`` also fails fast with a ``TypeError`` if any\nargument is not callable, or when called with no arguments.\n\n\nVersioning\n----------\n\nThis library's version numbers follow the `SemVer 2.0.0 specification\n<https://semver.org/spec/v2.0.0.html>`_.\n\nThe current version number is available in the variable ``__version__``,\nas is normal for Python modules.\n\n\nInstallation\n------------\n\n::\n\n    pip install compose\n\n\nUsage\n-----\n\nImport ``compose``:\n\n.. code:: python\n\n    from compose import compose\n\nAll the usual function composition you know and love:\n\n.. code:: python\n\n    >>> def double(x):\n    ...     return x * 2\n    ...\n    >>> def increment(x):\n    ...     return x + 1\n    ...\n    >>> double_then_increment = compose(increment, double)\n    >>> double_then_increment(1)\n    3\n\nOf course any number of functions can be composed:\n\n.. code:: python\n\n    >>> def double(x):\n    ...     return x * 2\n    ...\n    >>> times_eight = compose(douple, double, double)\n    >>> times_16 = compose(douple, double, double, double)\n\nWe still get the correct signature introspection:\n\n.. code:: python\n\n    >>> def f(a, b, c=0, **kwargs):\n    ...     pass\n    ...\n    >>> def g(x):\n    ...     pass\n    ...\n    >>> g_of_f = compose(g, f)\n    >>> import inspect\n    >>> inspect.signature(g_of_f)\n    <Signature (a, b, c=0, **kwargs)>\n\nAnd we can inspect all the composed callables:\n\n.. code:: python\n\n    >>> g_of_f.functions  # in order of execution:\n    (<function f at 0x4048e6f0>, <function g at 0x405228e8>)\n\nWhen programmatically inspecting arbitrary callables, we\ncan check if we are looking at a ``compose`` instance:\n\n.. code:: python\n\n    >>> isinstance(g_of_f, compose)\n    True\n\n\nDesign Decisions\n----------------\n\n* The result of ``compose`` should be a drop-in replacement to\n  functions in as many code paths as possible. Therefore:\n\n  * The proper signature of the composed function is exposed\n    in the standard Python way (by exposing the \"inner-most\"\n    function as the attribute ``__wrapped__``).\n\n  * Arbitrary attribute assignment (``__dict__``) should work,\n    because Python allows people to do that to functions.\n\n  * Weak references (``__weakref__``) are supported,\n    because Python allows weakly referencing functions.\n\n* Failing-fast as much as possible because that is important\n  to help debugging by keeping errors local to their causes.\n\n* Treating ``compose()`` with no arguments as an error, instead\n  of as implicitly composing with an identity function, because:\n\n  * It avoids turning mistakes into silent misbehavior by default.\n\n  * People who want the other behavior can more trivially build\n    it on top of this behavior than the other way around:\n\n    .. code:: python\n\n        compose = partial(compose, identity)\n\n* Doing ``__init__(self, *functions)`` instead of\n  ``__init__(self, function, *functions)`` because:\n\n  * It makes the signature and docstring more correctly hint that the\n    first function argument is not special or different from the rest.\n\n  * It allows manually raising an error with a clearer and more\n    helpful message if ``compose()`` is called with no arguments.\n\n* Using ``functools.recursive_repr`` if available because if recursion\n  happens, having a working and recursion-safe ``__repr__`` would\n  likely be extremely helpful for debugging and code robustness.\n\n  Not going beyond that because the code involved would be complex and\n  not portable across Python implementations, and the right place to\n  solve that is a separate polyfil if at all possible.\n\n* ``self`` has to be a positional-only argument of ``__call__``\n  to make ``__call__`` properly transparent in all cases.\n\n  If the user makes a typo, ``**``-splats arguments, or otherwise\n  ends up passing ``self`` in ``kwargs``, maybe even intentionally,\n  function composition should still work correctly - in this case,\n  silent seemingly-successful unintended misbehavior would be awful.\n\n  If the user uses ``compose`` to implement methods, the ``self``\n  argument to that method going through ``compose`` will normally\n  be a positional argument, but ideally should be passed through\n  transparently even if not, to match how normal methods work.\n\n* Manually getting ``self`` from ``*args`` in ``__call__``\n  **portably** makes ``self`` a positional-only argument.\n\n* Optimization priorities are:\n\n  1. \"Optimize for optimization\": implementing the essential logic\n     of the intended behavior in as clearly and simply as possible,\n     because that helps optimizers.\n\n  2. ``__call__``, because that is the code path which can only be\n     extracted from hot loops or other spots where performance\n     matters by not using ``compose`` at all.\n\n  3. ``__init__``, because composing callables together is also\n     essential to actually using this, and in some cases cannot\n     be pulled out of performance-sensitive code paths.\n\n  4. Not storing data redundantly, because memory-constrained\n     systems are a thing, and it is much easier to add redundant\n     data on top of an implementation than it is to remove it.\n\n* Flattening nested instances of ``compose`` because\n\n  * It makes the repr much more helpful for debugging and\n    interactive usage. It is more common to want to know\n    what the actual composed callable does, than to know\n    the tree of nested ``compose`` calls that created it.\n\n  * ``__call__`` performance is more important in typical cases\n    than runspace efficiency (see above performance priorities).\n\n  * Intermediate composed functions that are never used\n    after composing them with something else can just\n    be deleted so that they don't take up memory.\n\n  * It is more trivial to prevent the flattening by using a\n    simple wrapper function or class on this implementation\n    than flattening on top of a not-flattening one.\n\n* Using tuples and a read-only ``@property`` for storing\n  and exposing the composed functions because:\n\n  * Immutability helps reasoning about and validating code.\n\n  * Immutable types provide more optimisation opportunities\n    that a Python implementation could take advantage of.\n\n  * Discouraging mutations encourages optimizer-friendly code.\n\n  * Mutability is normally not needed for composed functions.\n\n  * ``functools.partial`` also only exposes read-only attributes.\n\n  * Immutability now is forward-compatible with mutability later;\n    changing mutability into immutability is a breaking change.\n\n  * A simple mutable variant can be implemented trivially\n    on top of the current immutable ``compose``:\n\n    .. code:: python\n\n        class compose(compose):\n            def __init__(self, *functions):\n                super().__init__(*functions)\n                self._wrappers = list(self._wrappers)\n\n* Generating the ``functions`` attribute tuple every time instead\n  of caching it, because:\n\n  * This implementation prevents *accidental* inconsistencies\n    if someone intentionally bypasses the immutability.\n\n    (Intentional inconsistencies that can only be introduced *by\n    deliberately modifying the implementation* are fine. What's\n    important is minimizing the surface area for errors and\n    debugging difficulty being introduced by merely *forgetting*\n    or *not realizing* the need to keep things consistent.)\n\n  * The performance priority of not storing data redundantly as\n    part of composing and calling is usually more important\n    than introspection performance, *especially* because the\n    caching can be implemented much more trivially on top of\n    this implementation than preventing caching would be if\n    it was implemented in ``compose``.\n\n  * A caching variant can be implemented fairly easily\n    on top of the current non-caching ``compose``:\n\n    .. code:: python\n\n        import functools\n\n        class compose(compose):\n            @property\n            @functools.lru_cache(maxsize=1)\n            def functions(self):\n                return super().functions\n\n* Storing the first function separately from the rest allows\n  ``__call__`` to be more efficient, simpler, and clearer.\n\n* ``__wrapped__`` cannot be a ``@property`` because several\n  functions in the standard library cannot handle that.\n\n  As a minor point, \"portability conservatism\": it is safer\n  to bet on the most conservative feature-set possible.\n\n* Not using ``__slots__`` because of many reasons adding up:\n\n  * ``__call__`` performance is basically the same, at best\n    only marginally better, when using ``__slots__``.\n\n    (``__init__`` sees a better but still small improvement.)\n\n    On PyPy, ``__call__`` ends up getting optimized to the\n    same blazingly performant code with or without\n    ``__slots__`` - makes no difference. On CPython, the\n    no-``__slots__`` variant actually performs better once\n    ``__wrapped__`` is supported (see below).\n\n  * ``__slots__`` forces more code to support older\n    pickle protocols for those who might need that.\n\n    (But one-liner ``__getstate__`` and ``__setstate__`` that\n    just handle the 3-tuple of ``_wrapped``, ``_wrappers``,\n    and ``__dict__`` would work, and are probably optimal.)\n\n  * ``__wrapped__`` cannot be in ``__slots__`` because that has\n    the same problem as making it a ``@property`` (see above).\n\n  * ``__wrapped__`` can be implemented with ``__getattribute__``\n    redirecting to a slotted ``_wrapped``, but implementing the\n    ``__getattribute__`` function is much slower than just not\n    using ``__slots__`` at all, since it proxies all attribute\n    access.\n\n  * ``__wrapped__`` can be implemented with ``__getattr__``\n    redirecting to a slotted ``_wrapped``, although once\n    upon a type Transcrypt didn't support ``__getattr__``,\n    which is a great example for portability conservatism.\n\n    Moreover, testing shows that adding ``__getattr__`` to\n    a class still makes the whole slotted implementation\n    slower somehow (merely removing ``__getattr__`` from\n    the class definition makes tests which never use\n    ``__getattr__`` go faster, although there is no\n    reason at the level of Python semantics for why this\n    should be the case). Once PyPy warms up, this is\n    negligible, and on CPython it is relatively minor,\n    but it is still strictly worse on most systems tested.\n\n  * ``__wrapped__`` can be just a *copy* of a slotted attribute,\n    but the same reasons apply against this as against making\n    ``functions`` a cached copy.\n\n  * If ``__wrapped__`` is stored in ``__dict__`` and is always\n    set in ``__init__``, a lot of the memory savings from\n    using ``__slots__`` are negated too.\n\n* When flattening composed ``compose`` instances in ``__init__``,\n  ``__wrapped__`` and ``_wrapped`` attributes are used instead\n  of the ``functions`` attribute, because:\n\n  * Speed of composition significantly increases, given\n    that ``functions`` is generated every time.\n\n  * The loss of symmetry between this and the public interface\n    of the ``functions`` attribute is unfortunate, because it\n    forces any subclasses to use ``_wrappers`` consistently\n    with ``compose`` instead of just ``functions``, but the\n    advantage seems to be worthwhile.\n\n* The ``functions`` generation uses ``tuple(self._wrappers)``\n  instead of just ``self._wrappers`` to enable subclasses\n  that make ``_wrappers`` something other than a tuple to\n  still work properly.\n\n  A subclass which wants ``functions`` itself to be something\n  other than a tuple would need to provide that themselves,\n  but this should cover at least some cases.\n\n  Importantly, because tuples are immutable, calling ``tuple``\n  on a tuple just returns the same tuple instead of copying in\n  CPython, and other Pythons can do that optimization too.\n\n* Not providing a separate ``rcompose`` (which would compose\n  its arguments in reverse order) for now, because it is\n  trivial to implement on top of ``compose`` if needed:\n\n  .. code:: python\n\n      def rcompose(*functions):\n          return compose(*reversed(functions))\n\n* Not providing a separate \"just a normal function\" variant for now,\n  because it is trivial to implement on top of ``compose`` if needed:\n\n  .. code:: python\n\n      def fcompose(*functions):\n          composed = compose(*functions)\n          return lambda *args, **kwargs: composed(*args, **kwargs)\n\n* Not providing descriptor support like ``functools.partialmethod``\n  for now, until a need for it becomes apparent which a \"normal\n  function\" variant (see last point) does not satisfy well enough.\n\n* Not providing an ``async``/``await`` variant for now, because\n  it is not yet clear if it is useful enough or if the best\n  place for it is this package, and in the meantime it can be\n  implemented on top of ``compose`` if needed:\n\n  .. code:: python\n\n      import inspect\n\n      class acompose(compose):\n          async def __call__(self, /, *args, **kwargs):\n              result = self.__wrapped__(*args, **kwargs)\n              if inspect.isawaitable(result):\n                  result = await result\n              for function in self._wrappers:\n                  result = function(result)\n                  if inspect.isawaitable(result):\n                      result = await result\n              return result\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mentalisttraceur/python-compose", "keywords": "", "license": "0BSD (BSD Zero Clause License)", "maintainer": "", "maintainer_email": "", "name": "compose", "package_url": "https://pypi.org/project/compose/", "platform": "", "project_url": "https://pypi.org/project/compose/", "project_urls": {"Homepage": "https://github.com/mentalisttraceur/python-compose"}, "release_url": "https://pypi.org/project/compose/1.1.0/", "requires_dist": null, "requires_python": "", "summary": "The classic ``compose``, with all the Pythonic features.", "version": "1.1.0"}, "last_serial": 7008546, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "d68d92ca2f9fca6ef34881ae3c1c4289", "sha256": "6c63ce9800e600e0e810dd04fff53f02846db15a38a5153997241b0b3df697c0"}, "downloads": -1, "filename": "compose-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d68d92ca2f9fca6ef34881ae3c1c4289", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 5515, "upload_time": "2020-02-25T18:06:13", "upload_time_iso_8601": "2020-02-25T18:06:13.584361Z", "url": "https://files.pythonhosted.org/packages/fc/ee/0d2592931f0195ca2ef9b062ce98aff87b8eb229be894baab7982b0c5a89/compose-1.0.0-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "0c210c3348a5d9af43c4ae70005cf748", "sha256": "048a8f23b5127a83c99fe9f2e4de638dfc0d2cb76c9db3f39babe8d831fdcf7c"}, "downloads": -1, "filename": "compose-1.0.0.tar.gz", "has_sig": false, "md5_digest": "0c210c3348a5d9af43c4ae70005cf748", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5319, "upload_time": "2020-02-25T18:06:16", "upload_time_iso_8601": "2020-02-25T18:06:16.026782Z", "url": "https://files.pythonhosted.org/packages/0c/9d/27df8f871de0183b8b829411fcb8db16caa1b093002168c5bf0b94fe96a5/compose-1.0.0.tar.gz"}], "1.1.0": [{"comment_text": "", "digests": {"md5": "459d7058768cd72189405845b9b7dde1", "sha256": "e65098dd190dc16d71e751e4687ddacbbc20fb82e00e940411d077990749150f"}, "downloads": -1, "filename": "compose-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "459d7058768cd72189405845b9b7dde1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8136, "upload_time": "2020-04-13T09:01:40", "upload_time_iso_8601": "2020-04-13T09:01:40.260138Z", "url": "https://files.pythonhosted.org/packages/db/2d/aa8257e46e094bb94b3793fa3ba1a2ad1205d3a617820c2834bd4e10d0db/compose-1.1.0-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "3924c7b4fcad8ba2aa6f8c8164464416", "sha256": "4a3d5ee8ed42b9bc10e08ddd29c348037742218396caffe1880e9976d63adf57"}, "downloads": -1, "filename": "compose-1.1.0.tar.gz", "has_sig": false, "md5_digest": "3924c7b4fcad8ba2aa6f8c8164464416", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8891, "upload_time": "2020-04-13T09:01:42", "upload_time_iso_8601": "2020-04-13T09:01:42.769302Z", "url": "https://files.pythonhosted.org/packages/8f/ee/9cef14c3499115d3b23a95a81b73d5d9b190ed3a7181b41c728aaac55aa7/compose-1.1.0.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "459d7058768cd72189405845b9b7dde1", "sha256": "e65098dd190dc16d71e751e4687ddacbbc20fb82e00e940411d077990749150f"}, "downloads": -1, "filename": "compose-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "459d7058768cd72189405845b9b7dde1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8136, "upload_time": "2020-04-13T09:01:40", "upload_time_iso_8601": "2020-04-13T09:01:40.260138Z", "url": "https://files.pythonhosted.org/packages/db/2d/aa8257e46e094bb94b3793fa3ba1a2ad1205d3a617820c2834bd4e10d0db/compose-1.1.0-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "3924c7b4fcad8ba2aa6f8c8164464416", "sha256": "4a3d5ee8ed42b9bc10e08ddd29c348037742218396caffe1880e9976d63adf57"}, "downloads": -1, "filename": "compose-1.1.0.tar.gz", "has_sig": false, "md5_digest": "3924c7b4fcad8ba2aa6f8c8164464416", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8891, "upload_time": "2020-04-13T09:01:42", "upload_time_iso_8601": "2020-04-13T09:01:42.769302Z", "url": "https://files.pythonhosted.org/packages/8f/ee/9cef14c3499115d3b23a95a81b73d5d9b190ed3a7181b41c728aaac55aa7/compose-1.1.0.tar.gz"}]}
{"info": {"author": "Per A. Brodtkorb", "author_email": "per.andreas.brodtkorb@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Education", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Operating System :: MacOS", "Operating System :: Microsoft :: Windows", "Operating System :: OS Independent", "Operating System :: POSIX :: Linux", "Operating System :: Unix", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: GIS", "Topic :: Scientific/Engineering :: Mathematics"], "description": "\n=======\nnvector\n=======\n\n|nvector_img| |tests_img| |docs_img| |health_img| |coverage_img| |versions_img| |downloads_img|\n\nNvector is a suite of tools written in Python to solve geographical position\ncalculations like:\n\n* Calculate the surface distance between two geographical positions.\n\n* Convert positions given in one reference frame into another reference frame.\n\n* Find the destination point given start point, azimuth/bearing and distance.\n\n* Find the mean position (center/midpoint) of several geographical positions.\n\n* Find the intersection between two paths.\n\n* Find the cross track distance between a path and a position.\n\n\nDescription\n===========\n\nIn this library, we represent position with an \"n-vector\",  which\nis the normal vector to the Earth model (the same reference ellipsoid that is\nused for latitude and longitude). When using n-vector, all Earth-positions are\ntreated equally, and there is no need to worry about singularities or\ndiscontinuities. An additional benefit with using n-vector is that many\nposition calculations can be solved with simple vector algebra\n(e.g. dot product and cross product).\n\nConverting between n-vector and latitude/longitude is unambiguous and easy\nusing the provided functions.\n\nn_E is n-vector in the program code, while in documents we use nE. E denotes\nan Earth-fixed coordinate frame, and it indicates that the three components of\nn-vector are along the three axes of E. More details about the notation and\nreference frames can be found here:\n\nDocumentation and code\n======================\n\nOfficial documentation:\n\nhttp://www.navlab.net/nvector/\n\nhttp://nvector.readthedocs.io/en/latest/\n\n*Kenneth Gade (2010):*\n    `A Nonsingular Horizontal Position Representation,\n    The Journal of Navigation, Volume 63, Issue 03, pp 395-417, July 2010.\n    <http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf>`_\n\n\nBleeding edge: https://github.com/pbrod/nvector.\n\nOfficial releases available at: http://pypi.python.org/pypi/nvector.\n\n\nInstallation\n============\n\nIf you have pip installed and are online, then simply type:\n\n    $ pip install nvector\n\nto get the lastest stable version. Using pip also has the advantage that all\nrequirements are automatically installed.\n\nYou can download nvector and all dependencies to a folder \"pkg\", by the following:\n\n   $ pip install --download=pkg nvector\n\nTo install the downloaded nvector, just type:\n\n   $ pip install --no-index --find-links=pkg nvector\n\n\nUnit tests\n===========\nTo test if the toolbox is working paste the following in an interactive\npython session::\n\n   import nvector as nv\n   nv.test('--doctest-modules')\n\nor\n\n   $ py.test --pyargs nvector --doctest-modules\n\nat the command prompt.\n\n\nAcknowledgement\n===============\nThe `nvector package <http://pypi.python.org/pypi/nvector/>`_ for\n`Python <https://www.python.org/>`_ was written by Per A. Brodtkorb at\n`FFI (The Norwegian Defence Research Establishment) <http://www.ffi.no/en>`_\nbased on the `nvector toolbox <http://www.navlab.net/nvector/#download>`_ for\n`Matlab <http://www.mathworks.com>`_ written by the navigation group at\n`FFI <http://www.ffi.no/en>`_.\n\nMost of the content is based on the following article:\n\n*Kenneth Gade (2010):*\n    `A Nonsingular Horizontal Position Representation,\n    The Journal of Navigation, Volume 63, Issue 03, pp 395-417, July 2010.\n    <http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf>`_\n\nThus this article should be cited in publications using this page or the\ndownloaded program code.\n\n\nGetting Started\n===============\n\nBelow the object-oriented solution to some common geodesic problems are given.\nIn the first example the functional solution is also given.\nThe functional solutions to the remaining problems can be found in\n`test_nvector.py\n<https://github.com/pbrod/nvector/blob/master/src/nvector/tests/test_nvector.py>`_.\n\n\n**Example 1: \"A and B to delta\"**\n---------------------------------\n\n.. image:: http://www.navlab.net/images/ex1img.png\n\nGiven two positions, A and B as latitudes, longitudes and depths relative to\nEarth, E.\n\nFind the exact vector between the two positions, given in meters north, east,\nand down, and find the direction (azimuth) to B, relative to north.\nAssume WGS-84 ellipsoid. The given depths are from the ellipsoid surface.\nUse position A to define north, east, and down directions.\n(Due to the curvature of Earth and different directions to the North Pole,\nthe north, east, and down directions will change (relative to Earth) for\ndifferent places.  A must be outside the poles for the north and east\ndirections to be defined.)\n\nSolution:\n    >>> import numpy as np\n    >>> import nvector as nv\n    >>> wgs84 = nv.FrameE(name='WGS84')\n    >>> pointA = wgs84.GeoPoint(latitude=1, longitude=2, z=3, degrees=True)\n    >>> pointB = wgs84.GeoPoint(latitude=4, longitude=5, z=6, degrees=True)\n\nStep1:  Find p_AB_N (delta decomposed in N).\n    >>> p_AB_N = pointA.delta_to(pointB)\n    >>> x, y, z = p_AB_N.pvector.ravel()\n    >>> valtxt = '{0:8.2f}, {1:8.2f}, {2:8.2f}'.format(x, y, z)\n    >>> 'Ex1: delta north, east, down = {}'.format(valtxt)\n    'Ex1: delta north, east, down = 331730.23, 332997.87, 17404.27'\n\nStep2: Also find the direction (azimuth) to B, relative to north:\n    >>> azimuth = p_AB_N.azimuth_deg[0]\n    >>> 'azimuth = {0:4.2f} deg'.format(azimuth)\n    'azimuth = 45.11 deg'\n\nFunctional Solution:\n    >>> import numpy as np\n    >>> import nvector as nv\n    >>> from nvector import rad, deg\n\n    >>> lat_EA, lon_EA, z_EA = rad(1), rad(2), 3\n    >>> lat_EB, lon_EB, z_EB = rad(4), rad(5), 6\n\nStep1: Convert to n-vectors:\n    >>> n_EA_E = nv.lat_lon2n_E(lat_EA, lon_EA)\n    >>> n_EB_E = nv.lat_lon2n_E(lat_EB, lon_EB)\n\nStep2: Find p_AB_E (delta decomposed in E).WGS-84 ellipsoid is default:\n    >>> p_AB_E = nv.n_EA_E_and_n_EB_E2p_AB_E(n_EA_E, n_EB_E, z_EA, z_EB)\n\nStep3: Find R_EN for position A:\n    >>> R_EN = nv.n_E2R_EN(n_EA_E)\n\nStep4: Find p_AB_N (delta decomposed in N).\n    >>> p_AB_N = np.dot(R_EN.T, p_AB_E).ravel()\n    >>> valtxt = '{0:8.2f}, {1:8.2f}, {2:8.2f}'.format(*p_AB_N)\n    >>> 'Ex1: delta north, east, down = {}'.format(valtxt)\n    'Ex1: delta north, east, down = 331730.23, 332997.87, 17404.27'\n\nStep5: Also find the direction (azimuth) to B, relative to north:\n    >>> azimuth = np.arctan2(p_AB_N[1], p_AB_N[0])\n    >>> 'azimuth = {0:4.2f} deg'.format(deg(azimuth))\n    'azimuth = 45.11 deg'\n\nSee also\n    `Example 1 at www.navlab.net <http://www.navlab.net/nvector/#example_1>`_\n\n\n**Example 2: \"B and delta to C\"**\n---------------------------------\n\n.. image:: http://www.navlab.net/images/ex2img.png\n\nA radar or sonar attached to a vehicle B (Body coordinate frame) measures the\ndistance and direction to an object C. We assume that the distance and two\nangles (typically bearing and elevation relative to B) are already combined to\nthe vector p_BC_B (i.e. the vector from B to C, decomposed in B). The position\nof B is given as n_EB_E and z_EB, and the orientation (attitude) of B is given\nas R_NB (this rotation matrix can be found from roll/pitch/yaw by using zyx2R).\n\nFind the exact position of object C as n-vector and depth ( n_EC_E and z_EC ),\nassuming Earth ellipsoid with semi-major axis a and flattening f. For WGS-72,\nuse a = 6 378 135 m and f = 1/298.26.\n\n\nSolution:\n    >>> import nvector as nv\n    >>> import numpy as np\n    >>> wgs72 = nv.FrameE(name='WGS72')\n    >>> wgs72 = nv.FrameE(a=6378135, f=1.0/298.26)\n\nStep 1: Position and orientation of B is given 400m above E:\n    >>> n_EB_E = wgs72.Nvector(nv.unit([[1], [2], [3]]), z=-400)\n    >>> frame_B = nv.FrameB(n_EB_E, yaw=10, pitch=20, roll=30, degrees=True)\n\nStep 2: Delta BC decomposed in B\n    >>> p_BC_B = frame_B.Pvector(np.r_[3000, 2000, 100].reshape((-1, 1)))\n\nStep 3: Decompose delta BC in E\n    >>> p_BC_E = p_BC_B.to_ecef_vector()\n\nStep 4: Find point C by adding delta BC to EB\n    >>> p_EB_E = n_EB_E.to_ecef_vector()\n    >>> p_EC_E = p_EB_E + p_BC_E\n    >>> pointC = p_EC_E.to_geo_point()\n\n    >>> lat, lon, z = pointC.latlon_deg\n    >>> msg = 'Ex2: PosC: lat, lon = {:4.2f}, {:4.2f} deg,  height = {:4.2f} m'\n    >>> msg.format(lat[0], lon[0], -z[0])\n    'Ex2: PosC: lat, lon = 53.33, 63.47 deg,  height = 406.01 m'\n\nSee also\n    `Example 2 at www.navlab.net <http://www.navlab.net/nvector/#example_2>`_\n\n\n**Example 3: \"ECEF-vector to geodetic latitude\"**\n-------------------------------------------------\n\n.. image:: http://www.navlab.net/images/ex3img.png\n\nPosition B is given as an \"ECEF-vector\" p_EB_E (i.e. a vector from E, the\ncenter of the Earth, to B, decomposed in E).\nFind the geodetic latitude, longitude and height (latEB, lonEB and hEB),\nassuming WGS-84 ellipsoid.\n\n\nSolution:\n    >>> import numpy as np\n    >>> import nvector as nv\n    >>> wgs84 = nv.FrameE(name='WGS84')\n    >>> position_B = 6371e3 * np.vstack((0.9, -1, 1.1))  # m\n    >>> p_EB_E = wgs84.ECEFvector(position_B)\n    >>> pointB = p_EB_E.to_geo_point()\n\n    >>> lat, lon, z = pointB.latlon_deg\n    >>> msg = 'Ex3: Pos B: lat, lon = {:4.2f}, {:4.2f} deg, height = {:9.2f} m'\n    >>> msg.format(lat[0], lon[0], -z[0])\n    'Ex3: Pos B: lat, lon = 39.38, -48.01 deg, height = 4702059.83 m'\n\nSee also\n    `Example 3 at www.navlab.net <http://www.navlab.net/nvector/#example_3>`_\n\n\n**Example 4: \"Geodetic latitude to ECEF-vector\"**\n-------------------------------------------------\n\n.. image:: http://www.navlab.net/images/ex4img.png\n\nGeodetic latitude, longitude and height are given for position B as latEB,\nlonEB and hEB, find the ECEF-vector for this position, p_EB_E.\n\n\nSolution:\n    >>> import nvector as nv\n    >>> wgs84 = nv.FrameE(name='WGS84')\n    >>> pointB = wgs84.GeoPoint(latitude=1, longitude=2, z=-3, degrees=True)\n    >>> p_EB_E = pointB.to_ecef_vector()\n\n    >>> 'Ex4: p_EB_E = {} m'.format(p_EB_E.pvector.ravel().tolist())\n    'Ex4: p_EB_E = [6373290.277218279, 222560.20067473652, 110568.82718178593] m'\n\nSee also\n    `Example 4 at www.navlab.net <http://www.navlab.net/nvector/#example_4>`_\n\n\n**Example 5: \"Surface distance\"**\n---------------------------------\n\n.. image:: http://www.navlab.net/images/ex5img.png\n\nFind the surface distance sAB (i.e. great circle distance) between two\npositions A and B. The heights of A and B are ignored, i.e. if they don't have\nzero height, we seek the distance between the points that are at the surface of\nthe Earth, directly above/below A and B. The Euclidean distance (chord length)\ndAB should also be found. Use Earth radius 6371e3 m.\nCompare the results with exact calculations for the WGS-84 ellipsoid.\n\n\nSolution for a sphere:\n    >>> import numpy as np\n    >>> import nvector as nv\n    >>> frame_E = nv.FrameE(a=6371e3, f=0)\n    >>> positionA = frame_E.GeoPoint(latitude=88, longitude=0, degrees=True)\n    >>> positionB = frame_E.GeoPoint(latitude=89, longitude=-170, degrees=True)\n\n    >>> s_AB, _azia, _azib = positionA.distance_and_azimuth(positionB)\n    >>> p_AB_E = positionB.to_ecef_vector() - positionA.to_ecef_vector()\n    >>> d_AB = p_AB_E.length[0]\n\n    >>> msg = 'Ex5: Great circle and Euclidean distance = {}'\n    >>> msg = msg.format('{:5.2f} km, {:5.2f} km')\n    >>> msg.format(s_AB / 1000, d_AB / 1000)\n    'Ex5: Great circle and Euclidean distance = 332.46 km, 332.42 km'\n\nAlternative sphere solution:\n    >>> path = nv.GeoPath(positionA, positionB)\n    >>> s_AB2 = path.track_distance(method='greatcircle').ravel()\n    >>> d_AB2 = path.track_distance(method='euclidean').ravel()\n    >>> msg.format(s_AB2[0] / 1000, d_AB2[0] / 1000)\n    'Ex5: Great circle and Euclidean distance = 332.46 km, 332.42 km'\n\nExact solution for the WGS84 ellipsoid:\n    >>> wgs84 = nv.FrameE(name='WGS84')\n    >>> point1 = wgs84.GeoPoint(latitude=88, longitude=0, degrees=True)\n    >>> point2 = wgs84.GeoPoint(latitude=89, longitude=-170, degrees=True)\n    >>> s_12, _azi1, _azi2 = point1.distance_and_azimuth(point2)\n\n    >>> p_12_E = point2.to_ecef_vector() - point1.to_ecef_vector()\n    >>> d_12 = p_12_E.length[0]\n    >>> msg = 'Ellipsoidal and Euclidean distance = {:5.2f} km, {:5.2f} km'\n    >>> msg.format(s_12 / 1000, d_12 / 1000)\n    'Ellipsoidal and Euclidean distance = 333.95 km, 333.91 km'\n\nSee also\n    `Example 5 at www.navlab.net <http://www.navlab.net/nvector/#example_5>`_\n\n\n**Example 6 \"Interpolated position\"**\n-------------------------------------\n\n.. image:: http://www.navlab.net/images/ex6img.png\n\nGiven the position of B at time t0 and t1, n_EB_E(t0) and n_EB_E(t1).\n\nFind an interpolated position at time ti, n_EB_E(ti). All positions are given\nas n-vectors.\n\n\nSolution:\n    >>> import nvector as nv\n    >>> wgs84 = nv.FrameE(name='WGS84')\n    >>> n_EB_E_t0 = wgs84.GeoPoint(89, 0, degrees=True).to_nvector()\n    >>> n_EB_E_t1 = wgs84.GeoPoint(89, 180, degrees=True).to_nvector()\n    >>> path = nv.GeoPath(n_EB_E_t0, n_EB_E_t1)\n\n    >>> t0 = 10.\n    >>> t1 = 20.\n    >>> ti = 16.  # time of interpolation\n    >>> ti_n = (ti - t0) / (t1 - t0) # normalized time of interpolation\n\n    >>> g_EB_E_ti = path.interpolate(ti_n).to_geo_point()\n\n    >>> lat_ti, lon_ti, z_ti = g_EB_E_ti.latlon_deg\n    >>> msg = 'Ex6, Interpolated position: lat, lon = {:2.1f} deg, {:2.1f} deg'\n    >>> msg.format(lat_ti[0], lon_ti[0])\n    'Ex6, Interpolated position: lat, lon = 89.8 deg, 180.0 deg'\n\nSee also\n    `Example 6 at www.navlab.net <http://www.navlab.net/nvector/#example_6>`_\n\n\n**Example 7: \"Mean position\"**\n------------------------------\n\n.. image:: http://www.navlab.net/images/ex7img.png\n\nThree positions A, B, and C are given as n-vectors n_EA_E, n_EB_E, and n_EC_E.\nFind the mean position, M, given as n_EM_E.\nNote that the calculation is independent of the depths of the positions.\n\n\nSolution:\n    >>> import nvector as nv\n    >>> points = nv.GeoPoint(latitude=[90, 60, 50],\n    ...                      longitude=[0, 10, -20], degrees=True)\n    >>> nvectors = points.to_nvector()\n    >>> n_EM_E = nvectors.mean()\n    >>> g_EM_E = n_EM_E.to_geo_point()\n    >>> lat, lon = g_EM_E.latitude_deg, g_EM_E.longitude_deg\n    >>> msg = 'Ex7: Pos M: lat, lon = {:4.2f}, {:4.2f} deg'\n    >>> msg.format(lat[0], lon[0])\n    'Ex7: Pos M: lat, lon = 67.24, -6.92 deg'\n\nSee also\n    `Example 7 at www.navlab.net <http://www.navlab.net/nvector/#example_7>`_\n\n\n**Example 8: \"A and azimuth/distance to B\"**\n--------------------------------------------\n\n.. image:: http://www.navlab.net/images/ex8img.png\n\nWe have an initial position A, direction of travel given as an azimuth\n(bearing) relative to north (clockwise), and finally the\ndistance to travel along a great circle given as sAB.\nUse Earth radius 6371e3 m to find the destination point B.\n\nIn geodesy this is known as \"The first geodetic problem\" or\n\"The direct geodetic problem\" for a sphere, and we see that this is similar to\n`Example 2 <http://www.navlab.net/nvector/#example_2>`_, but now the delta is\ngiven as an azimuth and a great circle distance. (\"The second/inverse geodetic\nproblem\" for a sphere is already solved in Examples\n`1 <http://www.navlab.net/nvector/#example_1>`_ and\n`5 <http://www.navlab.net/nvector/#example_5>`_.)\n\n\nSolution:\n    >>> import nvector as nv\n    >>> frame = nv.FrameE(a=6371e3, f=0)\n    >>> pointA = frame.GeoPoint(latitude=80, longitude=-90, degrees=True)\n    >>> pointB, _azimuthb = pointA.displace(distance=1000, azimuth=200,\n    ...                                     degrees=True)\n    >>> lat, lon = pointB.latitude_deg, pointB.longitude_deg\n\n    >>> msg = 'Ex8, Destination: lat, lon = {:4.2f} deg, {:4.2f} deg'\n    >>> msg.format(lat, lon)\n    'Ex8, Destination: lat, lon = 79.99 deg, -90.02 deg'\n\nSee also\n    `Example 8 at www.navlab.net <http://www.navlab.net/nvector/#example_8>`_\n\n\n**Example 9: \"Intersection of two paths\"**\n------------------------------------------\n\n.. image:: http://www.navlab.net/images/ex9img.png\n\nDefine a path from two given positions (at the surface of a spherical Earth),\nas the great circle that goes through the two points.\n\nPath A is given by A1 and A2, while path B is given by B1 and B2.\n\nFind the position C where the two great circles intersect.\n\n\nSolution:\n    >>> import nvector as nv\n    >>> pointA1 = nv.GeoPoint(10, 20, degrees=True)\n    >>> pointA2 = nv.GeoPoint(30, 40, degrees=True)\n    >>> pointB1 = nv.GeoPoint(50, 60, degrees=True)\n    >>> pointB2 = nv.GeoPoint(70, 80, degrees=True)\n    >>> pathA = nv.GeoPath(pointA1, pointA2)\n    >>> pathB = nv.GeoPath(pointB1, pointB2)\n\n    >>> pointC = pathA.intersect(pathB)\n    >>> np.allclose(pathA.on_path(pointC), pathB.on_path(pointC))\n    True\n    >>> np.allclose(pathA.on_great_circle(pointC),\n    ...             pathB.on_great_circle(pointC))\n    True\n    >>> pointC = pointC.to_geo_point()\n    >>> lat, lon = pointC.latitude_deg, pointC.longitude_deg\n    >>> msg = 'Ex9, Intersection: lat, lon = {:4.2f}, {:4.2f} deg'\n    >>> msg.format(lat[0], lon[0])\n    'Ex9, Intersection: lat, lon = 40.32, 55.90 deg'\n\nSee also\n    `Example 9 at www.navlab.net <http://www.navlab.net/nvector/#example_9>`_\n\n\n**Example 10: \"Cross track distance\"**\n--------------------------------------\n\n.. image:: https://raw.githubusercontent.com/pbrod/Nvector/master/ex10img.png\n\nPath A is given by the two positions A1 and A2 (similar to the previous\nexample).\n\nFind the cross track distance sxt between the path A (i.e. the great circle\nthrough A1 and A2) and the position B (i.e. the shortest distance at the\nsurface, between the great circle and B).\n\nAlso find the Euclidean distance dxt between B and the plane defined by the\ngreat circle. Use Earth radius 6371e3.\n\nFinally, find the intersection point on the great circle and determine if it is\nbetween position A1 and A2.\n\n\nSolution:\n    >>> import nvector as nv\n    >>> frame = nv.FrameE(a=6371e3, f=0)\n    >>> pointA1 = frame.GeoPoint(0, 0, degrees=True)\n    >>> pointA2 = frame.GeoPoint(10, 0, degrees=True)\n    >>> pointB = frame.GeoPoint(1, 0.1, degrees=True)\n    >>> pathA = nv.GeoPath(pointA1, pointA2)\n\n    >>> s_xt = pathA.cross_track_distance(pointB, method='greatcircle').ravel()\n    >>> d_xt = pathA.cross_track_distance(pointB, method='euclidean').ravel()\n\n    >>> val_txt = '{:4.2f} km, {:4.2f} km'.format(s_xt[0]/1000, d_xt[0]/1000)\n    >>> 'Ex10: Cross track distance: s_xt, d_xt = {}'.format(val_txt)\n    'Ex10: Cross track distance: s_xt, d_xt = 11.12 km, 11.12 km'\n\n    >>> pointC = pathA.closest_point_on_great_circle(pointB)\n    >>> np.allclose(pathA.on_path(pointC), True)\n    True\n\nSee also\n    `Example 10 at www.navlab.net <http://www.navlab.net/nvector/#example_10>`_\n\n\n\nSee also\n========\n`geographiclib <https://pypi.python.org/pypi/geographiclib>`_\n\n.. |nvector_img| image:: https://badge.fury.io/py/nvector.png\n   :target: https://pypi.python.org/pypi/nvector/\n.. |tests_img| image:: https://travis-ci.org/pbrod/Nvector.svg?branch=master\n   :target: https://travis-ci.org/pbrod/Nvector\n.. |docs_img| image:: https://readthedocs.org/projects/pip/badge/?version=stable\n   :target: http://Nvector.readthedocs.org/en/stable/\n.. |health_img| image:: https://api.codeclimate.com/v1/badges/c04214bef610b25906fe/maintainability\n   :target: https://codeclimate.com/github/pbrod/Nvector/maintainability\n   :alt: Maintainability\n.. |coverage_img| image:: https://codecov.io/gh/pbrod/nvector/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/pbrod/nvector\n.. |versions_img| image:: https://img.shields.io/pypi/pyversions/Nvector.svg\n   :target: https://github.com/pbrod/nvector\n.. |downloads_img| image:: https://img.shields.io/pypi/dm/nvector.svg\n   :alt: PyPI - Downloads\n\n=========\nChangelog\n=========\n\nVersion 0.7.4, June 4, 2019\n============================\nPer A Brodtkorb (2):\n      * Fixed PyPi badge and added downloads badge in nvector/_info.py and README.rst\n      * Removed obsolete and wrong badges from docs/index.rst\n\nVersion 0.7.3, June 4, 2019\n============================\nPer A Brodtkorb (6):\n      * Renamed LICENSE.txt and THANKS.txt to LICENSE.rst and THANKS.rst\n      * Updated README.rst and nvector/_info.py\n      * Fixed issue 7# incorrect test for test_n_E_and_wa2R_EL.\n      * Removed coveralls test coverage report.\n      * Replaced coverage badge from coveralls to codecov.\n      * Updated code-climate reporter.\n      * Simplified duplicated code in nvector._core.\n      * Added tests/__init__.py\n      * Added \"--pyargs nvector\" to pytest options in setup.cfg\n      * Exclude build_package.py from distribution in MANIFEST.in\n      * Replaced healt_img from landscape to codeclimate.\n      * Updated travis to explicitly install pytest-cov and pytest-pep8\n      * Removed dependence on pyscaffold\n      * Added MANIFEST.in\n      * Renamed set_package_version.py to build_package.py\n\n\nVersion 0.7.0, June 2, 2019\n============================\n\nGary van der Merwe (1):\n      * Add interpolate to __all__ so that it can be imported\n\nPer A Brodtkorb (26):\n      * Updated long_description in setup.cfg\n      * Replaced deprecated sphinx.ext.pngmath with sphinx.ext.imgmath\n      * Added imgmath to requirements for building the docs.\n      * Fixing shallow clone warning. Replaced property\n         'sonar.python.coverage.itReportPath' with\n         'sonar.python.coverage.reportPaths' instead, because it is has been\n         removed.\n      * Drop python 3.4 support\n      * Added python 3.7 support\n      * Fixed a bug: Mixed scalars and np.array([1]) values don't work with\n         np.rad2deg function.\n      * Added ETRS ELLIPSOID in _core.py Added ED50 as alias for International\n         (Hayford)/European Datum in _core.py Added sad69 as alias for South\n         American 1969 in _core.py\n      * Simplified docstring for nv.test\n      * Generalized the setup.py.\n      * Replaced aliases with the correct names in setup.cfg.\n\n\nVersion 0.6.0, December 9, 2018\n================================\nPer A Brodtkorb (79):\n      * Updated requirements in setup.py\n      * Removed tox.ini\n      * Updated documentation on how to set package version\n      * Made a separate script to set package version in nvector/__init__.py\n      * Updated docstring for select_ellipsoid\n      * Replace GeoPoint.geo_point with GeoPoint.displace and removed deprecated GeoPoint.geo_point\n      * Update .travis.yml\n      * Fix so that codeclimate is able to parse .travis.yml\n      * Only run sonar and codeclimate reporter for python v3.6\n      * Added sonar-project.properties\n      * Pinned coverage to v4.3.4 due to fact that codeclimate reporter is only\n         compatible with Coverage.py versions >=4.0,<4.4.\n      * Updated with sonar scanner.\n      * Added .pylintrc\n      * Set up codeclimate reporter\n      * Updated docstring for unit function.\n      * Avoid division by zero in unit function.\n      * Reenabled the doctest of plot_mean_position\n      * Reset \"pyscaffold==2.5.11\"\n      * Replaced deprecated basemap with cartopy.\n      * Replaced doctest of plot_mean_position with test_plot_mean_position in\n         test_plot.py\n      * Fixed failing doctests for python v3.4 and v3.5 and made them more\n         robust.\n      * Fixed failing doctests and made them more robust.\n      * Increased pycoverage version to use.\n      * moved nvector to src/nvector/\n      * Reset the setup.py to require 'pyscaffold==2.5.11' which works on\n         python version 3.4, 3.5 and 3.6. as well as 2.7\n      * Updated unittests.\n      * Updated tests.\n      * Removed obsolete code\n      * Added test for delta_L\n      * Added corner testcase for\n         pointA.displace(distance=1000,azimuth=np.deg2rad(200))\n      * Added test for path.track_distance(method='exact')\n      * Added delta_L a function thet teturn cartesian delta vector from\n         positions A to B decomposed in L.\n      * Simplified OO-solution in example 1 by using delta_N function\n      * Refactored duplicated code\n      * Vectorized code so that the frames can take more than one position at\n         the time.\n      * Keeping only the html docs in the distribution.\n      * replaced link from latest to stable docs on readthedocs and updated\n         crosstrack distance test.\n      * updated documentation in setup.py\n\nVersion 0.5.2, March 7, 2017\n============================\n\n\nPer A Brodtkorb (10):\n      * Fixed tests in tests/test_frames.py\n      * Updated to setup.cfg and tox.ini + pep8\n      * updated .travis.yml\n      * Updated Readme.rst with new example 10 picture and link to nvector docs at readthedocs.\n      * updated official documentation links\n      * Updated crosstrack distance tests.\n\n\nVersion 0.5.1, March 5, 2017\n============================\n\n\nCody (4):\n     * Explicitely numbered replacement fields\n     * Migrated `%` string formating\n\nPer A Brodtkorb (29):\n     * pep8\n     * Updated failing examples\n     * Updated README.rst\n     * Removed obsolete pass statement\n     * Documented functions\n     * added .checkignore for quantifycode\n     * moved test_docstrings and use_docstring_from into _common.py\n     * Added .codeclimate.yml\n     * Updated installation information in _info.py\n     * Added GeoPath.on_path method. Clearified intersection example\n     * Added great_circle_normal, cross_track_distance Renamed intersection to intersect (Intersection is deprecated.)\n     * Simplified R2zyx with a call to R2xyz Improved accuracy for great circle cross track distance for small distances.\n     * Added on_great_circle, _on_great_circle_path, _on_ellipsoid_path, closest_point_on_great_circle and closest_point_on_path to GeoPath\n     * made __eq__ more robust for frames\n     * Removed duplicated code\n     * Updated tests\n     * Removed fishy test\n     * replaced zero n-vector with nan\n     * Commented out failing test.\n     * Added example 10 image\n     * Added 'closest_point_on_great_circle', 'on_great_circle','on_great_circle_path'.\n     * Updated examples + documentation\n     * Updated index depth\n     * Updated README.rst and classifier in setup.cfg\n\n\n\nVersion 0.4.1, January 19, 2016\n===============================\n\npbrod (46):\n\n      * Cosmetic updates\n      * Updated README.rst\n      * updated docs and removed unused code\n      * updated README.rst and .coveragerc\n      * Refactored out _check_frames\n      * Refactored out _default_frame\n      * Updated .coveragerc\n      * Added link to geographiclib\n      * Updated external link\n      * Updated documentation\n      * Added figures to examples\n      * Added GeoPath.interpolate + interpolation example 6\n      * Added links to FFI homepage.\n      * Updated documentation:\n          - Added link to nvector toolbox for matlab\n          - For each example added links to the more detailed explanation on the homepage\n      * Updated link to nvector toolbox for matlab\n      * Added link to nvector on  pypi\n      * Updated documentation fro FrameB, FrameE, FrameL and FrameN.\n      * updated __all__ variable\n      * Added missing R_Ee to function n_EA_E_and_n_EB_E2azimuth + updated documentation\n      * Updated CHANGES.rst\n      * Updated conf.py\n      * Renamed info.py to _info.py\n      * All examples are now generated from _examples.py.\n\n\nVersion 0.1.3, January 1, 2016\n==============================\n\npbrod (31):\n\n      * Refactored\n      * Updated tests\n      * Updated docs\n      * Moved tests to nvector/tests\n      * Updated .coverage     Added travis.yml, .landscape.yml\n      * Deleted obsolete LICENSE\n      * Updated README.rst\n      * Removed ngs version\n      * Fixed bug in .travis.yml\n      * Updated .travis.yml\n      * Removed dependence on navigator.py\n      * Updated README.rst\n      * Updated examples\n      * Deleted skeleton.py and added tox.ini\n      * Small refactoring     Renamed distance_rad_bearing_rad2point to n_EA_E_distance_and_azimuth2n_EB_E     updated tests\n      * Renamed azimuth to n_EA_E_and_n_EB_E2azimuth     Added tests for R2xyz as well as R2zyx\n      * Removed backward compatibility     Added test_n_E_and_wa2R_EL\n      * Refactored tests\n      * Commented out failing tests on python 3+\n      * updated CHANGES.rst\n      * Removed bug in setup.py\n\n\nVersion 0.1.1, January 1, 2016\n==============================\n\npbrod (31):\n      * Initial commit: Translated code from Matlab to Python.\n      * Added object oriented interface to nvector library\n      * Added tests for object oriented interface\n      * Added geodesic tests.\n\n=======\nLicense\n=======\n\nThe content of this library is based on the following publication:\n\nGade, K. (2010). A Nonsingular Horizontal Position Representation, The Journal\nof Navigation, Volume 63, Issue 03, pp 395-417, July 2010.\n(www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf)\n\nThis paper should be cited in publications using this library.\n\nCopyright (c) 2015, Norwegian Defence Research Establishment (FFI)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above publication\ninformation, copyright notice, this list of conditions and the following\ndisclaimer.\n\n2. Redistributions in binary form must reproduce the above publication\ninformation, copyright notice, this list of conditions and the following\ndisclaimer in the documentation and/or other materials provided with the\ndistribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS\nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\nTHE POSSIBILITY OF SUCH DAMAGE.\n\n\n============\nContributers\n============\n\n* Kenneth Gade, FFI: Main author of Matlab toolbox nvector.\n* Kristian Svartveit, FFI: Contributions to matlab code: R_Ee.m and unit.m.\n* Brita Hafskjold Gade, FFI: Contributions to matlab code: n_EB_E2p_EB_E.m, p_EB_E2n_EB_E.m\n* Per A Brodtkorb, FFI: Translation of nvector from matlab to Python.\n\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pbrod/nvector/", "keywords": "", "license": "Simplified BSD", "maintainer": "", "maintainer_email": "", "name": "nvector", "package_url": "https://pypi.org/project/nvector/", "platform": "any", "project_url": "https://pypi.org/project/nvector/", "project_urls": {"Homepage": "https://github.com/pbrod/nvector/"}, "release_url": "https://pypi.org/project/nvector/0.7.4/", "requires_dist": ["sphinx (>=1.3.1) ; extra == 'build_sphinx'"], "requires_python": "", "summary": "Solves all kinds of geographical position calculations.", "version": "0.7.4"}, "last_serial": 5356816, "releases": {"0.1.3": [{"comment_text": "", "digests": {"md5": "af284c448a72dc9660b7d05f7e191a27", "sha256": "b8a10f5a8a1f5a2182425df27edb42130be2b86219c74d6d86b61fda9722c6c4"}, "downloads": -1, "filename": "nvector-0.1.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "af284c448a72dc9660b7d05f7e191a27", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 1818962, "upload_time": "2016-01-01T19:01:57", "upload_time_iso_8601": "2016-01-01T19:01:57.550211Z", "url": "https://files.pythonhosted.org/packages/90/da/cb328d2ef52e4c7a889c7d8b15c9b0f3ba2593770e707e85108bc7584aa2/nvector-0.1.3-py2.py3-none-any.whl"}], "0.4.1": [{"comment_text": "", "digests": {"md5": "2ee662fd827c6c9bb253262ab44f3f49", "sha256": "8e267fbc38d780a94315d12070ce07178573bff4b2d8538369338343a2899469"}, "downloads": -1, "filename": "nvector-0.4.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2ee662fd827c6c9bb253262ab44f3f49", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 2325166, "upload_time": "2016-01-19T02:07:23", "upload_time_iso_8601": "2016-01-19T02:07:23.683032Z", "url": "https://files.pythonhosted.org/packages/93/b6/171087248d82f8202d2c05e7ed518adc13cbd4889417b896621ae25b9340/nvector-0.4.1-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "83782e7361cb11e3089fceceed5db105", "sha256": "80ac5b1ab4d319180f0e6eff7a27a65a5c1eb6d9aa9f9225e0fd5ed156f89cf4"}, "downloads": -1, "filename": "nvector-0.4.1.zip", "has_sig": false, "md5_digest": "83782e7361cb11e3089fceceed5db105", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 73487, "upload_time": "2016-01-19T02:07:35", "upload_time_iso_8601": "2016-01-19T02:07:35.020217Z", "url": "https://files.pythonhosted.org/packages/5c/c2/5f015fc30693559f74449d2120e08f884a2fa28da103035be3d89d217b51/nvector-0.4.1.zip"}], "0.5.2": [{"comment_text": "", "digests": {"md5": "9b833873cbd05ef1ec8d4c82fddff50a", "sha256": "f3877e3b5c1f498095a8ed05427b462d7d1e2bc21220f3cc4c5543bb24dbd33c"}, "downloads": -1, "filename": "nvector-0.5.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9b833873cbd05ef1ec8d4c82fddff50a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 2919983, "upload_time": "2017-03-07T13:16:05", "upload_time_iso_8601": "2017-03-07T13:16:05.350008Z", "url": "https://files.pythonhosted.org/packages/9a/57/3b3b74377764f5d20b031788cb204a0b550c886f079aa54a6a3aec4f59fd/nvector-0.5.2-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "0ac0d87333967f9b2329a7f76c5b3e76", "sha256": "0995540e319caaceb20d75ed57d8cf043eabd90caaf0322bb35f8e2baeeed567"}, "downloads": -1, "filename": "nvector-0.5.2.tar.gz", "has_sig": false, "md5_digest": "0ac0d87333967f9b2329a7f76c5b3e76", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 70209, "upload_time": "2017-03-07T13:16:10", "upload_time_iso_8601": "2017-03-07T13:16:10.039441Z", "url": "https://files.pythonhosted.org/packages/10/90/d12e55ad007bd14997473c62f0b0b447b3208a3625f2afcf0bcccb1c88f6/nvector-0.5.2.tar.gz"}], "0.6.0": [{"comment_text": "", "digests": {"md5": "d69a25092e43609a685743181f3c9267", "sha256": "a0645e2dcb453a3666d2ae612f02b80bf32dddc4a8aef125b205a5fc267cd9de"}, "downloads": -1, "filename": "nvector-0.6.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d69a25092e43609a685743181f3c9267", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 103398, "upload_time": "2018-12-09T00:26:15", "upload_time_iso_8601": "2018-12-09T00:26:15.568546Z", "url": "https://files.pythonhosted.org/packages/4f/f0/dc186a3afcfd5f9d7143f123c0136b66dbd493f6b9d4756c6ea63fd6e0ab/nvector-0.6.0-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "b7060c11f0d0d030bade7ff455ffdfca", "sha256": "b08da9efe982957da1dc6371376cfd1cb528a23474465fb740482075dd1072b0"}, "downloads": -1, "filename": "nvector-0.6.0.tar.gz", "has_sig": false, "md5_digest": "b7060c11f0d0d030bade7ff455ffdfca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 89608, "upload_time": "2018-12-09T00:26:18", "upload_time_iso_8601": "2018-12-09T00:26:18.107058Z", "url": "https://files.pythonhosted.org/packages/e1/ee/f8a51d7a8c41e9de64f4492b2e35c47b7f492c2b010316a86c4376f16a7b/nvector-0.6.0.tar.gz"}], "0.7.0": [{"comment_text": "", "digests": {"md5": "5c061ffd16094199eda030bd67ecd73f", "sha256": "7fa4cece7d35ab3e1a6f73b6d4e2dab0d234f9b07dc22676471aa3f4aba5c150"}, "downloads": -1, "filename": "nvector-0.7.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5c061ffd16094199eda030bd67ecd73f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 61893, "upload_time": "2019-06-03T15:15:26", "upload_time_iso_8601": "2019-06-03T15:15:26.886007Z", "url": "https://files.pythonhosted.org/packages/d4/70/d018ee8377675d9a0e7d861a966c2168fefa83516c99935ba1e639959438/nvector-0.7.0-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "78f6306bb0c933a3e15e15f1a538196a", "sha256": "e7a91f815dcb6170212f052a841c87f0d1e4654cd83d7faa518579fb55eef9bc"}, "downloads": -1, "filename": "nvector-0.7.0.tar.gz", "has_sig": false, "md5_digest": "78f6306bb0c933a3e15e15f1a538196a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3049297, "upload_time": "2019-06-03T15:15:52", "upload_time_iso_8601": "2019-06-03T15:15:52.250022Z", "url": "https://files.pythonhosted.org/packages/b0/49/db394e1e35031f5142feda9260730d33b990862b667d0a98643f046cffa8/nvector-0.7.0.tar.gz"}], "0.7.3": [{"comment_text": "", "digests": {"md5": "f97f5716553bfe736416884847673252", "sha256": "70d998fcfba9b6608ff45e341ace5f81feb832c6bd6ac9d21cc451fbf4f6bdfe"}, "downloads": -1, "filename": "nvector-0.7.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f97f5716553bfe736416884847673252", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 62319, "upload_time": "2019-06-04T08:27:25", "upload_time_iso_8601": "2019-06-04T08:27:25.393234Z", "url": "https://files.pythonhosted.org/packages/c7/a5/021009eb122a3fc4e1cc33f2f6d43cefe8fefd615505e9104fb01173f762/nvector-0.7.3-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "50ec72bec613e09aa2375b4418242371", "sha256": "bd42ab7f0a88a463568c1e9e6aa89a71e35ba55b0f0d30f8cd44960ab51af7aa"}, "downloads": -1, "filename": "nvector-0.7.3.tar.gz", "has_sig": false, "md5_digest": "50ec72bec613e09aa2375b4418242371", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3051271, "upload_time": "2019-06-04T08:27:53", "upload_time_iso_8601": "2019-06-04T08:27:53.051105Z", "url": "https://files.pythonhosted.org/packages/d0/15/5b8bae9c4844c989c6f9ce43d5c033a16041c8d174874fa9ac80fccd83fd/nvector-0.7.3.tar.gz"}], "0.7.4": [{"comment_text": "", "digests": {"md5": "2c1328fe4d97ded4100f847ff11f2d56", "sha256": "48f560721e96d5050c55b876162608f369c755a8f178f12bd25729fcdd97c66a"}, "downloads": -1, "filename": "nvector-0.7.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2c1328fe4d97ded4100f847ff11f2d56", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 62389, "upload_time": "2019-06-04T09:37:21", "upload_time_iso_8601": "2019-06-04T09:37:21.208094Z", "url": "https://files.pythonhosted.org/packages/f3/09/9921b26126b7547589745c0b785bb95802b97b33f060cb5d776b1bbc75f2/nvector-0.7.4-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "caa998827a23dc111376b70688f8192a", "sha256": "359867a0f61821eb9b1bf286f71918003455b478e53d4cb455636ad499ec0887"}, "downloads": -1, "filename": "nvector-0.7.4.tar.gz", "has_sig": false, "md5_digest": "caa998827a23dc111376b70688f8192a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3050783, "upload_time": "2019-06-04T09:37:47", "upload_time_iso_8601": "2019-06-04T09:37:47.379169Z", "url": "https://files.pythonhosted.org/packages/9d/74/0c430545dca37a07fd8348e2afec7decb3cee9a9e64fe55013341cbd65d8/nvector-0.7.4.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "2c1328fe4d97ded4100f847ff11f2d56", "sha256": "48f560721e96d5050c55b876162608f369c755a8f178f12bd25729fcdd97c66a"}, "downloads": -1, "filename": "nvector-0.7.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2c1328fe4d97ded4100f847ff11f2d56", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 62389, "upload_time": "2019-06-04T09:37:21", "upload_time_iso_8601": "2019-06-04T09:37:21.208094Z", "url": "https://files.pythonhosted.org/packages/f3/09/9921b26126b7547589745c0b785bb95802b97b33f060cb5d776b1bbc75f2/nvector-0.7.4-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "caa998827a23dc111376b70688f8192a", "sha256": "359867a0f61821eb9b1bf286f71918003455b478e53d4cb455636ad499ec0887"}, "downloads": -1, "filename": "nvector-0.7.4.tar.gz", "has_sig": false, "md5_digest": "caa998827a23dc111376b70688f8192a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3050783, "upload_time": "2019-06-04T09:37:47", "upload_time_iso_8601": "2019-06-04T09:37:47.379169Z", "url": "https://files.pythonhosted.org/packages/9d/74/0c430545dca37a07fd8348e2afec7decb3cee9a9e64fe55013341cbd65d8/nvector-0.7.4.tar.gz"}]}
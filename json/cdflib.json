{"info": {"author": "MAVEN SDC", "author_email": "mavensdc@lasp.colorado.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "Intended Audience :: Science/Research", "Operating System :: OS Independent", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Utilities"], "description": "[![image](https://travis-ci.com/MAVENSDC/cdflib.svg?branch=master)](https://travis-ci.com/MAVENSDC/cdflib)\n[![image](https://coveralls.io/repos/github/MAVENSDC/cdflib/badge.svg?branch=master)](https://coveralls.io/github/MAVENSDC/cdflib?branch=master)\n[![Actions Status](https://github.com/MAVENSDC/cdflib/workflows/ci/badge.svg)](https://github.com/MAVENSDC/cdflib/actions)\n[![DOI](https://zenodo.org/badge/102912691.svg)](https://zenodo.org/badge/latestdoi/102912691)\n[![Documentation Status](https://readthedocs.org/projects/cdflib/badge/?version=latest)](https://cdflib.readthedocs.io/en/latest/?badge=latest)\n\n# CDFlib\n\n`cdflib` is a python module to read/write CDF (Common Data Format `.cdf`) files without needing to install the\n[CDF NASA library](https://cdf.gsfc.nasa.gov/).\n\nPython &ge; 3.5 is required.\nThis module uses only Numpy, no complicated prereqs.\n\n## Install\n\nTo install, open up your terminal/command prompt, and type:\n```sh\npip install cdflib\n```\nThere are two different CDF classes: a cdf reader, and a cdf writer.\n\nCurrently, you cannot simultaneously read and write to the same file.\nFuture implementations, however, will unify these two classes.\n\n## CDF Reader Class\n\nTo begin accessing the data within a CDF file, first create a new CDF class.\nThis can be done with the following commands\n\n```python\nimport cdflib\n\ncdf_file = cdflib.CDF('/path/to/cdf_file.cdf')\n```\n\nThen, you can call various functions on the variable.\nFor example:\n\n```python\nx = cdf_file.varget(\"NameOfVariable\", startrec = 0, endrec = 150)\n```\n\nThis command will return all data inside of the variable `Variable1`, from records 0 to 150.\nBelow is a list of the 8 different functions you can call.\n\n### cdf_info()\n\nReturns a dictionary that shows the basic CDF information.\nThis information includes\n\n* `CDF` the name of the CDF\n* `Version` the version of the CDF\n* `Encoding` the endianness of the CDF\n* `Majority` the row/column majority\n* `zVariables` the dictionary for zVariable numbers and theircorresponding names\n* `rVariables` the dictionary for rVariable numbers and their corresponding names\n* `Attributes` the dictionary for attribute numbers and their corresponding names and scopes\n* `Checksum` the checksum indicator\n* `Num_rdim` the number of dimensions, applicable only to rVariables\n* `rDim_sizes` the dimensional sizes, applicable only to rVariables\n* `Compressed` CDF is compressed at the file-level\n* `LeapSecondUpdated` The last updated for the leap second table, if applicable\n\n### varinq(variable)\n\nReturns a dictionary that shows the basic variable information.\nThis information includes\n\n* `Variable` the name of the variable\n* `Num` the variable number\n* `Var_Type` the variable type: zVariable or rVariable\n* `Data_Type` the variable's CDF data type\n* `Num_Elements']| the number of elements of the variable\n* `Num_Dims` the dimensionality of the variable record\n* `Dim_Sizes` the shape of the variable record\n* `Sparse` the variable's record sparseness\n* `Last_Rec` the maximum written record number (0-based)\n* `Dim_Vary` the dimensional variance(s)\n* `Rec_Vary` the record variance\n* `Pad` the padded value if set\n* `Compress` the GZIP compression level, 0 to 9.  0 if not compressed\n* `Block_Factor']| the blocking factor if the variable is compressed\n\n### attinq( attribute = None)\n\nReturns a python dictionary of attribute information.\nIf no attribute is\nprovided, a list of all attributes is printed.\n\n### attget( attribute = None, entry = None )\n\nReturns the value of the attribute at the entry number provided. A\nvariable name can be used instead of its corresponding entry number. A\ndictionary is returned with the following defined keys\n\n* `Item_Size` the number of bytes for each entry value\n* `Num_Items` total number of values extracted\n* `Data_Type` the CDF data type\n* `Data` retrieved attribute data as a scalar value, a numpy array or a string\n\n### varattsget(variable = None, expand = False)\n\nGets all variable attributes.\nUnlike attget, which returns a single attribute entry value, this function returns all of the variable attribute entries, in a `dict()`.\nIf there is no entry found, `None` is returned. If\nno variable name is provided, a list of variables are printed. If expand\nis entered with non-False, then each entry's data type is also returned\nin a list form as `[entry, 'CDF_xxxx']`. For attributes without any\nentries, they will also return with None value.\n\n### globalattsget(expand = False)\n\nGets all global attributes. This function returns all of the global\nattribute entries, in a dictionary (in the form of 'attribute':\n{entry: value} pair) from a CDF. If there is no entry found, None is\nreturned. If expand is entered with non-False, then each entry's data\ntype is also returned in a list form as `[entry, 'CDF_xxxx']`.\nFor attributes without any entries, they will also return with None value.\n\n### varget()\n\n```python\nvarget( variable = None, [epoch=None], [[starttime=None, endtime=None] | [startrec=0, endrec = None]], [,expand=True])\n```\n\nReturns the variable data. Variable can be entered either\na name or a variable number. By default, it returns a `numpy.ndarray`\nor `list()` class object, depending on the data type, with the variable\ndata and its specification.\n\nIf `expand=True`, a dictionary is returned with the\nfollowing defined keys for the output\n\n* `Rec_Ndim` the dimension number of each variable record\n* `Rec_Shape` the shape of the variable record dimensions\n* `Num_Records` the total number of records\n* `Records_Returned` the number of records retrieved\n* `Data_Type` the CDF data type\n* `Data` retrieved variable data\n* `Real_Records` Record numbers for real data for sparse record variable in list\n\nBy default, the full variable data is returned. To acquire only a\nportion of the data for a record-varying variable, either the time or\nrecord (0-based) range can be specified. 'epoch' can be used to\nspecify which time variable this variable depends on and is to be\nsearched for the time range. For the ISTP-compliant CDFs, the time\nvariable will come from the attribute 'DEPEND_0' from this variable.\nThe function will automatically search for it thus no need to specify\n'epoch'. If either the start or end time is not specified, the\npossible minimum or maximum value for the specific epoch data type is\nassumed. If either the start or end record is not specified, the range\nstarts at 0 or/and ends at the last of the written data.\n\nThe start (and end) time should be presented in a list as:\n\n* [year month day hour minute second millisec] for CDF_EPOCH\n* [year month day hour minute second millisec microsec nanosec picosec] for CDF_EPOCH16\n* [year month day hour minute second millisec microsec nanosec] for CDF_TIME_TT2000\n\nIf not enough time components are presented, only the last item can have the floating portion for the sub-time components.\n\nNote: CDF's CDF_EPOCH16 data type uses 2 8-byte doubles for each data value.\nIn Python, each value is presented as a complex or\nnumpy.complex128.\n\n### epochrange\n\n```python\nepochrange( epoch, [starttime=None, endtime=None])\n```\n\nGet epoch range.\nReturns `list()` of the record numbers, representing the corresponding starting and ending records within the time range from the epoch data.\n`None` is returned if there is no data either written or found in the time range.\n\n### getVersion ()\n\nShows the code version.\n\n```python\nimport cdflib\n\nswea_cdf_file = cdflib.CDF('/path/to/swea_file.cdf') swea_cdf_file.cdf_info()\n\nx = swea_cdf_file.varget('NameOfVariable') swea_cdf_file.close()\n```\n\n## CDF Writer Class\n\n### CDF (path, cdf_spec=None, delete=False)\n\nCreates an empty CDF file. path is the path name of the CDF (with or\nwithout .cdf extension).\n`cdf_spec` is the optional specification of the\nCDF file, in the form of a dictionary. The dictionary can have the\nfollowing values:\n\n* `Majority` 'row_major' or 'column_major', or its corresponding value. Default is 'column_major'.\n* `Encoding` Data encoding scheme. See the CDF documentation about the valid values. Can be in string or its numeric corresponding value. Default is 'host'.\n* `Checksum` Whether to set the data validation upon file creation. The default is False.\n* `rDim_sizes` The dimensional sizes, applicable only to rVariables.\n* `Compressed` Whether to compress the CDF at the file level. A value of 0-9 or True/False, the default is 0/False.\n\n### write_globalattrs (globalAttrs)\n\nWrites the global attributes. **globalAttrs** is a dictionary that has\nglobal attribute name(s) and their value(s) pair(s). The value(s) is a\ndictionary of entry number and value pair(s). For example:\n\n```python\nglobalAttrs={}\nglobalAttrs['Global1']={0: 'Global Value 1'}\nglobalAttrs['Global2']={0: 'Global Value 2'}\n```\n\nFor a non-string value, use a list with the value and its CDF data type.\nFor example:\n\n```python\nglobalAttrs['Global3']={0: [12, 'cdf_int4']}\nglobalAttrs['Global4']={0: [12.34, 'cdf_double']}\n```\n\nIf the data type is not provided, a corresponding CDF data type is\nassumed:\n\n```python\nglobalAttrs['Global3']={0: 12}     as 'cdf_int4'\nglobalAttrs['Global4']={0: 12.34}  as 'cdf_double'\n```\n\nCDF allows multi-values for non-string data for an attribute:\n\n```python\nglobalAttrs['Global5']={0: [[12.34,21.43], 'cdf_double']}\n```\n\nFor multi-entries from a global variable, they should be presented in\nthis form:\n\n```python\nGA6={}\nGA6[0]='abcd'\nGA6[1]=[12, 'cdf_int2']\nGA6[2]=[12.5, 'cdf_float']\nGA6[3]=[[0,1,2], 'cdf_int8']\nglobalAttrs['Global6']=GA6\n....\nf.write_globalattrs(globalAttrs)\n```\n\n### write_variableattrs (variableAttrs)\n\nWrites a variable's attributes, provided the variable already exists.\n**variableAttrs** is a dictionary that has variable attribute name and\nits entry value pair(s). The entry value is also a dictionary of\nvariable id and value pair(s). Variable id can be the variable name or\nits id number in the file. Use write_var function if the variable does\nnot exist.\nFor example:\n\n```python\nvariableAttrs={}\nentries_1={}\n\nentries_1['var_name_1'] = 'abcd'\nentries_1['var_name_2'] = [12, 'cdf_int4']\n....\nvariableAttrs['attr_name_1'] = entries_1\n\nentries_2={}\nentries_2['var_name_1'] = 'xyz'\nentries_2['var_name_2'] = [[12, 34], 'cdf_int4']\n....\nvariableAttrs['attr_name_2']=entries_2\n....\nf.write_variableattrs(variableAttrs)\n```\n\n### write_var (var_spec, var_attrs=None, var_data=None)\n\nWrites a variable, along with variable attributes and data.\n**var_spec** is a dictionary that contains the specifications of the\nvariable. The required/optional keys for creating a variable:\n\nRequired keys:\n\n* `Variable` The name of the variable\n* `Data_Type` the CDF data type\n* `Num_Elements` The number of elements. Always 1 the for numeric type. The char length for string type.\n* `Rec_Vary` The dimensional sizes, applicable only to rVariables.\n\nFor zVariables:\n\n* `Dim_Sizes` The dimensional sizes for zVariables only. Use [] for 0-dimension. Each and every dimension is varying for zVariables.\n\nFor rVariables:\n\n* `Dims_Vary` The dimensional variances for rVariables only.\n\nOptional keys:\n\n* `Var_Type` Whether the variable is a zVariable or rVariable. Valid values: \"zVariable\" and \"rVariable\". The default is \"zVariable\".\n* `Sparse` Whether the variable has sparse records. Valid values are \"no_sparse\", \"pad_sparse\", and \"prev_sparse\". The default is 'no_sparse'.\n* `Compress` Set the gzip compression level (0 to 9), 0 for no compression. The default is to compress with level 6 (done only if the compressed data is less than the uncompressed data).\n* `Block_Factor` The blocking factor, the number of records in a chunk when the variable is compressed.\n* `Pad` The padded value (in bytes, numpy.ndarray or string)\n\n**var_attrs** is a dictionary, with {attribute:value} pairs. The\nattribute is the name of a variable attribute. The value can have its\ndata type specified for the numeric data. If not, based on Python's\ntype, a corresponding CDF type is assumed: CDF_INT4 for int,\nCDF_DOUBLE for float, CDF_EPOCH16 for complex and and CDF_INT8 for\nlong. For example:\n\n```python\nvar_attrs= { 'attr1': 'value1', 'attr2': 12.45, 'attr3': [3,4,5], .....} -or- var_attrs= { 'attr1': 'value1', 'attr2': [12.45, 'CDF_DOUBLE'], 'attr3': [[3,4,5], 'CDF_INT4'], ..... }\n```\n\n**var_data** is the data for the variable. If the variable is a regular\nvariable without sparse records, it must be in a single structure of\nbytes, or numpy.ndarray for numeric variable, or str or list of strs for\nstring variable. If the variable has sparse records, var_data should be\npresented in a list/tuple with two elements, the first being a\nlist/tuple that contains the physical record number(s), the second being\nthe variable data in bytes, numpy.ndarray, or a list of strings.\nVariable data can have just physical records' data (with the same\nnumber of records as the first element) or have data from both physical\nrecords and virtual records (which with filled data). The var_data has\nthe form:\n\n```python\n[[[rec]()#1,rec_#2,rec_#3,...], [[data]()#1,data_#2,data_#3,...]]\n```\nSee the sample for its setup.\n\n### getVersion()\n\nShows the code version and modified date.\n\nNote: The attribute entry value for the CDF epoch data type, CDF_EPOCH,\nCDF_EPOCH16 or CDF_TIME_TT2000, can be presented in either a numeric\nform, or an encoded string form.\nFor numeric, the CDF_EPOCH data is 8-byte float, CDF_EPOCH16 16-byte complex and CDF_TIME_TT2000 8-byte\nlong. The default encoded string for the epoch `data should have this\nform:\n\n```python\nCDF_EPOCH: 'dd-mon-year hh:mm:ss.mmm'\nCDF_EPOCH16: 'dd-mon-year hh:mm:ss.mmm.uuu.nnn.ppp'\nCDF_TIME_TT2000: 'year-mm-ddThh:mm:ss.mmmuuunnn'\n```\n\nwhere mon is a 3-character month.\n\nSample use -\n\nUse a master CDF file as the template for creating a CDF. Both global\nand variable meta-data comes from the master CDF.\nEach variable's specification also is copied from the master CDF.\nJust fill the variable data to write a new CDF file:\n\n```python\nimport cdfwrite\nimport cdfread\nimport numpy as np\n\ncdf_master = cdfread.CDF('/path/to/master_file.cdf')\nif (cdf_master.file != None):\n# Get the cdf's specification\ninfo=cdf_master.cdf_info()\ncdf_file=cdfwrite.CDF('/path/to/swea_file.cdf',cdf_spec=info,delete=True)\nif (cdf_file.file == None):\n    cdf_master.close()\n    raise OSError('Problem writing file.... Stop')\n\n# Get the global attributes\nglobalaAttrs=cdf_master.globalattsget(expand=True)\n# Write the global attributes\ncdf_file.write_globalattrs(globalaAttrs)\nzvars=info['zVariables']\nprint('no of zvars=',len(zvars))\n# Loop thru all the zVariables\nfor x in range (0, len(zvars)):\n    # Get the variable's specification\n    varinfo=cdf_master.varinq(zvars[x])\n    #print('Z =============>',x,': ', varinfo['Variable'])\n    # Get the variable's attributes\n    varattrs=cdf_master.varattsget(zvars[x], expand=True)\n    if (varinfo['Sparse'].lower() == 'no_sparse'):\n        # A variable with no sparse records... get the variable data\n        vardata=.......\n        # Create the zVariable, write out the attributes and data\n        cdf_file.write_var(varinfo, var_attrs=varattrs, var_data=vardata)\n    else:\n        # A variable with sparse records...\n        # data is in this form [physical_record_numbers, data_values]\n        # physical_record_numbers (0-based) contains the real record\n        # numbers. For example, a variable has only 3 physical records\n        # at [0, 5, 10]:\n        varrecs=[0,5,10]\n        # data_values could contain only the physical records' data or\n        # both the physical and virtual records' data.\n        # For example, a float variable of 1-D with 3 elements with only\n        # 3 physical records at [0,5,10]:\n        # vardata = [[  5.55000000e+01, -1.00000002e+30,  6.65999985e+01],\n        #            [  6.66659973e+02,  7.77770020e+02,  8.88880005e+02],\n        #            [  2.00500000e+02,  2.10600006e+02,  2.20699997e+02]]\n        # Or, with virtual record data embedded in the data:\n        # vardata = [[  5.55000000e+01, -1.00000002e+30,  6.65999985e+01],\n        #            [ -1.00000002e+30, -1.00000002e+30, -1.00000002e+30],\n        #            [ -1.00000002e+30, -1.00000002e+30, -1.00000002e+30],\n        #            [ -1.00000002e+30, -1.00000002e+30, -1.00000002e+30],\n        #            [ -1.00000002e+30, -1.00000002e+30, -1.00000002e+30],\n        #            [  6.66659973e+02,  7.77770020e+02,  8.88880005e+02],\n        #            [ -1.00000002e+30, -1.00000002e+30, -1.00000002e+30],\n        #            [ -1.00000002e+30, -1.00000002e+30, -1.00000002e+30],\n        #            [ -1.00000002e+30, -1.00000002e+30, -1.00000002e+30],\n        #            [ -1.00000002e+30, -1.00000002e+30, -1.00000002e+30],\n        #            [  2.00500000e+02,  2.10600006e+02,  2.20699997e+02]]\n        # Records 1, 2, 3, 4, 6, 7, 8, 9 are all virtual records with pad\n        # data (variable defined with 'pad_sparse').\n        vardata=np.asarray([.,.,.,..])\n        # Create the zVariable, and optionally write out the attributes\n        # and data\n        cdf_file.write_var(varinfo, var_attrs=varattrs,\n                   var_data=[varrecs,vardata])\n   rvars=info['rVariables']\n   print('no of rvars=',len(rvars))\n   # Loop thru all the rVariables\n   for x in range (0, len(rvars)):\n       varinfo=cdf_master.varinq(rvars[x])\n       print('R =============>',x,': ', varinfo['Variable'])\n       varattrs=cdf_master.varattsget(rvars[x], expand=True)\n       if (varinfo['Sparse'].lower() == 'no_sparse'):\n           vardata=.......\n           # Create the rVariable, write out the attributes and data\n           cdf_file.write_var(varinfo, var_attrs=varattrs, var_data=vardata)\n       else:\n           varrecs=[.,.,.,..]\n           vardata=np.asarray([.,.,.,..])\n           cdf_file.write_var(varinfo, var_attrs=varattrs,\n                      var_data=[vardata,vardata])\ncdf_master.close()\ncdf_file.close()\n```\n\n## CDF Epochs\n\nImporting cdflib also imports the module CDFepoch, which handles\nCDF-based epochs. The following functions can be used to convert back\nand forth between different ways to display the date. You can call these\nfunctions like so:\n\n```python\nimport cdflib\n\ncdf_file = cdflib.cdfepoch.compute_epoch([2017,1,1,1,1,1,111])\n```\n\nThere are three (3) epoch data types in CDF: CDF_EPOCH, CDF_EPOCH16\nand CDF_TIME_TT2000.\n\n- CDF_EPOCH is milliseconds since Year 0.\n- CDF_EPOCH16 is picoseconds since Year 0.\n- CDF_TIME_TT2000 (TT2000 as short) is nanoseconds since J2000 with\n    leap seconds.\n\nCDF_EPOCH is a single double(as float in Python), CDF_EPOCH16 is\n2-doubles (as complex in Python), and TT2000 is 8-byte integer (as int\nin Python). In Numpy, they are np.float64, np.complex128 and np.int64,\nrespectively. All these epoch values can come from from CDF.varget\nfunction.\n\nFive main functions are provided\n\n### encode (epochs, iso_8601=False)\n\nEncodes the epoch(s) into UTC string(s).\n\n* CDF_EPOCH: The input should be either a float or list of floats (in numpy, a\n  np.float64 or a np.ndarray of np.float64) Each epoch is encoded, by\n  default to a ISO 8601 form: 2004-05-13T15:08:11.022 Or, if iso_8601\n  is set to False, 13-May-2004 15:08:11.022\n* CDF_EPOCH16: The input should be either a complex or list of complex(in numpy, a\n  np.complex128 or a np.ndarray of np.complex128) Each epoch is\n  encoded, by default to a ISO 8601 form:\n  2004-05-13T15:08:11.022033044055 Or, if iso_8601 is set to False,\n  13-May-2004 15:08:11.022.033.044.055\n* TT2000: The input should be either a int or list of ints (in numpy, a\n  np.int64 or a np.ndarray of np.int64) Each epoch is encoded, by\n  default to a ISO 8601 form: 2008-02-02T06:08:10.10.012014016 Or, if\n  iso_8601 is set to False, 02-Feb-2008 06:08:10.012.014.016\n\n### unixtime (epochs, to_np=False)\n\nEncodes the epoch(s) into seconds after 1970-01-01.\nPrecision is only kept to the nearest microsecond.\n\nIf `to_np=True`, then the values will be returned in a numpy array.\n\n### breakdown (epochs, to_np=False)\n\nBreaks down the epoch(s) into UTC components.\n\n* CDF_EPOCH: they are 7 date/time components: year, month, day, hour, minute, second, and millisecond\n* CDF_EPOCH16:  they are 10 date/time components: year, month, day, hour, minute, second, and millisecond, microsecond, nanosecond, and picosecond.\n* TT2000: they are 9 date/time components: year, month, day, hour, minute, second, millisecond, microsecond, nanosecond.\n\nSpecify `to_np=True`, if the result should be in numpy array.\n\n### compute[_epoch/_epoch16/_tt200] (datetimes, to_np=False)\n\nComputes the provided date/time components into CDF epoch value(s).\n\nFor CDF_EPOCH: For computing into CDF_EPOCH value, each date/time elements should\nhave exactly seven (7) components, as year, month, day, hour,\nminute, second and millisecond, in a list. For example:\n\n```python\n[[2017,1,1,1,1,1,111],[2017,2,2,2,2,2,222]]\n```\n\nOr, call function\ncompute_epoch directly, instead, with at least three (3) first (up\nto seven) components. The last component, if not the 7th, can be a\nfloat that can have a fraction of the unit.\n\nFor CDF_EPOCH16: They should have exactly ten (10) components, as year, month, day,\nhour, minute, second, millisecond, microsecond, nanosecond and\npicosecond, in a list. For example:\n\n```python\n[[2017,1,1,1,1,1,123,456,789,999],[2017,2,2,2,2,2,987,654,321,999]]\n```\n\nOr, call function compute_epoch directly, instead, with at least\nthree (3) first (up to ten) components. The last component, if not\nthe 10th, can be a float that can have a fraction of the unit.\n\nFor TT2000: Each TT2000 typed date/time should have exactly nine (9) components,\nas year, month, day, hour, minute, second, millisecond, microsecond,\nand nanosecond, in a list. For example:\n\n```python\n[[2017,1,1,1,1,1,123,456,789],[2017,2,2,2,2,2,987,654,321]]\n```\n\nOr, call function compute_tt2000 directly, instead, with at least\nthree (3) first (up to nine) components. The last component, if not\nthe 9th, can be a float that can have a fraction of the unit.\n\nSpecify `to_np=True`, if the result should be in numpy class.\n\n### parse (datetimes, to_np=False)\n\nParses the provided date/time string(s) into CDF epoch value(s).\n\n* CDF_EPOCH: The string has to be in the form of 'dd-mmm-yyyy hh:mm:ss.xxx' or 'yyyy-mm-ddThh:mm:ss.xxx' (in iso_8601). The string is the output from encode function.\n* CDF_EPOCH16: The string has to be in the form of 'dd-mmm-yyyy hh:mm:ss.mmm.uuu.nnn.ppp' or 'yyyy-mm-ddThh:mm:ss.mmmuuunnnppp' (in iso_8601). The string is the output from encode function.\n* TT2000: The string has to be in the form of 'dd-mmm-yyyy hh:mm:ss.mmm.uuu.nnn' or 'yyyy-mm-ddThh:mm:ss.mmmuuunnn' (in iso_8601). The string is the output from encode function.\n\nSpecify `to_np=True`, if the result should be in numpy class.\n\n### findepochrange (epochs, starttime=None, endtime=None)\n\nFinds the record range within the start and end time from values of a\nCDF epoch data type. It returns a list of record numbers. If the start\ntime is not provided, then it is assumed to be the minimum possible\nvalue. If the end time is not provided, then the maximum possible value\nis assumed. The epoch is assumed to be in the chronological order. The\nstart and end times should have the proper number of date/time\ncomponents, corresponding to the epoch's data type.\n\nThe start/end times should be in either be in epoch units, or in the\nlist format described in \"compute_epoch/epoch16/tt2000\" section.\n\n### getVersion ()\n\nShows the code version.\n\n### getLeapSecondLastUpdated ()\n\nShows the latest date a leap second was added to the leap second table.\n\n## CDF Astropy Epochs\n\nIf the user has astropy installed, importing cdflib also imports the module\ncdflib.cdfastropy, which contains all of the functionality of the above module,\nbut uses the Astropy Time class for all conversions.  It can be used in the same\nway as the above module:\n\n```python\nimport cdflib\n\ncdf_file = cdflib.cdfastropy.compute_epoch([2017,1,1,1,1,1,111])\n```\n\nAdditionally, and perhaps most importantly, there is an additonal function that converts\nCDF_EPOCH/EPOCH16/TT2000 times to the Astropy Time class:\n\n### convert_to_astropy (epochs, format=None)\n\nConverts the epoch(s) into Astropy Time(s).\n\n* CDF_EPOCH: The input should be either a float or list of floats (in numpy, a\n  np.float64 or a np.ndarray of np.float64).  If you'd like to ignore the input type and convert\n  to CDF_EPOCH directly, specify format='cdf_epoch' when you call the function.\n* CDF_EPOCH16: The input should be either a complex or list of complex(in numpy, a\n  np.complex128 or a np.ndarray of np.complex128).  If you'd like to ignore the input type and convert\n  to CDF_EPOCH directly, specify format='cdf_epoch16' when you call the function.\n* TT2000: The input should be either a int or list of ints (in numpy, a\n  np.int64 or a np.ndarray of np.int64).  If you'd like to ignore the input type and convert\n  to CDF_EPOCH directly, specify format='cdf_tt2000' when you call the function.\n\nFor more information about Astropy Times and all the functionality it contains, take a look at the astropy documentation\n\nhttps://docs.astropy.org/en/stable/time/", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/MAVENSDC/cdflib", "keywords": "CDF,maven,lasp,PDS,GSFC", "license": "", "maintainer": "", "maintainer_email": "", "name": "cdflib", "package_url": "https://pypi.org/project/cdflib/", "platform": "", "project_url": "https://pypi.org/project/cdflib/", "project_urls": {"Homepage": "https://github.com/MAVENSDC/cdflib"}, "release_url": "https://pypi.org/project/cdflib/0.3.18/", "requires_dist": null, "requires_python": ">=3.5", "summary": "A python CDF reader toolkit", "version": "0.3.18"}, "last_serial": 6667846, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "a9d9343bfd4b1b99f2031a9d8bbe8cd3", "sha256": "422331296c3ffc17d62d99e08bf2b81051277fd589b823d7825112ed17a62c43"}, "downloads": -1, "filename": "cdflib-0.1.0.tar.gz", "has_sig": false, "md5_digest": "a9d9343bfd4b1b99f2031a9d8bbe8cd3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23759, "upload_time": "2017-09-11T18:18:14", "upload_time_iso_8601": "2017-09-11T18:18:14.604417Z", "url": "https://files.pythonhosted.org/packages/d4/42/0b49c916dabbe5b093d9dd346bdbea7b47a5d38c3312de420686d34f8493/cdflib-0.1.0.tar.gz"}], "0.2.0": [{"comment_text": "", "digests": {"md5": "a1996f4d98c37f6da80d3544e306286e", "sha256": "fcdeab470fce44ee24b2f6f24292efacb19e10559104211b93554ae52e67d5bf"}, "downloads": -1, "filename": "cdflib-0.2.0.tar.gz", "has_sig": false, "md5_digest": "a1996f4d98c37f6da80d3544e306286e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25131, "upload_time": "2017-09-29T16:32:48", "upload_time_iso_8601": "2017-09-29T16:32:48.173546Z", "url": "https://files.pythonhosted.org/packages/a3/3c/76fed71994d028441c1f9230cb7576f637f85211c0a1e352bf5371a1bfc1/cdflib-0.2.0.tar.gz"}], "0.3.0": [{"comment_text": "", "digests": {"md5": "737a472b5a7b3697788fea35bf969614", "sha256": "5d86862fb7ebdb9a17e153943c45883ca3731b00998cb3e4b2e3a4c73b5b7ec5"}, "downloads": -1, "filename": "cdflib-0.3.0.tar.gz", "has_sig": false, "md5_digest": "737a472b5a7b3697788fea35bf969614", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53052, "upload_time": "2018-01-10T18:52:47", "upload_time_iso_8601": "2018-01-10T18:52:47.875354Z", "url": "https://files.pythonhosted.org/packages/69/44/a0abfbfc636bc95da8961b16e12ba55b8dbdeaf4109f3e15492e1d690e4b/cdflib-0.3.0.tar.gz"}], "0.3.1": [{"comment_text": "", "digests": {"md5": "c8e99add974ab29741a34a8f45633a9f", "sha256": "661ce248e013c4fa6ad52787c69168992d3c42a0861ec73de409c8e2271617d9"}, "downloads": -1, "filename": "cdflib-0.3.1.tar.gz", "has_sig": false, "md5_digest": "c8e99add974ab29741a34a8f45633a9f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53465, "upload_time": "2018-01-11T22:02:07", "upload_time_iso_8601": "2018-01-11T22:02:07.076330Z", "url": "https://files.pythonhosted.org/packages/6b/00/7ce438efa17aa0df639b6d02226f5d19accc879d3cd6c59b16f618d0e3ef/cdflib-0.3.1.tar.gz"}], "0.3.10": [{"comment_text": "", "digests": {"md5": "2f350e28ea0861425c272d6c5f9c9a93", "sha256": "a1409e7892e99cf217f830adea7897b912596a42b272eb2ad9a7fc303915dde9"}, "downloads": -1, "filename": "cdflib-0.3.10.tar.gz", "has_sig": false, "md5_digest": "2f350e28ea0861425c272d6c5f9c9a93", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 64449, "upload_time": "2019-05-08T00:14:38", "upload_time_iso_8601": "2019-05-08T00:14:38.762927Z", "url": "https://files.pythonhosted.org/packages/76/7d/12d3a53cfe4708c164e72a3cfcfc55b17167f3fc5bb23b2a4d8f31a965b4/cdflib-0.3.10.tar.gz"}], "0.3.11": [{"comment_text": "", "digests": {"md5": "7c886cb9450959c395e514520bb240ce", "sha256": "e57a65b86ad63a703a6e12e22ae0a2956e2391e2d8e141ad55d782d1120952ef"}, "downloads": -1, "filename": "cdflib-0.3.11.tar.gz", "has_sig": false, "md5_digest": "7c886cb9450959c395e514520bb240ce", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 64510, "upload_time": "2019-05-08T00:17:14", "upload_time_iso_8601": "2019-05-08T00:17:14.691024Z", "url": "https://files.pythonhosted.org/packages/6d/d9/a50e56e7924a3dd9c90fbb9e4a7e5fd398b375af277828a255db40ce3375/cdflib-0.3.11.tar.gz"}], "0.3.12": [{"comment_text": "", "digests": {"md5": "463004c7525548c94d8da6e67c73252b", "sha256": "a2def69313de01b77de413b4bfbc0fcb5661139665c51d6377b8a1a3b02c1efb"}, "downloads": -1, "filename": "cdflib-0.3.12.tar.gz", "has_sig": false, "md5_digest": "463004c7525548c94d8da6e67c73252b", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 64556, "upload_time": "2019-05-08T23:30:34", "upload_time_iso_8601": "2019-05-08T23:30:34.221703Z", "url": "https://files.pythonhosted.org/packages/81/d9/62a74dbdc9a6b67b5e3472664a5d79fcf1b77b8209372ed5a05968f9742a/cdflib-0.3.12.tar.gz"}], "0.3.14": [{"comment_text": "", "digests": {"md5": "a342a393c62f538c5c8e3e2e3d9c4ce7", "sha256": "b134793fea6a0973a70f8c8c0a07e78fbdc6d21ef621a8ac92fa8d5e703503d1"}, "downloads": -1, "filename": "cdflib-0.3.14.tar.gz", "has_sig": false, "md5_digest": "a342a393c62f538c5c8e3e2e3d9c4ce7", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 75941, "upload_time": "2019-07-10T23:15:10", "upload_time_iso_8601": "2019-07-10T23:15:10.791777Z", "url": "https://files.pythonhosted.org/packages/21/c0/80cfc4ad585bab5646b4a9a16df88a2cb14d6c06b87eb9498167116d7c12/cdflib-0.3.14.tar.gz"}], "0.3.15": [{"comment_text": "", "digests": {"md5": "cffbfa40ebe46166042fbfe873b03aed", "sha256": "0ff43e7fcf3659c64ab5bc4805e87d1129d5d44060333cd5b91ecbee7c8991c1"}, "downloads": -1, "filename": "cdflib-0.3.15.tar.gz", "has_sig": false, "md5_digest": "cffbfa40ebe46166042fbfe873b03aed", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 66455, "upload_time": "2019-07-11T17:02:40", "upload_time_iso_8601": "2019-07-11T17:02:40.256697Z", "url": "https://files.pythonhosted.org/packages/df/93/8ad1ebf44088d2213b1a4fa216d6389bf38cc55c259cf5c553fe6da914d4/cdflib-0.3.15.tar.gz"}], "0.3.16": [{"comment_text": "", "digests": {"md5": "2bfffae9f5716bdb9fa005269275e76c", "sha256": "7ff687b43ce2a6e47cdeb8f8ebc88cdb2352960c18787c3503f9e0b530180704"}, "downloads": -1, "filename": "cdflib-0.3.16.tar.gz", "has_sig": false, "md5_digest": "2bfffae9f5716bdb9fa005269275e76c", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 67256, "upload_time": "2019-08-05T23:15:04", "upload_time_iso_8601": "2019-08-05T23:15:04.320573Z", "url": "https://files.pythonhosted.org/packages/ec/d7/d787c99e6087d4c7bbd597342c646f6c9bdfda5fb2060e67a9b8e3c4a570/cdflib-0.3.16.tar.gz"}], "0.3.17": [{"comment_text": "", "digests": {"md5": "a005c813a118201b9efd2d39afbc279b", "sha256": "8aab6ef065396819877605acad5c195e96fb9e23daec5a612b5b9c42cc2c6f26"}, "downloads": -1, "filename": "cdflib-0.3.17-py3-none-any.whl", "has_sig": false, "md5_digest": "a005c813a118201b9efd2d39afbc279b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 60565, "upload_time": "2019-10-21T14:29:27", "upload_time_iso_8601": "2019-10-21T14:29:27.074779Z", "url": "https://files.pythonhosted.org/packages/1b/24/27079213f40a54cd522e8f5e5f6ab673741a5f7b29c8ddcae512299df011/cdflib-0.3.17-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "4d41b6d6c2e8ac2fe5a74f8ceebfe96c", "sha256": "9b027b0e5b7d84816aafa13edc5df3767c560881e8a93348f92cdfba29d7897a"}, "downloads": -1, "filename": "cdflib-0.3.17.tar.gz", "has_sig": false, "md5_digest": "4d41b6d6c2e8ac2fe5a74f8ceebfe96c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 66616, "upload_time": "2019-10-21T14:29:29", "upload_time_iso_8601": "2019-10-21T14:29:29.886782Z", "url": "https://files.pythonhosted.org/packages/c4/7f/30267a6ec3e66d6010e6856d580155851d22e4797f873e983e4252d24ba8/cdflib-0.3.17.tar.gz"}], "0.3.18": [{"comment_text": "", "digests": {"md5": "9b07c271cc08ff3f9a6f8f79122261e3", "sha256": "8249fd28653b40a9241e3cebe38e82bff11bda2e2167971d039d6f76024243aa"}, "downloads": -1, "filename": "cdflib-0.3.18.tar.gz", "has_sig": false, "md5_digest": "9b07c271cc08ff3f9a6f8f79122261e3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 66968, "upload_time": "2020-02-20T12:13:16", "upload_time_iso_8601": "2020-02-20T12:13:16.283264Z", "url": "https://files.pythonhosted.org/packages/1f/d3/4c76dc94bc311ec779e9a2f662539028c7bd6ded1785bf27ead4e9f2f6a2/cdflib-0.3.18.tar.gz"}], "0.3.2": [{"comment_text": "", "digests": {"md5": "bff201a87c4b84362f5c60f8879422c2", "sha256": "f4631134a0857e6422d5417e5498089569cb77b811aa02ef5ea5861f756a6de4"}, "downloads": -1, "filename": "cdflib-0.3.2.tar.gz", "has_sig": false, "md5_digest": "bff201a87c4b84362f5c60f8879422c2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53505, "upload_time": "2018-01-12T19:51:54", "upload_time_iso_8601": "2018-01-12T19:51:54.131775Z", "url": "https://files.pythonhosted.org/packages/0e/db/15021f5ac0187706e235c5db133e31fe220fe48ef81b92a5836d0e9abf74/cdflib-0.3.2.tar.gz"}], "0.3.3": [{"comment_text": "", "digests": {"md5": "7e93f2c38bf31ccc524fe7ad7f2384d5", "sha256": "e7a3504c2e7abc126df98cd108e509125823dc89b79ec02ff9d8c9a590873508"}, "downloads": -1, "filename": "cdflib-0.3.3.tar.gz", "has_sig": false, "md5_digest": "7e93f2c38bf31ccc524fe7ad7f2384d5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56081, "upload_time": "2018-01-30T23:21:19", "upload_time_iso_8601": "2018-01-30T23:21:19.279746Z", "url": "https://files.pythonhosted.org/packages/bd/cb/c32f5ed9fd0ab24ea53376c1017942094de4d0e4aeffd5c4aa2c77205de0/cdflib-0.3.3.tar.gz"}], "0.3.4": [{"comment_text": "", "digests": {"md5": "4084d0660b823caeb82e93a8c7683c12", "sha256": "d9c0a03022dc4a80db24fc58dc8a29327ca8e9776a1a8448b74097399b553788"}, "downloads": -1, "filename": "cdflib-0.3.4.tar.gz", "has_sig": false, "md5_digest": "4084d0660b823caeb82e93a8c7683c12", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56011, "upload_time": "2018-01-31T03:22:55", "upload_time_iso_8601": "2018-01-31T03:22:55.876910Z", "url": "https://files.pythonhosted.org/packages/09/e4/d0b3279359b05aa58698e65245a16cb0033951a246ca362f4e053cb065f0/cdflib-0.3.4.tar.gz"}], "0.3.5": [{"comment_text": "", "digests": {"md5": "3855b8cba380792a8d4e113c0f03e24c", "sha256": "7ca5083ff93c709403f061acbe3a4f5953412325d6670ab44b8f7ca5cff77eea"}, "downloads": -1, "filename": "cdflib-0.3.5.tar.gz", "has_sig": false, "md5_digest": "3855b8cba380792a8d4e113c0f03e24c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56015, "upload_time": "2018-05-10T18:08:58", "upload_time_iso_8601": "2018-05-10T18:08:58.235563Z", "url": "https://files.pythonhosted.org/packages/68/e9/c6dbb8e759168d61eee47418d2781cc52350a18711b58d4777afb7e30a15/cdflib-0.3.5.tar.gz"}], "0.3.6": [{"comment_text": "", "digests": {"md5": "f44aad357a58a6fd30202a26f2081b31", "sha256": "a58ded8cac93282a033a5502f8a7f9fb2fcec978b6563769a1c9824420348385"}, "downloads": -1, "filename": "cdflib-0.3.6.tar.gz", "has_sig": false, "md5_digest": "f44aad357a58a6fd30202a26f2081b31", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64187, "upload_time": "2018-11-08T23:42:25", "upload_time_iso_8601": "2018-11-08T23:42:25.206601Z", "url": "https://files.pythonhosted.org/packages/3a/20/107752a33625351aed22b0a9228f78969d622a532a36991eec9440b6a899/cdflib-0.3.6.tar.gz"}], "0.3.7": [{"comment_text": "", "digests": {"md5": "de705d7eebf4518e7351810c5bf4f15f", "sha256": "55c0f9045dc0bede63a1d0eea6609db5a23292403fce46c66d1ce808d4f715ad"}, "downloads": -1, "filename": "cdflib-0.3.7.tar.gz", "has_sig": false, "md5_digest": "de705d7eebf4518e7351810c5bf4f15f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64196, "upload_time": "2018-11-12T20:34:34", "upload_time_iso_8601": "2018-11-12T20:34:34.886073Z", "url": "https://files.pythonhosted.org/packages/e7/d7/b2283912605d79c9f6a45cdd75d3ed544744dd32037bb21b167fa9ed78c2/cdflib-0.3.7.tar.gz"}], "0.3.8": [{"comment_text": "", "digests": {"md5": "9964e8783b870bee25c5e09457f32d39", "sha256": "810817014d058202f2581dccd13cb55953da29280c6b822461c0726ccad5cee5"}, "downloads": -1, "filename": "cdflib-0.3.8.tar.gz", "has_sig": false, "md5_digest": "9964e8783b870bee25c5e09457f32d39", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 64222, "upload_time": "2019-01-10T00:54:03", "upload_time_iso_8601": "2019-01-10T00:54:03.541938Z", "url": "https://files.pythonhosted.org/packages/95/a3/a73a989c720baa2d992db4efe2258947fda86566d18581571fb34373b22e/cdflib-0.3.8.tar.gz"}], "0.3.9": [{"comment_text": "", "digests": {"md5": "6f337165a2d0cc238aa09aa1b0998a0e", "sha256": "81aababaad37cf679fb54e0ba1e49c0e66ec74935d105a012655515b4dc4fad8"}, "downloads": -1, "filename": "cdflib-0.3.9.tar.gz", "has_sig": false, "md5_digest": "6f337165a2d0cc238aa09aa1b0998a0e", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 63877, "upload_time": "2019-01-18T13:26:44", "upload_time_iso_8601": "2019-01-18T13:26:44.024560Z", "url": "https://files.pythonhosted.org/packages/85/60/915f7f5bdafca384ac52b2a29a6c0f4b299adf84ae293cc5f15bac8d946e/cdflib-0.3.9.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "9b07c271cc08ff3f9a6f8f79122261e3", "sha256": "8249fd28653b40a9241e3cebe38e82bff11bda2e2167971d039d6f76024243aa"}, "downloads": -1, "filename": "cdflib-0.3.18.tar.gz", "has_sig": false, "md5_digest": "9b07c271cc08ff3f9a6f8f79122261e3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 66968, "upload_time": "2020-02-20T12:13:16", "upload_time_iso_8601": "2020-02-20T12:13:16.283264Z", "url": "https://files.pythonhosted.org/packages/1f/d3/4c76dc94bc311ec779e9a2f662539028c7bd6ded1785bf27ead4e9f2f6a2/cdflib-0.3.18.tar.gz"}]}
{"info": {"author": "Dmitry Pershin", "author_email": "dapper91@mail.ru", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: Public Domain", "Natural Language :: English", "Programming Language :: Python", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "=====\npjrpc\n=====\n\n.. image:: https://travis-ci.org/dapper91/pjrpc.svg?branch=master\n    :target: https://travis-ci.org/dapper91/pjrpc\n    :alt: Build status\n.. image:: https://img.shields.io/pypi/l/pjrpc.svg\n    :target: https://pypi.org/project/pjrpc\n    :alt: License\n.. image:: https://img.shields.io/pypi/pyversions/pjrpc.svg\n    :target: https://pypi.org/project/pjrpc\n    :alt: Supported Python versions\n.. image:: https://codecov.io/gh/dapper91/pjrpc/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/dapper91/pjrpc\n    :alt: Code coverage\n.. image:: https://readthedocs.org/projects/pjrpc/badge/?version=stable&style=flat\n   :alt: ReadTheDocs status\n   :target: https://pjrpc.readthedocs.io/en/stable/\n\n\n``pjrpc`` is an extensible `JSON-RPC <https://www.jsonrpc.org>`_ client/server library with an intuitive interface\nthat can be easily extended and integrated in your project without writing a lot of boilerplate code.\n\nFeatures:\n\n- intuitive api\n- extendability\n- synchronous and asynchronous client backed\n- popular frameworks integration\n- builtin parameter validation\n- pytest integration\n\nInstallation\n------------\n\nYou can install pjrpc with pip:\n\n.. code-block:: console\n\n    $ pip install pjrpc\n\n\nExtra requirements\n------------------\n\n- `aiohttp <https://aiohttp.readthedocs.io>`_\n- `aio_pika <https://aio-pika.readthedocs.io>`_\n- `flask <https://flask.palletsprojects.com>`_\n- `jsonschema <https://python-jsonschema.readthedocs.io>`_\n- `kombu <https://kombu.readthedocs.io/en/stable/>`_\n- `pydantic <https://pydantic-docs.helpmanual.io/>`_\n- `requests <https://requests.readthedocs.io>`_\n\n\nDocumentation\n-------------\n\nDocumentation is available at `Read the Docs <https://pjrpc.readthedocs.io/en/latest/>`_.\n\n\nQuickstart\n----------\n\nClient requests\n_______________\n\nThe way of using ``pjrpc`` clients is very simple and intuitive. Methods may be called by name, using proxy object\nor by sending handmade ``pjrpc.common.Request`` class object. Notification requests can be made using\n``pjrpc.client.AbstractClient.notify`` method or by sending a ``pjrpc.common.Request`` object without id.\n\n.. code-block:: python\n\n    import pjrpc\n    from pjrpc.client.backend import requests as pjrpc_client\n\n\n    client = pjrpc_client.Client('http://localhost/api/v1')\n\n    response: pjrpc.Response = client.send(pjrpc.Request('sum', params=[1, 2], id=1))\n    print(f\"1 + 2 = {response.result}\")\n\n    result = client('sum', a=1, b=2)\n    print(f\"1 + 2 = {result}\")\n\n    result = client.proxy.sum(1, 2)\n    print(f\"1 + 2 = {result}\")\n\n    client.notify('tick')\n\n\nAsynchronous client api looks pretty much the same:\n\n.. code-block:: python\n\n    import pjrpc\n    from pjrpc.client.backend import aiohttp as pjrpc_client\n\n\n    client = pjrpc_client.Client('http://localhost/api/v1')\n\n    response = await client.send(pjrpc.Request('sum', params=[1, 2], id=1))\n    print(f\"1 + 2 = {response.result}\")\n\n    result = await client('sum', a=1, b=2)\n    print(f\"1 + 2 = {result}\")\n\n    result = await client.proxy.sum(1, 2)\n    print(f\"1 + 2 = {result}\")\n\n    await client.notify('tick')\n\n\nBatch requests\n______________\n\nBatch requests also supported. You can build ``pjrpc.common.BatchRequest`` request by your hand and then send it to the\nserver. The result is a ``pjrpc.common.BatchResponse`` instance you can iterate over to get all the results or get\neach one by index:\n\n.. code-block:: python\n\n    import pjrpc\n    from pjrpc.client.backend import requests as pjrpc_client\n\n\n    client = pjrpc_client.Client('http://localhost/api/v1')\n\n    batch_response = await client.batch.send(pjrpc.BatchRequest(\n        pjrpc.Request('sum', [2, 2], id=1),\n        pjrpc.Request('sub', [2, 2], id=2),\n        pjrpc.Request('div', [2, 2], id=3),\n        pjrpc.Request('mult', [2, 2], id=4),\n    ))\n    print(f\"2 + 2 = {batch_response[0].result}\")\n    print(f\"2 - 2 = {batch_response[1].result}\")\n    print(f\"2 / 2 = {batch_response[2].result}\")\n    print(f\"2 * 2 = {batch_response[3].result}\")\n\n\nThere are also several alternative approaches which are a syntactic sugar for the first one (note that the result\nis not a ``pjrpc.common.BatchResponse`` object anymore but a tuple of \"plain\" method invocation results):\n\n- using chain call notation:\n\n.. code-block:: python\n\n    result = await client.batch('sum', 2, 2)('sub', 2, 2)('div', 2, 2)('mult', 2, 2).call()\n    print(f\"2 + 2 = {result[0]}\")\n    print(f\"2 - 2 = {result[1]}\")\n    print(f\"2 / 2 = {result[2]}\")\n    print(f\"2 * 2 = {result[3]}\")\n\n\n- using subscription operator:\n\n.. code-block:: python\n\n    result = await client.batch[\n        ('sum', 2, 2),\n        ('sub', 2, 2),\n        ('div', 2, 2),\n        ('mult', 2, 2),\n    ]\n    print(f\"2 + 2 = {result[0]}\")\n    print(f\"2 - 2 = {result[1]}\")\n    print(f\"2 / 2 = {result[2]}\")\n    print(f\"2 * 2 = {result[3]}\")\n\n\n- using proxy chain call:\n\n.. code-block:: python\n\n    result = await client.batch.proxy.sum(2, 2).sub(2, 2).div(2, 2).mult(2, 2).call()\n    print(f\"2 + 2 = {result[0]}\")\n    print(f\"2 - 2 = {result[1]}\")\n    print(f\"2 / 2 = {result[2]}\")\n    print(f\"2 * 2 = {result[3]}\")\n\n\nWhich one to use is up to you but be aware that if any of the requests returns an error the result of the other ones\nwill be lost. In such case the first approach can be used to iterate over all the responses and get the results of\nthe succeeded ones like this:\n\n.. code-block:: python\n\n    import pjrpc\n    from pjrpc.client.backend import requests as pjrpc_client\n\n\n    client = pjrpc_client.Client('http://localhost/api/v1')\n\n    batch_response = client.batch.send(pjrpc.BatchRequest(\n        pjrpc.Request('sum', [2, 2], id=1),\n        pjrpc.Request('sub', [2, 2], id=2),\n        pjrpc.Request('div', [2, 2], id=3),\n        pjrpc.Request('mult', [2, 2], id=4),\n    ))\n\n    for response in batch_response:\n        if response.is_success:\n            print(response.result)\n        else:\n            print(response.error)\n\n\nBatch notifications:\n\n.. code-block:: python\n\n    import pjrpc\n    from pjrpc.client.backend import requests as pjrpc_client\n\n\n    client = pjrpc_client.Client('http://localhost/api/v1')\n\n    client.batch.notify('tick').notify('tack').notify('tick').notify('tack').call()\n\n\n\nServer\n______\n\n``pjrpc`` supports popular backend frameworks like `aiohttp <https://aiohttp.readthedocs.io>`_,\n`flask <https://flask.palletsprojects.com>`_ and message brokers like `kombu <https://kombu.readthedocs.io/en/stable/>`_\nand `aio_pika <https://aio-pika.readthedocs.io>`_.\n\n\nRunning of aiohttp based JSON-RPC server is a very simple process. Just define methods, add them to the\nregistry and run the server:\n\n.. code-block:: python\n\n    import uuid\n\n    from aiohttp import web\n\n    import pjrpc.server\n    from pjrpc.server.integration import aiohttp\n\n    methods = pjrpc.server.MethodRegistry()\n\n\n    @methods.add(context='request')\n    async def add_user(request: web.Request, user: dict):\n        user_id = uuid.uuid4().hex\n        request.app['users'][user_id] = user\n\n        return {'id': user_id, **user}\n\n\n    jsonrpc_app = aiohttp.Application('/api/v1')\n    jsonrpc_app.dispatcher.add_methods(methods)\n    jsonrpc_app.app['users'] = {}\n\n    if __name__ == \"__main__\":\n        web.run_app(jsonrpc_app.app, host='localhost', port=8080)\n\n\nParameter validation\n____________________\n\nVery often besides dumb method parameters validation it is necessary to implement more \"deep\" validation and provide\ncomprehensive errors description to clients. Fortunately ``pjrpc`` has builtin parameter validation based on\n`pydantic <https://pydantic-docs.helpmanual.io/>`_ library which uses python type annotation for validation.\nLook at the following example: all you need to annotate method parameters (or describe more complex types beforehand if\nnecessary). ``pjrpc`` will be validating method parameters and returning informative errors to clients.\n\n\n.. code-block:: python\n\n    import enum\n    import uuid\n    from typing import List\n\n    import pydantic\n    from aiohttp import web\n\n    import pjrpc.server\n    from pjrpc.server.validators import pydantic as validators\n    from pjrpc.server.integration import aiohttp\n\n    methods = pjrpc.server.MethodRegistry()\n    validator = validators.PydanticValidator()\n\n\n    class ContactType(enum.Enum):\n        PHONE = 'phone'\n        EMAIL = 'email'\n\n\n    class Contact(pydantic.BaseModel):\n        type: ContactType\n        value: str\n\n\n    class User(pydantic.BaseModel):\n        name: str\n        surname: str\n        age: int\n        contacts: List[Contact]\n\n\n    @methods.add(context='request')\n    @validator.validate\n    async def add_user(request: web.Request, user: User):\n        user_id = uuid.uuid4()\n        request.app['users'][user_id] = user\n\n        return {'id': user_id, **user.dict()}\n\n\n    class JSONEncoder(pjrpc.common.JSONEncoder):\n\n        def default(self, o):\n            if isinstance(o, uuid.UUID):\n                return o.hex\n            if isinstance(o, enum.Enum):\n                return o.value\n\n            return super().default(o)\n\n\n    jsonrpc_app = aiohttp.Application('/api/v1', json_encoder=JSONEncoder)\n    jsonrpc_app.dispatcher.add_methods(methods)\n    jsonrpc_app.app['users'] = {}\n\n    if __name__ == \"__main__\":\n        web.run_app(jsonrpc_app.app, host='localhost', port=8080)\n\n\nError handling\n______________\n\n``pjrpc`` implements all the errors listed in `protocol specification <https://www.jsonrpc.org/specification#error_object>`_\nwhich can be found in ``pjrpc.common.exceptions`` module so that error handling is very simple and \"pythonic-way\":\n\n.. code-block:: python\n\n    import pjrpc\n    from pjrpc.client.backend import requests as pjrpc_client\n\n    client = pjrpc_client.Client('http://localhost/api/v1')\n\n    try:\n        result = client.proxy.sum(1, 2)\n    except pjrpc.MethodNotFound as e:\n        print(e)\n\n\nDefault error list can be easily extended. All you need to create an error class inherited from\n``pjrpc.exc.JsonRpcError`` and define an error code and a description message. ``pjrpc`` will be automatically\ndeserializing custom errors for you:\n\n.. code-block:: python\n\n    import pjrpc\n    from pjrpc.client.backend import requests as pjrpc_client\n\n    class UserNotFound(pjrpc.exc.JsonRpcError):\n        code = 1\n        message = 'user not found'\n\n\n    client = pjrpc_client.Client('http://localhost/api/v1')\n\n    try:\n        result = client.proxy.get_user(user_id=1)\n    except UserNotFound as e:\n        print(e)\n\n\nOn the server side everything is also pretty straightforward:\n\n.. code-block:: python\n\n    import uuid\n\n    import flask\n\n    import pjrpc\n    from pjrpc.server import MethodRegistry\n    from pjrpc.server.integration import flask as integration\n\n    app = flask.Flask(__name__)\n\n    methods = pjrpc.server.MethodRegistry()\n\n\n    class UserNotFound(pjrpc.exc.JsonRpcError):\n        code = 1\n        message = 'user not found'\n\n\n    @methods.add\n    def add_user(user: dict):\n        user_id = uuid.uuid4().hex\n        flask.current_app.users[user_id] = user\n\n        return {'id': user_id, **user}\n\n    @methods.add\n     def get_user(self, user_id: str):\n        user = flask.current_app.users.get(user_id)\n        if not user:\n            raise UserNotFound(data=user_id)\n\n        return user\n\n\n    json_rpc = integration.JsonRPC('/api/v1')\n    json_rpc.dispatcher.add_methods(methods)\n\n    app.users = {}\n\n    json_rpc.init_app(app)\n\n    if __name__ == \"__main__\":\n        app.run(port=80)", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dapper91/pjrpc", "keywords": "json-rpc,rpc,jsonrpc-client,jsonrpc-server,requests,aiohttp,flask", "license": "Public Domain License", "maintainer": "", "maintainer_email": "", "name": "pjrpc", "package_url": "https://pypi.org/project/pjrpc/", "platform": "", "project_url": "https://pypi.org/project/pjrpc/", "project_urls": {"Documentation": "https://pjrpc.readthedocs.io/en/latest/", "Homepage": "https://github.com/dapper91/pjrpc", "Source": "https://github.com/dapper91/pjrpc"}, "release_url": "https://pypi.org/project/pjrpc/1.1.0/", "requires_dist": null, "requires_python": ">=3.5", "summary": "Extensible JSON-RPC library", "version": "1.1.0"}, "last_serial": 6900995, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "6c793cd2b8f6b494de1df4ccd6a921ed", "sha256": "06627f39f2df215c45edfabff148ffb47eaa513bfc5f43046889b993ac6b8b64"}, "downloads": -1, "filename": "pjrpc-0.1.0.tar.gz", "has_sig": false, "md5_digest": "6c793cd2b8f6b494de1df4ccd6a921ed", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 31572, "upload_time": "2019-11-09T11:41:28", "upload_time_iso_8601": "2019-11-09T11:41:28.722637Z", "url": "https://files.pythonhosted.org/packages/2b/60/64d39b397eb88e3f96acd4bfadb83835119389f067e27787aa34548fdb39/pjrpc-0.1.0.tar.gz"}], "0.1.1": [{"comment_text": "", "digests": {"md5": "330cc5b00c0febf30e55a5352a36bbc7", "sha256": "c4c8c6f0ec192865c9be8ff73eb1e90c022933f6e7665127d970e8c14a0e92b5"}, "downloads": -1, "filename": "pjrpc-0.1.1.tar.gz", "has_sig": false, "md5_digest": "330cc5b00c0febf30e55a5352a36bbc7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 31667, "upload_time": "2019-11-09T12:41:01", "upload_time_iso_8601": "2019-11-09T12:41:01.731148Z", "url": "https://files.pythonhosted.org/packages/81/24/a7ca90175c0b7b59e3d3fc4c880290ac0330b44e3acbd1266462a6902d60/pjrpc-0.1.1.tar.gz"}], "0.1.2": [{"comment_text": "", "digests": {"md5": "d98565443f184957a25036a8a73ace9b", "sha256": "289a266c6402c3f5f9bc28d5b06f643b63f82ad03877bbb69df05b167d74653b"}, "downloads": -1, "filename": "pjrpc-0.1.2.tar.gz", "has_sig": false, "md5_digest": "d98565443f184957a25036a8a73ace9b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 33338, "upload_time": "2019-11-10T12:06:21", "upload_time_iso_8601": "2019-11-10T12:06:21.148368Z", "url": "https://files.pythonhosted.org/packages/80/43/6a9be4c10a63d447a5f7ad65b7cf333ee75ee1cbbe3507c36d928acb4bad/pjrpc-0.1.2.tar.gz"}], "0.1.3": [{"comment_text": "", "digests": {"md5": "6e179dbd312c21fcd8e983fdccd43324", "sha256": "709aadc9cfe650b4fedeb87b338ab492751534e51e79c8ef1c61f2e4f5ffc5f9"}, "downloads": -1, "filename": "pjrpc-0.1.3.tar.gz", "has_sig": false, "md5_digest": "6e179dbd312c21fcd8e983fdccd43324", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 35148, "upload_time": "2019-11-16T09:59:46", "upload_time_iso_8601": "2019-11-16T09:59:46.883118Z", "url": "https://files.pythonhosted.org/packages/17/16/7664c9018ce14bfc7387113936f2271cea1c688f1f7c768ee53e7b486446/pjrpc-0.1.3.tar.gz"}], "0.1.4": [{"comment_text": "", "digests": {"md5": "bb3c73a6ad5426ec6ead38bfad3ed0f3", "sha256": "92e9bc0eae1e0610c8f3164326810fd3b840fd9781ac68b29ea07f62e94078d9"}, "downloads": -1, "filename": "pjrpc-0.1.4.tar.gz", "has_sig": false, "md5_digest": "bb3c73a6ad5426ec6ead38bfad3ed0f3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 35299, "upload_time": "2019-12-09T20:01:51", "upload_time_iso_8601": "2019-12-09T20:01:51.756014Z", "url": "https://files.pythonhosted.org/packages/2c/30/d97fefb8aa9974e21c0f68197c5e7af238799bed3b9df961743c4c37ca4f/pjrpc-0.1.4.tar.gz"}], "1.0.0": [{"comment_text": "", "digests": {"md5": "2821c7a4a5a215aa4b16f21d1f92c41f", "sha256": "571d7d219074fb5d7e05823c8eb5bf93ba9569a8294b4a65d4167d5c5e587fc0"}, "downloads": -1, "filename": "pjrpc-1.0.0.tar.gz", "has_sig": false, "md5_digest": "2821c7a4a5a215aa4b16f21d1f92c41f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 36875, "upload_time": "2020-03-14T18:35:42", "upload_time_iso_8601": "2020-03-14T18:35:42.597217Z", "url": "https://files.pythonhosted.org/packages/0e/cc/4e40d6ed89f6b21a3a9a89190c64cba17ee9fdc96204a8b872362f3a6757/pjrpc-1.0.0.tar.gz"}], "1.1.0": [{"comment_text": "", "digests": {"md5": "87164e8d9f15a4774f00836b494e3205", "sha256": "9a66e6ed58b7bad578a02d5c301492ec5cccdbfc2c6fcad8415e94ccfa17c00e"}, "downloads": -1, "filename": "pjrpc-1.1.0.tar.gz", "has_sig": false, "md5_digest": "87164e8d9f15a4774f00836b494e3205", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 38349, "upload_time": "2020-03-28T08:43:59", "upload_time_iso_8601": "2020-03-28T08:43:59.982460Z", "url": "https://files.pythonhosted.org/packages/0e/03/75bd01a34d37e831da09388a6821bf4fdffaca3a079eee842b426196624b/pjrpc-1.1.0.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "87164e8d9f15a4774f00836b494e3205", "sha256": "9a66e6ed58b7bad578a02d5c301492ec5cccdbfc2c6fcad8415e94ccfa17c00e"}, "downloads": -1, "filename": "pjrpc-1.1.0.tar.gz", "has_sig": false, "md5_digest": "87164e8d9f15a4774f00836b494e3205", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 38349, "upload_time": "2020-03-28T08:43:59", "upload_time_iso_8601": "2020-03-28T08:43:59.982460Z", "url": "https://files.pythonhosted.org/packages/0e/03/75bd01a34d37e831da09388a6821bf4fdffaca3a079eee842b426196624b/pjrpc-1.1.0.tar.gz"}]}
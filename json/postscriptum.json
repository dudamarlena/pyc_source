{"info": {"author": "", "author_email": "", "bugtrack_url": null, "classifiers": [], "description": "Postscriptum: an intuitive and unified API to run code when Python exit\n========================================================================\n\n.. warning::\n    While the code is considered functional and I used it in my projects,\n    the API is not complete and may change until we reach 1.0.\n\nPostscriptum wraps ``atexit.register``, ``sys.excepthook`` and ``signal.signal`` to lets you do:\n\n::\n\n    import postscriptum\n    watch = postscriptum.setup() # do this before creating a thread or a process\n\n    @watch.on_finish() # don't forget the parenthesis !\n    def _(context):\n        print(\"When the program finishes, no matter the reason.\")\n\n    @watch.on_terminate()\n    def _(context):  # context contains the signal that lead to termination\n        print(\"When the user terminates the program. E.G: Ctrl + C, kill -9, etc.\")\n\n    @watch.on_crash()\n    def _(context): # context contains the exception and traceback\n        print(\"When there is an unhandled exception\")\n\nAll those functions will be called automatically at the proper moment. The handler for ``on_finish`` will be called even if another handler has been called.\n\nIf the same function is used for several events:\n\n::\n\n    @watch.on_finish()\n    @watch.on_terminate()\n    def t(context):\n        print('woot!')\n\nIt will be called only once.\n\nIf several functions are used as handlers for the same event:\n\n::\n\n    @watch.on_terminate()\n    def _(context):\n        print('one!')\n\n    @watch.on_terminate()\n    def _(context):\n        print('two!')\n\nThe two functions will be called. Hooks from code not using postscriptum will be preserved by default for exceptions and atexit.  Hooks from code not using postscriptum for signals are replaced. They can be restored using watch.restore_hooks().\n\nYou can also react to ``sys.exit()`` and manual raise of ``SystemExit``:\n\n::\n\n    @watch.on_quit()\n    def _(context):  # context contains the exit code\n        print('Why me ?')\n\nBUT for this you MUST use the watcher as a decorator:\n\n::\n\n    @watch()\n    def main():\n        do_stuff()\n\n    main()\n\nOr as a context manager:\n\n::\n\n    with watch():\n        do_stuff()\n\n\nAll decorators are stackable. If you use other decorators than the ones from postcriptum, put postcriptum decorators at the top:\n\n::\n\n    @watch.on_quit()\n    @other_decorator()\n    def handler(context):\n        pass\n\nAlternatively, you can add the handler imperatively:\n\n::\n\n    @other_decorator()\n    def handler(context):\n        pass\n\n``watch.add_quit_handler(handler)``. All ``on_*`` method have their imperative equivalent.\n\nThe context is a dictionary that can contain:\n\nFor ``on_crash`` handlers:\n\n- **exception_type**: the class of the exception that lead to the crash\n- **exception_value**: the value of the exception that lead to the crash\n- **exception_traceback**: the traceback at the moment of the crash\n- **previous_exception_hook**: the callable that was the exception hook before we called setup()\n\nFor ``on_terminate`` handlers:\n\n- **signal**: the number representing the signal that was sent to terminate the program\n- **signal_frame**: the frame state at the moment the signal arrived\n- **previous_signal_hook**: the signal handler that was set before we called setup()\n- **recommended_exit_code**: the polite exit code to use when exiting after this signal\n\nFor ``on_quit`` handlers:\n\n- **exit_code**: the code passed to ``SystemExit``/``sys.exit``.\n\nFor ``on_finish`` handlers:\n\n- The contex is empty if the program ends cleanly, otherwise,\n  it will contain the same entries as one of the contexts above.\n\n\nCurrently, postscriptum does not provide a hook for\n\n- ``sys.unraisablehook``\n- exception occuring in other threads (``threading.excepthook`` from 3.8 will allow us to do that later)\n- unhandled exception errors in unawaited asyncio (not sure we should do something though)\n\n.. warning::\n    You must be very careful about the code you put in handlers. If you mess up in there,\n    it may give you no error message!\n\n    Test your function without being a hook, then hook it up.\n\n\nInstall\n--------\n\nIt's on pypi::\n\n    pip install postscriptum\n\n\n\nWhy this lib ?\n----------------\n\nPython has 3 very different API to deal with exiting, and they all have their challenges:\n\n- **atexit**: the handler is always called, weither python exited cleanly or not, which can lead do duplicated calls. Except if you get a SIGTERM signal when it's silently ignored. Even whell called, it doesn't give any information on the cause of the exit.\n- **signal**: to you capture terminating signals, you need to know which ones to watch for (and they differ depending of the OS). Normal behavior is to exit, but if you set your handler, the program will not exit unless you call sys.exit(). Finally, you can only have one handler for each signal.\n- **sys.excepthool** is called on all exception, but not SystemExit. It also leads to hard to debug errors if you don't call the previous hook properly. And you can have only one handler.\n\nAlso, there is no automatic way to react to ``sys.exit()``. And no way to distinguish ``SystemExit`` from ``sys.exit()``, which you need for signals.\n\nPostscriptum doesn't deal with the last goatchas yet:\n\n- signals are caught by childs and passed to the main threads, but not exceptions.\n- messing up in your handler may cause you to have no error message at all.\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "postscriptum", "package_url": "https://pypi.org/project/postscriptum/", "platform": "", "project_url": "https://pypi.org/project/postscriptum/", "project_urls": null, "release_url": "https://pypi.org/project/postscriptum/0.2/", "requires_dist": null, "requires_python": "", "summary": "An intuitive and unified API to run code when Python exit", "version": "0.2"}, "last_serial": 6934424, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "6e260ba633b2226d41e0c2f5a890a591", "sha256": "fc785dce7091ffb717af9d5b4b1577f0b9f0fd4d73a31c96cf40dd80bb7bbc5c"}, "downloads": -1, "filename": "postscriptum-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "6e260ba633b2226d41e0c2f5a890a591", "packagetype": "bdist_wheel", "python_version": "3.7", "requires_python": null, "size": 6898, "upload_time": "2020-04-01T16:06:33", "upload_time_iso_8601": "2020-04-01T16:06:33.911566Z", "url": "https://files.pythonhosted.org/packages/b0/cb/7b12f9c83c83498e3d8ed91dc02af1f1f90f72649c259af3443648e276a2/postscriptum-0.1-py3-none-any.whl"}], "0.2": [{"comment_text": "", "digests": {"md5": "d082dfbf631927c017754bfde72cf783", "sha256": "00ad433b90d80b279cb61a1e352c0a6ad860d9e53dc001b3ea1b60d67f2efdfd"}, "downloads": -1, "filename": "postscriptum-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "d082dfbf631927c017754bfde72cf783", "packagetype": "bdist_wheel", "python_version": "3.7", "requires_python": null, "size": 8846, "upload_time": "2020-04-02T09:40:07", "upload_time_iso_8601": "2020-04-02T09:40:07.803061Z", "url": "https://files.pythonhosted.org/packages/b6/1c/57087e2b2da42962c3c0eeb69ef58b581c72825cd4c8945e7539b839a2df/postscriptum-0.2-py3-none-any.whl"}]}, "urls": [{"comment_text": "", "digests": {"md5": "d082dfbf631927c017754bfde72cf783", "sha256": "00ad433b90d80b279cb61a1e352c0a6ad860d9e53dc001b3ea1b60d67f2efdfd"}, "downloads": -1, "filename": "postscriptum-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "d082dfbf631927c017754bfde72cf783", "packagetype": "bdist_wheel", "python_version": "3.7", "requires_python": null, "size": 8846, "upload_time": "2020-04-02T09:40:07", "upload_time_iso_8601": "2020-04-02T09:40:07.803061Z", "url": "https://files.pythonhosted.org/packages/b6/1c/57087e2b2da42962c3c0eeb69ef58b581c72825cd4c8945e7539b839a2df/postscriptum-0.2-py3-none-any.whl"}]}
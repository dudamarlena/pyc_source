{"info": {"author": "Mark Eklund", "author_email": "magic_dot@patnan.com", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "Magic Dot\n*********\n\n\n.. image:: https://img.shields.io/pypi/v/magic_dot.svg\n        :target: https://pypi.python.org/pypi/magic_dot\n\n.. image:: https://github.com/bonafideduck/magic_dot/workflows/Sanity/badge.svg\n        :target: https://github.com/bonafideduck/magic_dot/actions?query=branch%3Amaster+workflow%3A%22Sanity%22\n\n.. image:: https://readthedocs.org/projects/magic-dot/badge/?version=latest\n        :target: https://magic-dot.readthedocs.io/en/latest/?badge=latest\n        :alt: Documentation Status\n\n\n\n\nLibrary that allows deep extraction of layered data structures (like JSON).\n\n\n* Free software: BSD license\n* Documentation: https://magic-dot.readthedocs.io.\n\n\nIntroduction\n============\n\nMagic Dot delays the extraction of data to when you are ready of it.  It\nworks best with structured data like JSON.  Consider the following simplified JSON \nsnipppet curl https://api.github.com/events: ::\n\n  import json\n  data = json.loads(\"\"\"\n    [\n      {\n        \"type\": \"PushEvent\",\n        \"payload\": {\n          \"commits\": [\n            {\n              \"author\": {\n                \"name\": \"Bubba\"\n    }}]}}]\n  \"\"\")\n\n``magic_dot`` has a process of wrapping the data for easier extraction without\nthe need for complex ``setdefault`` or ``try:`` ``except``.  For example, to\nretrieve the first name of the first commit, you would do the following: ::\n\n  from magic_dot import MagicDot, NOT_FOUND\n  md = MagicDot(data)\n  md[0].payload.commits[0].author.name.get()\n  if name is NOT_FOUND:\n    print(\"handle error\")\n  else:\n    print(\"success\")\n\nSince the incoming JSON can't be trusted, without magic_dot, you have to verify that \neach layer is there.  This can be done with a ``try:`` ``except``, nearly as\nefficiently, but it is more verbose. ::\n\n  try:\n    name = md[0]['payload']['commits'][0]['author']['name']\n  except (IndexError, KeyError):\n    print(\"handle error\")\n  else:\n    print(\"success\")\n\nIn the above instance, it is a tossup between MagicDot and ``try:`` ``except``.\nOther features, like list extraction, default handling, selective exceptions,\nand attributes support can lead to cleaner code.\n\nFeatures\n========\n\nFor all the code examples, we will assume the following code has already been run: ::\n\n  import json\n  from magic_dot import MagicDot, NOT_FOUND\n  from magic_dot.exceptions import NotFound\n  data = json.loads(\"\"\"\n    [\n      {\n        \"type\": \"PushEvent\",\n        \"payload\": {\n          \"commits\": [\n            {\n              \"author\": {\n                \"name\": \"Bubba\"\n    }}]}}]\n  \"\"\")\n  md = MagicDot(data)\n\nForgiving NOT_FOUND Handling\n----------------------------\n\nManipulations of the MagicDot structure will raise no exceptions\nwhen one of the attributes or keys are not found.  Instead it delays\nthis until the ``get()`` call that extracts the data at the end.\nWhen the ``get()`` is called, there are three ways of handling\nmissing data:\n\n**Default is to return magic_dot.NOT_FOUND** ::\n\n  In [1]: md.nonexistent.get()\n  Out[1]: magic_dot.NOT_FOUND\n\n**You can request a default value for magic_dot.NOT_FOUND** ::\n\n  In [2]: md.nonexistent.get('bubba')\n  Out[2]: 'bubba'\n\n**Or raise an exception for NOT_FOUND** ::\n\n    In [3]: md.exception().nonexistent.get()\n    ---------------------------------------------------------------------------\n    NotFound                                  Traceback (most recent call last)\n\nExceptions are not enabled by default.  They can be enabled during creation\nI.E ``MagicDot(data, exception=True)`` and switched on and off with the \n``MagicDot::exception(exception=True)`` method.\n\nDict and List Item Handling\n---------------------------\n\nWhen a `md[item]` is encountered, data will be extracted as follows:\n\n1. If ``md.__data[item]`` exists, that is used.\n2. If ``md.__data.item`` attribute exists it is used.\n3. If `lists` is enabled and item is not an int, lists will be searched (see List Support below).\n4. Otherwise ``md.NOT_FOUND`` is assigned to the resulting ``md.__data``.\n\nAttribute Handling\n------------------\n\nWhen a ``md.key`` is supplied data will be extracted as follows:\n\n1. If ``md.__data.key`` attribute exists it is used.\n2. If ``md.__data[key]`` item exists, it is used.\n3. If `lists` is enabled, lists will be search (see List Support below).\n4. Otherwise ``md.NOT_FOUND`` is assigned to the resulting ``md.__data``.\n\nList Support\n------------\n\nWhen ``MagicDot(data, lists=True)`` is enabled (which is the default), extra\nlist support is enabled.  Please note that the **lists** is short for **list s**\\upport\nand not multiple lists.  With list support, if a attribute or item access would return NOT_FOUND\nand the data is a list, the contents of that list will be searched using attribute(see above).\nIf anything is found, then a list will be returned.\n\nAs an example, given this data: ::\n\n  In [1]: from collections import namedtuple\n  In [2]: data = [1, {'x': 2}, namedtuple('x', 'x')(3)]\n  In [3]: data[0]\n  Out[3]: 1\n  In [4]: data[1]['x']\n  Out[4]: 2\n  In [5]: data[2].x\n  Out[5]: 3\n\nThe following will be returned with the first item not expanding becuase it is an integer. ::\n\n  In [6]: md = MagicDot(data)\n  In [7]: md.x.data()\n  Out[7]: [magic_dot.NOT_FOUND, 2, 3]\n\nWith list processing disabled, ``NOT_FOUND`` will be returned. ::\n\n  In [6]: md = MagicDot(data, lists=False)\n  In [7]: md.x.get()\n  Out[7]: magic_dot.NOT_FOUND\n\nIf a default is supplied for the get, the ``NOT_FOUND``\\(s) in the underlying lists will be expanded. ::\n\n  In [6]: md = MagicDot(data)\n  In [7]: md.x.get('bubba')\n  Out[7]: ['bubba', 2, 3]\n\nIf data is referenced with list processing, but list procesing is turned off before\nthe ``get()``, the list ``NOT_FOUNDS``\\(s) will not be replaced. ::\n\n  In [6]: md = MagicDot(data)\n  In [7]: md.x.lists(False).get('bubba')\n  Out[7]: [magic_dot.NOT_FOUND, 2, 3]\n\nFuture Enhancement\n==================\n\nThese are some ideas that may be added in future versions:\n\n* ``.compact(remove=[NOT_FOUND, None])``: removes MagicDot list items that are ``NOT_FOUND`` or ``None``\n* ``.sort(key=None, reverse=False)``: returns MagicDot with a new sorted list\n* ``.delete_if(func)``: Returns a new MagicDot with anything in delete removed if true.\n* ``.find(func)``: Returns a new MagicDot with the first match.\n* ``.uniq()``: Returns uniq list values.\n* I.E. a wide variaty of variations like `Underscore js`_ or `Ruby Arrays`_\n\n.. _`Underscore js`: https://underscorejs.org/#arrays\n.. _`Ruby Arrays`: https://ruby-doc.org/core-2.7.0/Array.html\n\n\nCredits\n=======\n\nThis package was created with Cookiecutter_ and the `audreyr/cookiecutter-pypackage`_ project template.\n\n.. _Cookiecutter: https://github.com/audreyr/cookiecutter\n.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage\n\n\nHistory\n*******\n\n0.1.1 (2020-03-19)\n==================\n\n* No significant chagnes.  Testing github release automations.\n\n0.1.0 (2020-03-19)\n==================\n\n* First release on PyPI.\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/bonafideduck/magic_dot", "keywords": "magic_dot", "license": "BSD license", "maintainer": "", "maintainer_email": "", "name": "magic-dot", "package_url": "https://pypi.org/project/magic-dot/", "platform": "", "project_url": "https://pypi.org/project/magic-dot/", "project_urls": {"Homepage": "https://github.com/bonafideduck/magic_dot"}, "release_url": "https://pypi.org/project/magic-dot/0.1.1/", "requires_dist": null, "requires_python": ">=3.5", "summary": "Library that allows deep extraction of layered data structures (like JSON).", "version": "0.1.1"}, "last_serial": 6846438, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "40225cb630158360a3bc9cbf11a2cbd6", "sha256": "fa16b97ee56f826a7b53a3bf2824a936c0d4d83ce7cfebf509747f7c524cd671"}, "downloads": -1, "filename": "magic_dot-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "40225cb630158360a3bc9cbf11a2cbd6", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.5", "size": 6972, "upload_time": "2020-03-19T17:31:03", "upload_time_iso_8601": "2020-03-19T17:31:03.483747Z", "url": "https://files.pythonhosted.org/packages/25/ce/e0cb33e9f1f1205c88ebf76d28e214729aef3091f740ac0f58fd47b5b918/magic_dot-0.1.0-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "074bb6fad9f5832e9d3e2bfd49e1250f", "sha256": "d78bd0ce4c32e30f3212b32487e87a5a8c13751a516b766c991ffb6d2f97f2fc"}, "downloads": -1, "filename": "magic_dot-0.1.0.tar.gz", "has_sig": false, "md5_digest": "074bb6fad9f5832e9d3e2bfd49e1250f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 20428, "upload_time": "2020-03-19T17:31:06", "upload_time_iso_8601": "2020-03-19T17:31:06.008124Z", "url": "https://files.pythonhosted.org/packages/48/21/b7468af9049e01da8136b1705af7ac55d02b7852afbb28829e879ac9120e/magic_dot-0.1.0.tar.gz"}], "0.1.1": [{"comment_text": "", "digests": {"md5": "843b6146f3920a237eafde0615e8083e", "sha256": "33b2a4e45426ff9e3d45a42726896a4369cff8260ddc5ffed5a66537d809db22"}, "downloads": -1, "filename": "magic_dot-0.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "843b6146f3920a237eafde0615e8083e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.5", "size": 7047, "upload_time": "2020-03-19T22:08:42", "upload_time_iso_8601": "2020-03-19T22:08:42.094013Z", "url": "https://files.pythonhosted.org/packages/f8/a5/3d5773154b8d524b8063e6b0a8f733880c4de49525fef8b3a81407572a91/magic_dot-0.1.1-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "76b0a9118c17ce5b331dbaa8ead1f2ac", "sha256": "44db0e5f9eb43c45eeae23f67c5727ef3b3db251af76dec4cf43119f563ae7dc"}, "downloads": -1, "filename": "magic_dot-0.1.1.tar.gz", "has_sig": false, "md5_digest": "76b0a9118c17ce5b331dbaa8ead1f2ac", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 20632, "upload_time": "2020-03-19T22:08:43", "upload_time_iso_8601": "2020-03-19T22:08:43.469134Z", "url": "https://files.pythonhosted.org/packages/9b/f6/5a3422c20fa276edbc6c38d0a48f76f9b6ce5efaa52047dd193428c0d678/magic_dot-0.1.1.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "843b6146f3920a237eafde0615e8083e", "sha256": "33b2a4e45426ff9e3d45a42726896a4369cff8260ddc5ffed5a66537d809db22"}, "downloads": -1, "filename": "magic_dot-0.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "843b6146f3920a237eafde0615e8083e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.5", "size": 7047, "upload_time": "2020-03-19T22:08:42", "upload_time_iso_8601": "2020-03-19T22:08:42.094013Z", "url": "https://files.pythonhosted.org/packages/f8/a5/3d5773154b8d524b8063e6b0a8f733880c4de49525fef8b3a81407572a91/magic_dot-0.1.1-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "76b0a9118c17ce5b331dbaa8ead1f2ac", "sha256": "44db0e5f9eb43c45eeae23f67c5727ef3b3db251af76dec4cf43119f563ae7dc"}, "downloads": -1, "filename": "magic_dot-0.1.1.tar.gz", "has_sig": false, "md5_digest": "76b0a9118c17ce5b331dbaa8ead1f2ac", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 20632, "upload_time": "2020-03-19T22:08:43", "upload_time_iso_8601": "2020-03-19T22:08:43.469134Z", "url": "https://files.pythonhosted.org/packages/9b/f6/5a3422c20fa276edbc6c38d0a48f76f9b6ce5efaa52047dd193428c0d678/magic_dot-0.1.1.tar.gz"}]}
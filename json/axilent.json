{"info": {"author": "Ben Reynwar", "author_email": "ben@reynwar.net", "bugtrack_url": null, "classifiers": [], "description": ".. image:: https://travis-ci.org/benreynwar/axilent.svg?branch=master\n               :target: https://travis-ci.org/benreynwar/axilent\n\naxilent\n=======\n\naxilent provides python tools for describing a sequence of Axi4Lite command\nin python.\n\nA python test can be written describing the sequence of commands to be sent\nand the expected responses.  This test can then be run against both a\nsimulation of the design and against the implemented design running on an\nFPGA.\n\naxilent is structured so that tests can be run both against both interactive\nsimulations and simulations where inputs cannot depend on outputs such as\nfile-based testbenchs.\n\n\nHandlers\n--------\n\nCurrently there is `handler` for working with file-based testbenchs\ngenerated by `slvcodec <https://github.com/benreynwar/slvcodec>`_ and\nfor simulations on FPGAs run over JTAG using\n`pyvivado <https://github.com/benreynwar/pyvivado>`_.\nIn the likely event you are using neither of these methods, then you\nwill have to write you own handler. The handler has a single required\nmethod.\n\nhandler.send(command)\n    Sends a command to the FPGA, or adds the command to the list of commands that\n    will be run in the simulation.\n\nThe handler also processes the responses from the simulation or FPGA and updates the\n`command.future` values appropriately.  It calls the `command.process_responses` method\nto help process the responses.\n\n\nCommands\n--------\nA `Command` object represents a simple axi4lite read or write, or a more complex\naggregrate consisting of many read and write commands.\n\ncommand.get_axi_commands()\n    Returns a list of `AxiCommand` objects.  Each `AxiCommand` object is a simple\n    axi4lite read or write command to a single address or a range of addresses.\n\ncommand.process_responses(read_responses, write_responses, resolve_future)\n    Processes two lists of `AxiResponse` objects, one is a list of responses to\n    write requests and one is a list of responses to read requests.  The two lists\n    must begin with the responses to this command, and these entries are removed\n    from the lists.\n    An (exception, result) tuple is returned by the function.  If `resolve_future`\n    is True then the commands future is resolved with the result and exception.\n\nAs an example consider an AxiAdder module, which uses an Axi4Lite interface.  We can\nwrite to registers A and B, and when we read from register C the returned result is\nthe sum of the contents in regsiters A and B.  We can create a `Command` object to\nrepresent using this hardware to add two numbers.\n\n.. code:: python\n\n    class AddNumbersCommand(comms.CombinedCommand):\n        '''\n        A command that writes to the intA and intB registers\n        and then reads from the intC register.\n        The effect is the add the two inputs.\n        '''\n\n        def __init__(self, a, b, addresses):\n            write_a_command = comms.SetUnsignedCommand(\n                address=addresses['intA'], value=a,\n                description='Setting A in AddNumbers',\n            )\n            write_b_command = comms.SetUnsignedCommand(\n                address=addresses['intB'], value=b,\n                description='Setting B in AddNumbers',\n            )\n            read_c_command = comms.GetUnsignedCommand(\n                address=addresses['intC'],\n                description='Getting C from AddNumbers',\n            )\n            commands = (write_a_command, write_b_command, read_c_command)\n            super().__init__(\n                description='Add 2 numbers with AddNumber',\n                commands=commands)\n\n        def process_responses(self, read_responses, write_responses, resolve_future=True):\n            '''\n            Return the third response (from the final read command)\n            Don't return any errors.\n            '''\n            e, result = super().process_responses(read_responses, write_responses, resolve_future=False)\n            intc = result[2]\n            if resolve_future:\n                self.resolve_future(e, intc)\n            return e, intc\n\n\n\nComm\n----\nTypically command objects are hidden from the testing interface by wrapping them\nwith a Comm object.  Methods on this comm object create `Command` objects, send\nthem to a handler, and return the command futures.\n\n.. code:: python\n\n    class AxiAdderComm:\n        '''\n        Class to communicate with the AxiAdder module.\n        '''\n\n        INTA_ADDRESS = 0\n        INTB_ADDRESS = 1\n        INTC_ADDRESS = 2\n\n        def __init__(self, address_offset, handler):\n            '''\n            `address_offset` is any addition that is made to the address that is\n            consumed during routing.\n            `handler` is the object responsible for dispatching the commands.\n            '''\n            self.handler = handler\n            self.address_offset = address_offset\n            self.addresses = {\n                'intA': address_offset + self.INTA_ADDRESS,\n                'intB': address_offset + self.INTB_ADDRESS,\n                'intC': address_offset + self.INTC_ADDRESS,\n            }\n\n        def add_numbers(self, a, b):\n            '''\n            A complex complex command that write to two registers and\n            then reads from another.\n            Sets 'a' and 'b' then reads 'c' (should be a+b)\n            '''\n            command = AddNumbersCommand(a, b, self.addresses)\n            self.handler.send(command)\n            return command.future\n\nTests\n-----\nA possible way to write a test to is define a class with a `prepare` method that\ndefines the requests to send to the module, and a `check` method that analyzes\nthe responses.\n\nThe `prepare` method uses a `handler` to generate the requests and creates a\nnumber of futures to hold the results of processing the responses.\n\nThe responses are then processed by a handler-dependent method and then the\n`check` method can be run to check the contents of the resolved futures.\n\n.. code:: python\n\n    class AxiAdderTest(object):\n\n        def __init__(self):\n            self.expected_intcs = []\n            self.intc_futures = []\n\n        def prepare(self, handler):\n            '''\n            Sends a number of 'add_numbers' commands.\n            '''\n            comm = AxiAdderComm(address_offset=0, handler=handler)\n            n_data = 20\n            max_int = pow(2, 16)-1\n            logger.debug('preparing data')\n            for i in range(n_data):\n                inta = random.randint(0, max_int)\n                intb = random.randint(0, max_int)\n                self.expected_intcs.append(inta + intb)\n                future = comm.add_numbers(inta, intb)\n                self.intc_futures.append(future)\n            # Flush the communication for simulations.\n            # Ignored in FPGA.\n            handler.send(comms.FakeWaitCommand(clock_cycles=10))\n\n        def check(self):\n            '''\n            Check that the output of the commands matches the expected values.\n            '''\n            output_intcs = [f.result() for f in self.intc_futures]\n            assert output_intcs == self.expected_intcs\n            print('Success!!!!!!!!!!!!!!!')\n\n\n\nRepeatability of Simulations\n----------------------------\nAlthough the simulations are repeatable the FPGA-based tests are currently not\nrepeatable because of the changing number of clock-cycles between when requests\nare received.\nI would like to fix this by allowing the ability of specify on which clock\ncycle at AXI request should be sent (they would be gathered in a delayed in a buffer\non the FPGA until the correct clock cycle).\nTODO: Add delaying of requests to allow repeatability.\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/benreynwar/axilent", "keywords": "VHDL,hdl,rtl,FPGA,ASIC,Xilinx,Altera", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "axilent", "package_url": "https://pypi.org/project/axilent/", "platform": "", "project_url": "https://pypi.org/project/axilent/", "project_urls": {"Homepage": "https://github.com/benreynwar/axilent"}, "release_url": "https://pypi.org/project/axilent/0.1.5/", "requires_dist": ["jinja2 (>=2.8)", "pytest", "slvcodec (>=0.3.5)"], "requires_python": "", "summary": "Tools for describing a sequence of Axi4Lite commands.", "version": "0.1.5"}, "last_serial": 6100487, "releases": {"0.1.3": [{"comment_text": "", "digests": {"md5": "54ace4684e92f286ff580a72bb96a589", "sha256": "d97f6b3fd3fffe5dfac611a929b6f253dbdc759ac8318bd919248a861cf28f44"}, "downloads": -1, "filename": "axilent-0.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "54ace4684e92f286ff580a72bb96a589", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17331, "upload_time": "2019-03-11T22:39:52", "upload_time_iso_8601": "2019-03-11T22:39:52.158357Z", "url": "https://files.pythonhosted.org/packages/14/d9/ff94095de39c558124cdf328bba0114c80a0c3196b133f63ba4b1ae017f0/axilent-0.1.3-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "4f1c2d0057a7576c3a0c75d0cb0d615e", "sha256": "43b61530f612ed2e1b4e5b50673fcdfab3f230ade6af6979809fe9c2e082943c"}, "downloads": -1, "filename": "axilent-0.1.3.tar.gz", "has_sig": false, "md5_digest": "4f1c2d0057a7576c3a0c75d0cb0d615e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15696, "upload_time": "2019-03-11T22:39:54", "upload_time_iso_8601": "2019-03-11T22:39:54.414210Z", "url": "https://files.pythonhosted.org/packages/17/2a/048aca7238cec6ced95821be22a08099d3dcafb902087132f906cfa956bb/axilent-0.1.3.tar.gz"}], "0.1.4": [{"comment_text": "", "digests": {"md5": "a38fb8ce273e86e0697fa112a56b3840", "sha256": "c431ddf74473e731c7d042f530629cfd1356b187bcc323fb9030d4a4653e6e63"}, "downloads": -1, "filename": "axilent-0.1.4-py3-none-any.whl", "has_sig": false, "md5_digest": "a38fb8ce273e86e0697fa112a56b3840", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17967, "upload_time": "2019-03-12T02:17:15", "upload_time_iso_8601": "2019-03-12T02:17:15.184255Z", "url": "https://files.pythonhosted.org/packages/98/58/6969304386b9b5cca02a914308159398b5ef563005d7c1802060202a0e18/axilent-0.1.4-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "5ff700d01273e7e5594b83fe4c2da013", "sha256": "adfa09e1d4d497c6e450fc1111a42447be13e8860ace900dd8ab6701645fbfde"}, "downloads": -1, "filename": "axilent-0.1.4.tar.gz", "has_sig": false, "md5_digest": "5ff700d01273e7e5594b83fe4c2da013", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15704, "upload_time": "2019-03-12T02:17:16", "upload_time_iso_8601": "2019-03-12T02:17:16.382350Z", "url": "https://files.pythonhosted.org/packages/76/99/fca45fc816030e93aa4952a273c9bc779e85fe1eddbca88ba507e08134d6/axilent-0.1.4.tar.gz"}], "0.1.5": [{"comment_text": "", "digests": {"md5": "83c9dc65090de9031bef6bbae3f0fd04", "sha256": "1577e8cfac7b5f92540915b77cb3c01d6e62cd85f4feb2ba7c601b2d5705570f"}, "downloads": -1, "filename": "axilent-0.1.5-py3-none-any.whl", "has_sig": false, "md5_digest": "83c9dc65090de9031bef6bbae3f0fd04", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22669, "upload_time": "2019-11-08T17:27:15", "upload_time_iso_8601": "2019-11-08T17:27:15.878624Z", "url": "https://files.pythonhosted.org/packages/27/b3/f66eba4f89a8e5fba65f75d23aa6ca332a791b68083e222ef393e8dfd75f/axilent-0.1.5-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "fad4ec539b066c3fd8407d7b84a38968", "sha256": "2247ed0c189f61a070c6354de9e9b513df5940952d46bf8e9b811cb8aae993bc"}, "downloads": -1, "filename": "axilent-0.1.5.tar.gz", "has_sig": false, "md5_digest": "fad4ec539b066c3fd8407d7b84a38968", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22062, "upload_time": "2019-11-08T17:27:17", "upload_time_iso_8601": "2019-11-08T17:27:17.296891Z", "url": "https://files.pythonhosted.org/packages/39/c2/688a19f81688f8532a79e02469190f8b953c7100d62d96b6c205c1536b32/axilent-0.1.5.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "83c9dc65090de9031bef6bbae3f0fd04", "sha256": "1577e8cfac7b5f92540915b77cb3c01d6e62cd85f4feb2ba7c601b2d5705570f"}, "downloads": -1, "filename": "axilent-0.1.5-py3-none-any.whl", "has_sig": false, "md5_digest": "83c9dc65090de9031bef6bbae3f0fd04", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22669, "upload_time": "2019-11-08T17:27:15", "upload_time_iso_8601": "2019-11-08T17:27:15.878624Z", "url": "https://files.pythonhosted.org/packages/27/b3/f66eba4f89a8e5fba65f75d23aa6ca332a791b68083e222ef393e8dfd75f/axilent-0.1.5-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "fad4ec539b066c3fd8407d7b84a38968", "sha256": "2247ed0c189f61a070c6354de9e9b513df5940952d46bf8e9b811cb8aae993bc"}, "downloads": -1, "filename": "axilent-0.1.5.tar.gz", "has_sig": false, "md5_digest": "fad4ec539b066c3fd8407d7b84a38968", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22062, "upload_time": "2019-11-08T17:27:17", "upload_time_iso_8601": "2019-11-08T17:27:17.296891Z", "url": "https://files.pythonhosted.org/packages/39/c2/688a19f81688f8532a79e02469190f8b953c7100d62d96b6c205c1536b32/axilent-0.1.5.tar.gz"}]}
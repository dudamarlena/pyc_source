{"info": {"author": "Larry Hastings", "author_email": "larry@hastings.org", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 3 :: Only"], "description": "# correlate\n\n## A clever brute-force correlator for kinda-messy data\n\n##### Copyright 2019-2020 by Larry Hastings\n\n\n## Overview\n\nLet's say you have two sets of data that really represent the same data,\njust in different forms.\nAs an example, maybe your first dataset is Wikipedia's list of all episodes of a TV\nshow, and your second dataset is a directory full of video files of\nthat TV show.  The episode *\"Neurostim\"* appears in both datasets but\nit's represented differently in each.\n\nNow let's say you want to match them up with each other--you want\nto match up the values in the first dataset with their equivalents\nin the second dataset. The thing is, it's real-world data--and\nit's probably a little messy.  Perhaps the two datasets aren't in\nthe exact same order.  And while some matches are obvious, others are less so.\nMaybe one dataset has some values not present in the other and vice-versa.\n\nWhat do you do?  Sure, you could correlate the two datasets by hand.\nBut what if the datasets are really big?\nAnd what do you do if they get updated?  Do you want to update the\ncorrelation by hand too?\n\n**correlate** solves this problem for you.  It correlates values between\ntwo messy but strongly-related datasets.\n\nHow it works: you submit your two datasets to\n**correlate**, showing it each value and the \"keys\" that map to that value.\nYou then set it to work.  It thinks for a while, then produces its best\nguess as to how to match the two sets.  And its best guess is... hey, that's\npretty good!\n\nIn essense, **correlate** uses the uniqueness of keys as clues to pair up\nits matches.  If there's a key present in both datasets, but it only maps\nto one value in each dataset, odds are good that those two values\nare an excellent match.\n\nThat's the basics, but **correlate** supports some advanced features:\n\n* A key mapping can optionally specify a *weight*.\n\n* You can map a key *multiple times.*\n\n* Keys can be *fuzzy keys,* keys that may only partially match each other.\n\n* The order of values can inform the matches.  This is called *ranking.*\n\n### Quick Start\n\nThis code:\n\n    import correlate\n\n    c = correlate.Correlator()\n    a, b = c.datasets\n\n    a.set(\"this\", \"greg\")\n    a.set(\"is\", \"greg\")\n    a.set(\"Greg\", \"greg\", weight=5)\n    a.set_keys(\"Carol over here\".split(), \"carol\")\n    a.set_keys(\"My name is Tony\".split(), \"tony\")\n    a.set_keys(\"Hi I'm Steve\".split(), \"steve\", weight=2)\n\n    b.set_keys(\"gosh my name is Greg\".split(), \"Greg\")\n    b.set_keys(\"Carol is my name\".split() , \"Carol\")\n    b.set_keys(\"Pretty sure I'm still Tony\".split(), \"Tony\")\n    b.set_keys(\"I'm Steve\".split(), \"Steve\")\n\n    result = c.correlate()\n    for match in result.matches:\n        print(f\"{match.score:1.3f} {match.value_a} -> {match.value_b}\")\n\nproduces this output:\n\n    5.750 greg -> Greg\n    3.800 steve -> Steve\n    1.286 carol -> Carol\n    1.222 tony -> Tony\n\n\n### A Real-Life Example\n\nThere's a podcast I like.  I download it as MP3 files\nusing an RSS feed, 1990s-style. But the metadata in the RSS\nfeed is junk--the episode titles are inconsistent,\nand the episode numbers are almost wholly absent.\n\nThis podcast also has a\nlist of episodes on its website. This data is *much* cleaner,\nincluding nice proper (unique!) episode numbers.  And it's easily\nscraped.  But it's still not perfect.\nThe two lists of episodes aren't exactly the same, and even the episodes\nthat are present in both are sometimes reordered.\n\nObviously, I want to take the MP3s from the RSS feed,\nand match them up with the nice clean metadata scraped from the website.\nThis gets me the best of both worlds.\n\nBut there are more than *six hundred* episodes of this\nparticular podcast!  Matching those by hand would be a *lot* of work.\nAnd we get a new episode every week.\nAnd sometimes they actually add back in old episodes, or update the\nmetadata on old episodes--changes which would mess up any hand-built\nordering.  And I might want to listen to more than one podcast from\nthis same website someday!\nSo I really didn't want to do all of this by hand.\n\nHappily, after applying just a bit of intelligence to the two\ndatasets, **correlate** did a perfect job.\n\n### Why correlate Works So Well\n\nThe insight that inspired **correlate** is this:\nunique keys in the two datasets are probably very good matches.\nLet's say the key `\"egyptian\"` maps to value *A1* in `dataset_a`\nand value *B1*  in `dataset_b`--and it *only* maps to those two\nvalues.  In that case, *A1* and *B1* are probably a match.\n\nThis leads to a virtuous cycle.\nLet's say the word `\"nickel\"` maps to two values in each of the\ntwo datasets: *A1* and *A2*, and *B1* and *B2*.\nWe could match those four values in two possible ways:\n*A1* -> *B1* and *A2* -> *B2*,\nor *A1* -> *B2* and *A2* -> *B1*.\nBut the key `\"egyptian\"` already showed that *A1* and *B1* are a\ngood match.  If we've already removed those two values from\nconsideration, we're left with *A2* -> *B2*.\nAnd now *that* looks like a good match, too.\n\nIn short, **correlate** capitalizes on the *relative uniqueness*\nof keys.\n\n\n## Getting Started With correlate\n\n### Requirements\n\n**correlate** requires Python 3.6 or newer.  It has no\nother dependencies.\n\nIf you want to run the **correlate** test suite,\nyou'll need to install the `rapidfuzz` package.\n\n\n### The High-Level Conceptual Model\n\nTo correlate two datasets with **correlate**,\nyou first create a `correlate.Correlator` object.\nThis object contains two members\n`dataset_a` and `dataset_b`; these represent\nthe two datasets you want to correlate.\n\nYou fill each dataset with *keys* and *values*.\n\nA *value* is (nearly) any Python object.\nEach value should represent one value from your dataset.\n**correlate** doesn't examine your values--they're completely\nopaque to **correlate**.\n\nA *key* is a Python object that represents some metadata\nabout a value.  Keys \"map\" to values; **correlate** examines\nkeys, using matching keys in the two datasets to\nmatch up the values between them.\n\nKeys are usually strings--for example, the individual words\nfrom the title of some movie, TV show, song, or book.\nBut keys don't have to be strings.  Instances of lots of\nPython data types can be used as keys.\n\nOnce you've filled in the `correlate.Correlator` object\nwith your data, you call its `correlate()` method.  This\ncomputes the matches.  It returns a\n`correlate.CorrelateResult` containing\nthose matches, and lists of any objects from\nthe two datasets that didn't get matched.\n\nThe matches are returned as a list of `correlator.CorrelatorMatch`\nobjects.  Each object contains three members:\n\n* `value_a`, a reference to an object from `dataset_a`,\n\n* `value_b`, a reference to an object from `dataset_b`,\n\n* and a floating-point `score`.\n\nEach `CorrelatorMatch` object tells you that\n**correlator** thinks that this `value_a`\nmaps to this `value_b`.  The `score` is a sort of mathematical\nconfidence level--it's a direct result of the keys and\nother metadata you provide to **correlate**.  The list of\nmatches is sorted by `score`--higher scores first, as higher\nscores represent higher confidence in the match.\n\nThat's the basics.  But **correlate** supports some very sophisticated\nbehavior:\n\n* When mapping a key to a value, you may specify an optional *weight*,\nwhich represents the relative importance of this key.  The default\nweight is 1.  Higher scores indicate a higher significance; a weight of\n2 tells **correlate** that this key mapped to this value is twice as\nsignificant.\n\n* A key can map to a value multiple times.  Each mapping can have its own weight.\n\n* If both datasets are ordered, this ordering can optionally influence the match scores.\n**correlate** calls this *ranking.*  Ranking is an attribute of values, not keys.\n\n* Keys can be \"fuzzy\", meaning two keys can be a partial match rather than a binary yes/no.\nFuzzy keys in **correlate** must inherit from a custom abstract base class called\n`correlate.FuzzyKey`.\n\n## Sample Code And infer_mv\n\nIf you want to get a feel for what it's like to work with **correlate**,\nthe package ships with some sample code you can inspect.  Take a look\nat the scripts in the `tests` and `utilities` directories.\n\nIn particular, `utilities` contains a script called `infer_mv`.\n`infer_mv` takes a source directory and a list of files and directories\nto rename, and produces a mapping from the former to the latter.\nIn other words, when you run it, you're saying\n\"here's a source directory and a list of files and directories to rename.\nFor each file in the list of things to rename, find the\nfilename in the source directory that most closely resembles that file,\nand rename the file so it's exactly like that other filename from the\nsource directory.\"  (If you ask `infer_mv` to rename a directory,\nit renames all the files and directories inside that directory, recursively.)\n\nThis is useful if, for example, you have a directory where\nyou've already renamed the files the way you you like them, but then\nyou get a fresh copy from somewhere.  Simply run `infer_mv` with your\nexisting directory as the \"source directory\" and the fresh copy\nas the \"files\".  `infer_mv` will figure out how to rename the\nfresh files so they have the filenames how you like them.\n\nNote that `infer_mv` doesn't actually do the work of renaming!\nInstead, `infer_mv` prints out a *shell script* that, if executed,\nperforms the renames.\nWhy?  It's always a good idea to check over the output of **correlate**\nbefore you commit to it.\n\nYou should use `infer_mv` like so:\n\n    % infer_mv ../old_path *\n    # look at output, if it's all fine run\n    % infer_mv ../old_path * | sh\n\nOr you can direct the output of `infer_mv` into a file, then\nedit the file, then execute that.  Or something else!\nWhatever works for you!\n\n\n## Terminology And Requirements\n\n### Values\n\nValues are Python objects that represent individual elements of your two\ndatasets.  **correlate** doesn't examine values, and it makes very few\ndemands on them.  Here are the rules for values:\n\n* Values must support `==`.\n* Value comparison must be *reflexive,* *symmetric,* *transitive,* and *consistent*.\n  For all these examples, `a` `b` and `c` represent values:\n    * *reflexive:* A value must always compare as equal to itself.  `a == a` must evaluate to `True`.\n    * *symmetric:* If `a == b` is `True`, then `b == a` must also be `True`.\n    * *transitive:* If `a == b` is `True`, and `b == c` is `True`, then `a == c` must also be `True`.\n    * *consistent:* If `a == b` is `True`, it must always be `True`,\n       and if `a == b` is `False` it must always be `False`.\n\n### Keys\n\nKeys are Python objects that **correlate** uses to find matches between\nthe two datasets.  If a key maps to a value in `dataset_a` and also\na value in `dataset_b`, those two values might be a good match.\n\nKeys must obey all the same rules as values.  In addition,\nkeys must be *hashable.*\n\n#### Exact Keys\n\nAn \"exact\" key is what **correlate** calls any key that isn't a \"fuzzy\" key.\nStrings, integers, floats, complex, `datetime` objects--they're all fine to use\nas **correlate** keys, and instances of many more types too.\n\nWhen considering matches, exact keys are binary--either they're an exact match\nor they don't match at all.  If you need to understand partial matches you'll have\nto use \"fuzzy\" keys.\n\n\n#### Fuzzy Keys\n\nA \"fuzzy\" key is a key that supports a special protocol for performing \"fuzzy\"\ncomparisons--comparisons where the result can represent imperfect or partial matches.\n\nTechnically speaking, a **correlate** \"fuzzy\" key\nis an instance of a subclass of `correlate.FuzzyKey`.  If a key is an instance of\na subclass of that base class, it's a \"fuzzy\" key, and if it isn't, it's an \"exact\" key.\n\nFuzzy keys must follow the rules for keys above.\nAlso, the type of your fuzzy keys must also obey the same rules as keys;\nthey must be hashable, they must support `==`,\nand their comparison must be reflexive, symmetric, transitive, and consistent.\n\nIn addition, fuzzy keys must support a method called `compare` with this signature:\n`self.compare(other)`.  `other` will be another fuzzy key of the same type.  Your `compare`\nfunction should return a number between (and including) `0` and `1`, indicating how close\na match `self` is to `other`.  If `compare` returns `1`, it's saying this is a perfect\nmatch, that the two values are identical; if it returns `0`, it's a perfect mismatch,\ntelling **correlate** that the two keys have nothing in common.\n\n**correlate** requires that `compare` also obey the four mathematical constraints required\nof comparisons between keys.  In the following rules, `a` and `b` are fuzzy keys of the\nsame type.  `compare` must conform to these familiar four rules:\n\n* *reflexive:* `a.compare(a)` must return `1` (or `1.0`).\n* *symmetric:* If `a.compare(b)` returns *x*, then `b.compare(a)` must also return *x*.\n* *transitive:* If `a.compare(b)` returns *x*, and `b.compare(c)` returns *x*,\n  then `a.compare(c)` must also return *x*.\n* *consistent:* If `a.compare(b)` returns *x*, it must *always* return *x*.\n\nIt's important to note: fuzzy keys of two *different* types are automatically\nconsidered different to each other.  **correlate** won't even bother calling\n`compare()` on them--it automatically assigns the comparison a fuzzy score of `0`.\nThis is true even for subclasses; if you declare `class MyFuzzyNumber(correlate.FuzzyKey)`\nand also `class MyFuzzyInteger(MyFuzzyNumber)`,\n**correlate** will never compare an instance of `MyFuzzyNumber` and `MyFuzzyKey`\nto each other--it automatically assumes they have nothing in common.\n\n(Internally\n**correlate** stores fuzzy keys of different types segregated from each other.\nThis is a vital optimization!)\n\nOn a related note, **correlate** may optionally never\n*actually* call `a.compare(a)`, either.  That is, if the exact same key\nmaps to a value in both `dataset_a` and `dataset_b`, **correlate**\nis permitted to skip calling `compare()` and instead automatically\nassign the comparison a fuzzy score of `1`.  **correlate** currently\ndoes this--but this is not guaranteed,\nas it's only a small optimization, and conditions may change.\n\n\n## API\n\n`Correlator(default_weight=1)`\n\n> The correlator class.  `default_weight` is the weight used\n> when you map a key to a value without specifying an explicit weight.\n\n`Correlator.dataset_a`\n\n`Correlator.dataset_b`\n\n> Instances of `Correlator.Dataset` objects representing the two sets of data you want to correlate.  Initially empty.\n\n`Correlator.datasets`\n\n> A list containing the two datasets: `[dataset_a, dataset_b]`\n\n\n`Correlator.correlate(*,\n            minimum_score=0,\n            score_ratio_bonus=1,\n            ranking=BestRanking,\n            ranking_bonus=0,\n            ranking_factor=0,\n            key_reuse_penalty_factor=1,\n            reuse_a=False,\n            reuse_b=False)`\n\n> Correlates the two datasets.  Returns a `correlate.CorrelatorResult` object.\n>\n> `minimum_score` is the minimum permissible score for a match.  It must be\n> greater than or equal to 0.\n>\n> `score_ratio_bonus` specifies the weight of a bonus awarded to a match based on the ratio of\n> the actual score computed between these two values divided by the maximum possible score.\n>\n> `ranking` specifies which approch to computing ranking **correlate** should use.\n> The default value of `BestRanking` means **correlate** will try all approaches\n> and choose the one with the highest cumulative score across all matches.\n> Other values include `AbsoluteRanking` and `RelativeRanking`.\n>\n> `ranking_bonus` specifies the weight of the bonus awarded to a match\n> based on the proximity of the two values in their respective datasets, as specified\n> by their rankings.  The closer the two values are to the same position in their\n> respective datasets, the higher a percentage of the `ranking_bonus` will be awarded.\n>\n> `ranking_factor` specifies the ratio of the base score of a match that is multiplied\n> by the proximity of the two values in their respective datasets.  If you ues `ranking_factor=0.4`,\n> then a match only automatically keeps 60% of its original score; some percentage\n> of the remaining 40% will be re-awarded based on the proximity of the two values.\n>\n> (You can't use both a nonzero `ranking_bonus` and a nonzero `ranking_factor` in the\n> same correlation.  Pick at most one!)\n>\n> `key_reuse_penalty_factor` is a multiplier applied to the score calculated\n> for a key each time a key is re-mapped to a value.  The second time a key is used,\n> its score is multiplied by `key_reuse_penalty_factor`; the third time,\n> by `key_reuse_penalty_factor**2`, and so on.\n> The default value of 1 means every use of a key gets the same score.\n> `key_reuse_penalty_factor` should be greater than or equal to 0, and less than or equal to 1.\n>\n> `reuse_a` permits values in `dataset_a` to be matched to more than one value in `dataset_b`.\n> `reuse_b` is the same but for values in `dataset_b` matching `dataset_a`.\n> If you set both reuse flags to True, the `correlate.CorrelatorResult.matches`\n> list returned will contain *every* possible match.\n\n`Correlate.Dataset()`\n\n> The class for objects representing a dataset.  Behaves somewhat like\n> a write-only dict.\n\n`Correlator.Dataset.set(key, value, weight=default_weight)`\n\n> Adds a new correlation.\n>\n> You can use `Dataset[key] = value` as a shortcut for `Dataset.set(key, value)`.\n\n`Correlator.Dataset.set_keys(keys, value, weight=default_weight)`\n\n> Map multiple keys to a single value, all using the same weight.\n> `keys` must be an iterable containing keys.\n\n`Correlator.Dataset.value(value, *, ranking=None)`\n\n> Annotates a value with extra metadata.  Currently only one metadatum\n> is supported: `ranking`.\n>\n> `ranking` represents the position of this value in the dataset,\n> if the dataset is ordered.  `ranking` should be an integer\n> representing the ranking; if this value is the 19th in the dataset,\n> you should supply `ranking=19`.\n\n`Correlator.str_to_keys(s)`\n\n> A convenience function.\n> Converts string `s` into a list of string keys using a reasonable approach.\n> Lowercases the string, converts some common punctuation into spaces, then splits\n> the string at whitespace boundaries.  Returns a list of strings.\n\n\n### Getting Good Results Out Of Correlate\n\nUnfortunately, you can't always expect perfect results with **correlate**\nevery time.  You'll usually have to play with it at least a little.\n\n#### Ranking\n\nNaturally, the first step with **correlate** is to plug in your data.\nI strongly encourage you to add ranking information if possible.\n\nIf the two datasets are ordered, and equivalent items should appear in\nroughly the same place in each of the two datasets, ranking information\ncan make a *sizeable* improvement in the quality of your matches.\nTo use ranking information, you set the `ranking` for each value in each dataset\nthat you can, and specify either `ranking_bonus` or `ranking_factor` when\nrunning `correlate()`.\nWhich one you use kind of depends on how much confidence you have in the\nordering of your datasets.  If you think your ranking information is pretty\naccurate, you should definitely use `ranking_factor`; this exerts a much\nstronger influence on the matches.\nIf you have a low confidence in the ordering of your datasets,\nchoose `ranking_bonus`, which only provides a little nudge.\n\n#### Minimum Score\n\nOnce you've plugged in all your data, you should run the correlation,\nprint out the result in sorted order with the best\nmatches on top, then scroll to the bottom and see what the *worst*\n5% or 10% of matches look like.\n\nIf literally all your matches are already perfect--congratulations!\nYou're *already* getting good results out of **correlate** and you\ncan stop reading here!  But if you're not that lucky, you've got more\nwork to do.\n\nThe first step in cleaning up **correlate's** output is usually\nto stop it from making bad matches by setting a `minimum_score`.\n\nWhen you have bad matches, it's usually because the two datasets don't map\nperfectly to each other.  If there's a value in `dataset_a` that really\nhas no good match in `dataset_b`, well, **correlate** doesn't really\nhave a way of knowing that.   So it may match that value to something\nanyway.\n\nLook at it this way: the goal of **correlate** is to find matches between\nthe two datasets.  If it's made all the good matches it can, and there's\nonly one item left in each of the the two datasets, and they have *anything*\nin common at all, **correlate** will match those two values together\nout of sheer desparation.\n\nHowever!  Bad matches like these tend to have a very low score.\nAnd usually all those bad matches are clumped together\nat the bottom.  There'll probably be an inflection point\nwhere the scores drop off significantly and the matches go from good to bad.\n\nThis is what `minimum_score` is for.  `minimum_score` tells **correlate**\nthe minimum permissible score for a match.  When you have a clump of bad\nmatches at the bottom, you simply set `minimum_score` to be somewhere\nbetween the highest bad match and the lowest good match--and\nyour problem is solved!\n\n(Technically, **minimum_score** isn't actually the *minimum* score.\nIt's ever-so-slightly *less* than the lowest\npermitted score.  As in, for a match to be considered viable, its score\nmust be *greater than* **minimum_score.**  The default value for\n**minimum_score** is 0, which means **correlate** will keep\nany match with a positive score.)\n\nUnfortunately it's hard to predict what to set `minimum_score` to in advance.\nIts value really depends on your data set--how many keys you have, how good\nthe matches are, what weights you're using, everything.  It's much more\nstraightforward to run the correlation, look over the output, find where the\ncorrelations turn bad, and set a minimum score.  With large data sets there's\ngenerally a sudden and obvious dropoff in score, associated with **correlate**\nmaking poor matches.  That makes it pretty easy: set the minimum score so it\nkeeps the last good match and forgets the rest.  But there's no predicting what\nthat score will be in advance--every data set is different, and it's really\nan emergent property of your keys and weights--so\nyou'll have to calibrate it correctly for each correlation you run.\n\n(Sometimes there are good matches mixed in with the bad ones at the bottom.\nWhen that happens, the first step is generally to fix *that,* so that the\nbad ones are all clumped together at the bottom.  I can't give any general-purpose\nadvice on what to do here; all I can say is, start experimenting with changes\nto your datasets.  Change your keys, adjust your weights, run the correlation\nagain and see what happens.  Usually when I do this, I realize something I can\ndo to improve the data I feed in to **correlate**, and I can fix the problem\nexternally.)\n\n#### Weights\n\nIf you're still not getting the results you want, the next adjustment you\nshould consider is increasing the weight of\nkeys that provide a clear signal.  If the datasets you're comparing\nhave some sort of unique identifier associated with each value--like\nan episode number, or release date--you should experiment with giving those\nkeys a heavier weight.  Heavily-weighted keys like this can help\n**correlate** zero in on the best matches right away.\n\nIt's up to you what that weight\nshould be; I sometimes use weights as heavy as 5 for super-important keys,\nwhich means this one single key will have the same weight as 5 normal\nkeys.  Note that a weight of 5 on the mapping in `dataset_a` and\n`dataset_b` means that, if those keys match, they'll have a base score\nof 25!  If that key only appears once in each dataset, that will almost\n*certainly* result in a match.\n\nBut weighting can be a dual-edged sword.  If your data has mistakes\nin it, a heavy weighting of this bad data magnifies those mistakes.  One bad\nheavily-weighted key on the wrong value can inflate the score of a bad match\nover the correct match.  And that can have a domino effect--if *A1* should match\nto *B1*, but it get mapped to *B43* instead, that means *B1* is probably\ngoing to get mismatched too.  Which deprives another value of its correct\nmatch.  And so on and so on and so on.\n\n#### Too-Common Keys\n\nSimilarly, if there are super-common keys that aren't going to help with\nthe correlation, consider throwing them away and not even feeding them in as\ndata.  Keys that map to most or all of the values in a dataset add little\nclarity, and will mainly serve just to make **correlate** slower.\nI usually throw away the word \"The\", and the name of the podcast or show.\n(When correlating filenames, I may throw away the file extension too.)\n\nThen again, often leaving them in won't hurt anything, and it can occasionally\nbe helpful!  The way **correlate** works, it considers multiple maps of a\nkey to a value as different things--if you map the key `\"The\"` to a value\ntwice, **correlate** understands that those are two separate mappings.\nAnd if there's only one value in each dataset that has two `\"The\"` mappings,\nthat can be a very strong signal indeed.  So it's really up to you.\nThrowing away largely-redundant keys is a speed optimization, but it\nshouldn't affect the quality of your matches.\n\n(The best of both worlds: for common keys, try throwing away the *first* one.)\n\n#### Check Your Inputs\n\nAs always, it's helpful to make sure your code is doing what you intend it to.\nSeveral times I've goofed up the mechanism I use to feed data sets into\n**correlate**; for example, instead of feeding in words as keys, I've occasionally\nfed in the individual characters in those words as keys.  (Like, instead of\nthe single key `\"booze\"`, I accidentally fed in the five keys\n`'b'`, `'o'`, `'o'`, `'z'`, and `'e'`.)\nHowever, the **correlate** algorithm works so well,\nit still did a shockingly good job!  (Though it was a *lot* slower.)\n\nI've learned to double-check that I'm inputting the mappings and weights I meant\nto, with a debugger or with turning on the debug print statements in **correlate**\nitself.  Making sure you gave **correlate** the right data can make it not only\nmuch more accurate, it might make it faster too!\n\n#### Normalize Strings\n\nWhen using strings as keys from real-world sources, I recommend you\n*normalize* the strings:\nlowercase the strings, remove most or all punctuation, break the strings up into\nindividual keys at word boundaries.  In the real world, punctuation\nand capitalization can both be inconsistent, so throwing it away can help\ndispel those sorts of inconsistencies.  **correlate**\nprovides a utility function called `correlate.str_to_keys()` that does this\nfor you--but you can use any approach you like.\n\nYou might also consider *interning* your strings.  In my limited experimentation\nthis provided a small but measurable speedup.\n\n#### Sharpen Your Fuzzy Keys\n\nIf you're using fuzzy keys, the most important thing you can do is *sharpen\nyour keys.*  Fuzzy string-matching libraries have a naughty habit of scoring\nnot-very-similar strings as not *that* much less than almost-exactly-the-same\nstrings.  If you give that data unaltered to **correlate,** that \"everything\nlooks roughly the same\" outlook will be reflected in your final results as\nmediocre matches.  In those cases it's best to force your fuzzy\nmatches to extremes.  The best technique is simply to have a minimum score\nfor fuzzy maches in these cases.  Squaring or cubing the resulting\nscore is also a cheap way to attenuate weaker fuzzy scores while preserving\nthe stronger fuzzy scores.\n\n\n### What Do These Scores Mean?\n\nThe scores you seee in the results are directly related to the data you\ngave to **correlate**.  The scores really only have as much or as\nlittle meaning as you assign to them.\n\nIf you don't enjoy the unpredictable nature of **correlate** scores,\nconsider calling `normalize()` on your Correlate result object.\nThis normalizes the scores as follows: the highest score measured\nwill be adjusted to 1.0, `minimum_score` will be adjusted to 0.0,\nand every other score will be adjusted linearly between those two.\n\nMathematically:\n\n    score = the original score for this match\n    highest_score = highest score of any match\n    minimum_score = the minimum_score passed in to correlate()\n    delta = highest_score - minimum_score\n    normalized_score = (score - minimum_score) / delta\n\n\n\n## The Algorithm\n\n> If the implementation is hard to explain, it's a bad idea.\n> --*The Zen Of Python* by Tim Peters\n\nAt the heart of **correlate** is a brute-force algorithm.  It's what\ncomputer scientists would call an **O**(n\u00b2) algorithm.\n\n**correlate** computes every possible \"match\"--every mapping of a value in\n`dataset_a` to a value in `dataset_b` where the two values have keys in common.\nFor exact keys, it uses set intersections to ignore pairs of values that have\nnothing in common, discarding early matches it knows will have a score of 0.\nSadly, it can't do that for fuzzy keys, which is why fuzzy keys tend to\nslow down  **correlate** even more.\n\nFor each key that matches between the two values, **correlate**\ncomputes a score.  It then adds all those scores together,\ncomputing the final cumulative score for the \"match\",\nwhich it may modifiy based on the various bonuses and factors.\nIt then iterates over these scores in sorted order, highest score first.\nFor every match where neither of the two values have been used\nin a match yet, it counts that as a \"match\" and adds it to the output.\n(This assumes `reuse_a` and `reuse_b` are both `False`.  Also, this\nis a little bit of an oversimplification; see the section about the\n*Match Boiler* below.)\n\nOne important detail: **correlate** is 100%\ndeterministic.  Randomness can creep in around the edges in Python\nprograms; for example, if you ever iterate over a dictionary,\nthe order you will see the keys will vary from run to run.\n**correlate** eliminates these sources of randomness.\nGiven the exact same inputs, it performs the same operations\nin the same order and produces the same result, every time.\n\nThere are a number of concepts involved with how the **correlate**\nalgorithm works, each of which I'll explain in exhausting detail\nin the following sub-sections.\n\n### Streamlined Data\n\nThe **correlate** datasets store data in a format designed\nto eliminate redundancy and be easy to modify.  But this representation\nis inconvenient for performing the actual correlate.  Therefore,\nthe first step is to reprocess the data into a \"streamlined\" format.\nThis is an internal-only implementation detail, and in fact the data\nis thrown away at the end of each correlation.  As an end-user you'll\nnever have to deal with it.  It's only documented here just in case you\never need to understand the implementation of **correlate**.\n\nThis streamlined data representation is an important optimization.\nIt greatly speeds up computing a match between two values.  And it\nonly costs a little overhead, compared to all that matching work.\nConsider: if you have 600 values in `dataset_a` and 600 values in\n`dataset_b`, **correlate** will recompute 1,200 streamlined datasets.\nBut it'll then use it in as many as 360,000 comparisons!   That's\nwhy precomputing the streamlined format is such a big win.\n\nSpeaking of internal representations of data...\n\n### Rounds\n\nIf you call **correlate** as follows:\n\n    c = correlate.Correlator()\n    o = object()\n    c.dataset_a.set('a', o)\n    c.dataset_a.set('a', o)\n\nthen key `'a'` really *is* mapped to value `o` twice,\nand those two mappings can have different weights.\nIt's best to think of repeated keys like this as actually\nbeing two different keys--identical, but distinct.\nIt's ike having files with the same filename in two\ndifferent directories.  They have the same *filename,* but\nthey're not the same *file.*\n\n**correlate** calls groups of these multiple mappings *\"rounds\"*.\nA \"round\" contains all the keys from the Nth time they were\nrepeated; round 0 contains every key, round 1 contains the second\ninstances of all the keys that were repeated twice, round 2 contains\nall the third instances of all the keys that were repeated three times,\netc.\nRounds are per-value, and there are as\nmany rounds as the maximum number of redundant mappings of\nany single key to any particular value in a dataset.\n\nConsider this example:\n\n    c = correlate.Correlator()\n    o = object()\n    c.dataset_a.set('a', o, weight=1)\n    c.dataset_a.set('a', o, weight=3)\n    c.dataset_a.set('a', o, weight=5)\n    c.dataset_a.set('b', o)\n    c.dataset_a.set('b', o)\n    c.dataset_a.set('c', o)\n\n    o2 = object()\n    c.dataset_b.set('d', o2)\n    c.dataset_b.set('d', o2)\n    c.dataset_b.set('e', o2)\n    c.dataset_b.set('f', o2)\n\nHere, the value `o` in `dataset_a` would have three rounds:\n\n* Round 0 would contain the keys `{'a', 'b', 'c'}`.\n* Round 1 would contain the keys `{'a', 'b'}`.\n* Round 2 would contain only one key,`{'a'}`.\n\nAnd `o2` in `dataset_b` would have only two rounds:\n\n* Round 0 would contain the keys `{'d', 'e', 'f'}`.\n* Round 1 would contain only one key,`{'d'}`.\n\nAnd conceptually the `\"a\"` in round 0 is a different key\nfrom the `\"a\"` in round 1, etc.\n\nFor exact keys, rounds are directly matched iteratively\nto each other; the exact keys in round 0 for a value in\n`dataset_a` are matched to the round 0 exact keys for a value in\n`dataset_b`, round 1 in `dataset_a` is matched to\nround 1 in `dataset_b`, and so on.\nIf one side runs out of rounds early, you stop; if you compute\nthe intersection of a round and they have nothing in common,\nyou stop.\n\nOne invariant property: each subsequent round has a subset of\nthe keys before it.  The set of keys in round **N+1** *must*\nbe a subset of the keys in round **N**.\n\nWhat about weights?  Higher weights are sorted to lower rounds.\nThe weight for a key *k* in round **N-1** *must* be greater than\nor equal to the weight of *k* in round **N**.\nIn the above example, the `'a'` in round 0 has weight 5, in round 1\nit has weight 3, and in round 2 it has weight 1.\n(It doesn't matter what order you insert them in, **correlate**\ninternally stores the weights in sorted order.)\n\nThus, round 0 always contains every exact key mapped to\na particular value, with their highest weights.\n\nRounds can definitely help find the best matches.  If the\nkey `\"The\"` maps to most of your values once,\nthat's not particularly interesting, and it won't affect the scores\nvery much one way or another.  But if there's only one\nvalue in each dataset that `\"The\"` maps to *twice,*\nthat's a very strong signal indeed!  **correlate** does an\n*excellent* job of noticing unique-ness like that and factoring\nit into the scoring.\n\n\n\n### Scoring Exact Keys\n\nFor each match it considers, **correlate** computes the intersection of\nthe keys that map to each of those two values in the two datasets, then\ncomputes a score based on each of those key matches.\nThe formula used for scoring matches between exact keys\nis the heart of **correlate**, and was the original inspiration for\nwriting the library in the first place.\n\n**correlate** stores the keys per-round in `set()` objects, and computes\nthis intersection with the marvelously fast `set.intersection()`.\n\n**correlate** computes the score for an individual key as follows:\n\n    key = a key present in both dataset_a and dataset_b\n    value_a = a value from dataset_a that key maps to\n    value_b = a value from dataset_b that key maps to\n    round_number = which round this key is in\n    weight_a = weight of the mapping from key -> value_a in dataset_a in round round_number\n    weight_b = weight of the mapping from key -> value_b in dataset_b in round round_number\n    values_a = the count of values in dataset_a that this key maps to in round round_number\n    values_b = the count of values in dataset_b that this key maps to in round round_number\n    score_a = weight_a / values_b\n    score_b = weight_b / values_a\n    semifinal_score = score_a * score_b * (key_reuse_penalty_factor ** round_number)\n\nThis `semifinal_score` is then further adjusted based on ranking information,\nif used.  (See below.)\n\nThus, the fewer values a key maps to in a dataset, the higher it scores.\nA key that's only mapped once in each dataset scores 4x\nhigher than a key mapped twice in each dataset.\n\nThis scoring formula has a virtuous-feeling mathematical\nproperty I call *\"conservation of score\".*  Each key that\nyou add to a round in a dataset adds 1 to the total cumulatve\nscore of all possible matches; when you map a key to multiple\nvalues, you divide this score up evenly between those values.\nFor example, if the key `x` is mapped to three values in `dataset_a`\nand four values in `dataset_b`, each of those possible matches\nonly gets 1/12 of that key's score, and the final cumulative\nscore for all matches only goes up by 1/12.  So a key always\nadds 1 to the sum of all scores across all *possible* matches,\nbut only increases the actual final score by the amount of\nsignal it *actually* communicated.\n\nAlso, now you see why repeated keys can be so interesting.\nThey add 1 for *each round* they're in, but that score is only\ndivided by the number of values they're mapped to *in that round!*\n\n### Fuzzy Keys\n\nOnce upon a time, **correlate** was small and beautiful and\nmarvelously fast.  But that version could only support exact keys.\nBy the time fuzzy keys were completely implemented and feature-complete\nand working great, **correlate** was much more complex and... \"practical\".\nIt's because fuzzy keys introduce a lot of complex behavior, resulting in\ntricky scenarios that just couldn't happen with exact keys.\n\nConsider this example:\n\n>    Your two datasets represent lists of farms.  Both datasets list\n>    animals, but might have generic information (\"horse\") or might\n>    have specifics (\"Clydesdale\").  You create a fuzzy key subclass called\n>    `AnimalKey` that can handle matching these together;\n>    `AnimalKey(\"Horse/Clydesdale\")` matches `AnimalKey(\"Horse\")`,\n>    though with a score less than 1 because it isn't a perfect match.\n>\n>    The same farm, *Farm X*, is present in both datasets:\n>\n>    * In `dataset_a`, the keys `AnimalKey(\"Horse/Clydesdale\")`\n>    and `AnimalKey(\"Horse/Shetland Pony\")` map to Farm X.\n>\n>    * In `dataset_b`, the key `AnimalKey(\"Horse\")` maps to Farm X *twice.*\n>\n>    Question: should one of the `\"Horse\"` keys match `\"Horse/Clydesdale\"`,\n>    and the other `\"Horse\"` key match `\"Horse/Shetland Pony\"`?\n>\n>    Of course they should!\n\nThe scoring used for fuzzy keys is conceptually the same as the scoring\nfor exact keys, including the concept of \"rounds\".  In practice, fuzzy key\nscoring is much more complicated; there are some multipliers I elided\nin the description for exact keys because they're always 1, and some other\nthings that are easy to compute for exact keys that we must do the hard way\nfor fuzzy keys.  (There's a whole section at the end of this document about\nthe history of fuzzy key scoring in **correlate**, in case you're interested.)\n\nAlso, it's reasonable for a single value in a dataset to have multiple fuzzy\nkeys of the same type, which means that now we could have multiple keys\nin one dataset in contention for the same key in the other dataset.\nIn the above example with farms and horses, **correlate** will need to\ncompare both `AnimalKey(\"Horse/Clydesdale\")` and `AnimalKey(\"Horse/Shetland Pony\")`\nfrom `dataset_a` to `AnimalKey(\"Horse\")` in `dataset_b`.\n\nBut **correlate** doesn't add up every possible fuzzy score generated by a\nkey; when computing the final score, a fuzzy key is only matched against\none other fuzzy key.  If fuzzy keys *FA1* and *FA2* map to value *VA*\nin `dataset_a`, and fuzzy key *FB* maps to value *VB* in `dataset_b`,\n**correlate** will consider *FA1* -> *FB* and *FA2* -> *FB*\nand only keep the match with the highest score.  This match \"consumes\"\nthose two keys, and they can't be matched again.  (Again: when I say \"key\"\nhere, I mean \"this key in this round\".)\n\nWait!  It gets even *more* complicated!\nIt's entirely possible for a key in one round in `dataset_a` to be\nmatched to a key from a *different* round in `dataset_b`, again like the\nsample of the farms and horses above.  That's right: fuzzy keys can match\nkeys from *different rounds!*  Computing proper fuzzy scores thus\nrequires tracking separately how many reuses of each key\nwe've used so far so that *key_reuse_penalty_factor* can be computed\nproperly.  Where exact keys use very precise \"rounds\", fuzzy keys\nrequire a more dynamic approach.  In essense, an unused key in round *N*\ncan \"survive\" to rounds *N+1*.  That's what the above example with\nfarms and ponies is showing us; in round 0, if `\"Horse/Clysedale\"` in `dataset_a`\ngets matched to `\"Horse\"` in `dataset_b`, `\"Horse/Shetland Pony\"`\nin `dataset_a` goes unmatched and continues on to round 1.  This also\nmade scoring more complicated.  (For more on this, check out the test\nsuite.  There's a regression test that exercises this exact behavior.)\n\nSo here's how **correlate** computes fuzzy matches.  For each iteration,\nit computes all possible fuzzy matches between all viable keys,\nstores the results in a list, sorts the list with highest score first,\nand keep the highest-scored fuzzy match between two keys that haven't\nbeen \"used\" yet.  Every key that doesn't get \"used\" proceeds on to the\nnext iteration, if there is one, and if that same key was mapped in that\nround too the early one displaces the later one.  If fuzzy key *FKA*\nis mapped twice to value *VA*, and the first *FKA* doesn't get\nused in round 0, that mapping sticks around to the next iteration,\nand the second mapping continues to wait.  Complicated, huh!\n\n(One additional subtle point: the *weights* of these fuzzy key mappings\ndoesn't influence this aspect of scoring; they're only used in calculating\nthe semi-final score, below.  **correlate** prefers the *best* matches,\nnot the *most important* matches.)\n\nAt last, here's the scoring algorithm for fuzzy keys:\n\n    value_a = a value from dataset_a\n    value_b = a value from dataset_b\n    key_a = a fuzzy key in dataset_a that maps to value_a\n    key_b = a fuzzy key in dataset_b that maps to value_b\n    round_a = the round number for this mapping of key_a -> value_a in dataset_a\n    round_b = the round number for this mapping of key_b -> value_b in dataset_b\n    weight_a = weight of this mapping from key_a -> value_a in round_a in dataset_a\n    weight_b = weight of this mapping from key_b -> value_b in round_b in dataset_b\n    fuzzy_score = the result of key_a.compare(key_b)\n    cumulative_a = the cumulative score of all successful matches between key_a and all fuzzy keys in dataset_b\n    cumulative_b = the cumulative score of all successful matches between key_b and all fuzzy keys in dataset_a\n    reuse_penalty_a = key_reuse_penalty_factor ** round_a\n    reuse_penalty_b = key_reuse_penalty_factor ** round_b\n    score_ratio_a = (fuzzy_score * reuse_penalty_a) / cumulative_a\n    score_ratio_b = (fuzzy_score * reuse_penalty_b) / cumulative_b\n    unweighted_score = fuzzy_score * score_ratio_a * score_ratio_b\n    score_a = weight_a * unweighted_score_a\n    score_b = weight_b * unweighted_score_b\n    semifinal_score = score_a * score_b\n\n`cumulative_a` is the sum of all `fuzzy_score` scores for matches using `key_a`.\n`unweighted_score` is used when choosing which matches to keep per-round.\n`semifinal_score` is the actual score added to the total for this match.\nAgain, this `semifinal_score` is further permuted by ranking, if used.\n\nIt's hard to see it in all that messy math, but fuzzy keys maintain\n*\"conservation of score\"* too.  The total score contributed by a fuzzy key\nacross all possible matches is guaranteed to be no less than 0 and\nno more than 1.  But the amount of score it actually contributes\nto the final cumulative score is dependent on how many of those\nmatches are actually used.  A fuzzy key that, when matched,\nalways produced a `fuzzy_score` of 1 would behave identically\nto an exact key with respect to *\"conservation of score\"*.\n\n\n### Score Ratio Bonus\n\nThere's a \"bonus\" score calculated using `score_ratio_bonus`.  It's scored for the\noverall mapping of a value in `dataset_a` to a value in `dataset_b`.\nThis bonus is one of the last things computed for a match, just before ranking.\n\nThe bonus is calculated as follows:\n\n    value_a = a value from dataset_a\n    value_b = a value from dataset_b\n    actual_a = total actual score for all keys that map to value_a in dataset_a\n    actual_b = total actual score for all keys that map to value_b in dataset_b\n    possible_a = total possible score for all keys that map to value_a in dataset_a\n    possible_b = total possible score for all keys that map to value_b in dataset_b\n    bonus_weight = score_ratio_bonus * (actual_a + actual_b) / (possible_a + possible_b)\n\nThis bonus calculated with `score_ratio_bonus` clears up the\nambiguity when the set of keys mapping to one value is a subset of the keys\nmapping to a different value in the same dataset.  The higher percentage\nof keys that match, the larger this bonus will be.\n\nConsider this example:\n\n    c = correlate.Correlator()\n    c.dataset_a.set('breakin', X)\n\n    c.dataset_b.set('breakin', Y)\n    c.dataset_b.set_keys(['breakin', '2', 'electric', 'boogaloo'], Z)\n\nWhich is the better match, `X->Y` or `X->Z`?\nIn early versions of **correlate**, both matches got the exact same score.\nSo it was the luck of the draw as to which match **correlate** would choose.\n`score_ratio_bonus` disambiguates this scenario.  It awards a larger bonus\nto `X->Y` than it does to `X->Z`,  because a higher percentage of the keys\nmatched between `X` and `Y`.\nThat small boost is usually all that's needed to let **correlate**\ndisambiguate these situations and pick the correct match.\n\nTwo things to note.  First, when I say \"keys\", this is another situation\nwhere the same key mapped twice to the same value is conceptually considered\nto be two different keys.\nIn the example in the **Rounds** subsection above, where `value_a` is `o` and\n`value_b` is `o2`, `possible_a` would be 6 and `possible_b` would be 4.\n\nSecond, the scores used to compute `actual` and `possible` are *unweighted.*\nIf a match between two fuzzy keys resulted in a fuzzy score of `0.3`,\nthat adds `0.3` to both `actual_a` and `actual_b`, but each of those fuzzy\nkeys adds `1.0` to `possible_a` and `possible_b` respectively.\nAll modifiers, like weights and `key_reuse_penalty_factor`,\nare ignored when computing `score_ratio_bonus`.\n\n\n### Choosing Which Matches To Keep: The \"Match Boiler\"\n\nAs mentioned previously, **correlate** iterates over all the matches\nsorted by score, and keeps the matches with the highest score where\nneither `value_a` nor `value_b` has been matched yet.\n\nActually that's no longer quite true.\nLate in development of **correlate**, I realized there was a small\nproblem lurking with this approach.  Happily it had a relatively\neasy fix, and the fix didn't make **correlate** any slower in the\ngeneral case.\n\nHere's the abstract problem: if you're presented with a list of match\nobjects called `matches`,\nwhere each item has three attributes `value_a`, `value_b`, and `score`,\nhow would you compute an optimal subset of `matches` such that:\n\n* every discrete value of `value_a` and `value_b` appears only once, and\n* the sum of the `score` attributes is maximized?\n\nFinding the perfectly optimal subset would be expensive--not\nquite `O(N**2)` but close.  It'd require a brute-force approach,\nwhere, for every item in `matches` that shared a value of `value_a` or\n`value_b` with another item, you'd have to run an experiment to\n\"look ahead\" and see what happens if you chose that item.  You\ncompute the resulting score for each of these items, then\nkeep the item that resulted in the highest cumulative score.\n\n**correlate** needs to solve this problem in two different contexts:\n\n* when processing the list of fuzzy matches produced during each \"round\" of fuzzy matching, and\n* when processing the overall list of matches computed between `dataset_a` and `dataset_b`\n  at the end of the correlation process.\n\nBut **correlate** can't use this hypothetical \"optimal\" algorithm,\nbecause it'd take too long--you probably want your correlation\nto finish before our sun turns into a red giant.\nInstead, **correlate** used a considerably\ncheaper \"greedy\" algorithm.  As already described several times:\n**correlate** sorts\nthe list of matches by `score`, then iterates down the list highest\nto lowest.  For every item, if we haven't already \"kept\" another item\nwith the same `value_a` or `value_b`, \"keep\" this item in the `results`\nlist, and remember the `value_a` and `value_b`.\n\nThis approach completes in linear time.  In theory, it's not guaranteed\nto produce optimal results.  In practice, with real-world data, it should.\nExcept there *is* a plausible problem lurking in this approach!\n\nConsider: what if two values in the list are both viable, and they have the\n*same* score, and they have either `value_a` or `value_b` in common?  It's\nambiguous as to which match **correlate** will choose.  But choosing the\nwrong one *could* result in objectively less-than-optimal scoring.\n\nHere's a specific example:\n\n* `dataset_a` contains fuzzy keys `fka1` and `fka2`.\n* `dataset_b` contains fuzzy keys `fkbH` and `fkbL`.\n  Any match containing `fkbH` has a higher score than any match containing `fkbL`.\n  (H = high scoring, L = low scoring.)\n* The matches`fka1->fkbH` and `fka2->fkbH` have the same score.\n* The match `fka1->fkbL` has a lower score than `fka2->fkbL`.\n\n**correlate** should prefer `fka2->fkbL` to `fka1->fkbL`.\nBut it can only pick that match if it previously picked `fka1->fkbH`.\nAnd there's no guarantee that it would!  If two items in the list have\nthe same score, it's ambiguous which one **correlate** would choose.\nTo handle this properly it needs to look ahead and experiment.\n\nMy solution for this is what I call the \"match boiler\", or the \"boiler\"\nfor short.  The boiler uses a hybrid approach: it uses the greedy linear\nalgorithm when scores are unique.  If it encounters a run of items\nwith matching scores, and where any of those items have `value_a` or\n`value_b` in common, it recursively tries the experiment where it keeps\neach of those items in turn.  It does the look-ahead, and sums the score\nfrom each recursive experiment, then keeps the experiment with the highest\nscore.\n\nWith the \"match boiler\" in place, **correlate** seems to produce optimal\nresults even in these rare ambigous situations.\n\n(Using the boiler to analyze fuzzy rounds got pretty complicated!\nIt had to support a callback each time it kept a value, which let\nthe fuzzy keys submit new matches for consideration from subsequent\nrounds.)\n\n\nEven with the boiler, you can still contrive scenarios where **correlate**\nwill produce arguably sub-optimal results.  If `a1` and `a2` are values\nin `dataset_a`, and `b1` and `b2` are values in `dataset_b`, and the\nmatches have these scores:\n\n    a1->b1 == 10\n    a1->b2 == 9\n    a2->b1 == 8\n    a2->b2 == 1\n\nIn this scenario, the boiler will pick `a1->b1`, which means it's\nleft with `a2->b2`.  Total score: 11.  But if it had picked `a1->b2`,\nthat means it would get to pick `a2->b1`, and the total score would be 17!\nIs that better?  In an abstract, hypothetical scenario like this, it's\nhard to say for sure.\n\nIn practice I don't think this is really a problem.  Handling the\nambiguous scenario where items had identical scores is already\n\"gilding the lily\", considering how rare it happens with real-world data.\nAnyway, when would real data behave in this contrived way?  How\ncould `a1` score so highly against `b1` and `b2`, but `a1` scores\nhigh against `b1` but low against `b2`?\nThis scenario simply isn't realistic, and fixing it would likely be\ncomputationally expensive for the general case.  So it's just not\nworth it.  Relax, YAGNI.\n\n\n### Ranking\n\nRanking information can help a great deal.\nIf a value in `dataset_a` is near the beginning, and the order\nof values is significant, then we should prefer matching it to values\nin `dataset_b` near the beginning too.  Matching the first\nvalue in `dataset_a`\nagainst the last value in `dataset_b` is probably bad.\n\nConceptually it works as follows: when scoring a match,\nmeasure the distance between\nthe two values and let that distance influence the score.  The closer\nthe two values are to each other, the higher the resulting score.\n\nBut how do you compute that delta?  What do the ranking numbers mean?\n**correlate** supports two possible interpretations\nof the rankings, what we'll call *absolute* and *relative* ranking.\nThese two approaches differ in how they compare the ranking numbers,\nas follows:\n\n* *Absolute* ranking assmes the ranking numbers are the same\n  for both datasets.  `ranking=5` in `dataset_a` is a perfect\n  match to `ranking=5` in `dataset_b`.\n* *Relative* ranking assumes that the two datasets represent the\n  same range of data, and uses the ratio of the ranking of a value\n  divided by the highest ranking set in that dataset to compute\n  its relative position.  If the highest ranking we saw in a\n  particular dataset was `ranking=150`,\n  then a value that has `ranking=12` set is calculated to be 8%\n  of the way from the beginning to the end.  This percentage\n  is calculated similarly for both datasets, and the distance\n  between two values is the distance between these two percentages.\n\nFor example, if `dataset_a` had 100 items ranked 1 to 100,\nand `dataset_b` had 800 items ranked 1 to 800,\na value to `dataset_a` with `ranking=50` in *absolute* ranking\nwould be considered closest to a value in `dataset_b` with `ranking=50`,\nbut when using *relative* ranking\nit'd be considered closest to a value in `dataset_b` with `ranking=400`.\n\nWhich one does **correlate** use?  It's configurable with the `ranking`\nparameter to `correlate()`.  By default it uses \"best\" ranking.\n\"Best\" ranking means **correlate** will compute scores using *both*\nmethods and choose the approach with the highest overall score.\nYou can override this by supplying a different value to `ranking`\nbut this shouldn't be necessary.  (Theoretically it should be faster\nto use a specific ranking approach.  Unfortunately this hasn't been\noptimized yet, so using only one ranking doesn't really speed things up.)\n\n\nRanking is the last step in computing the score of a match.\nAs for how ranking affects the score, it depends on whether you\nuse `ranking_bonus` or `ranking_factor`.\n\nBoth approaches start with these four calculations:\n\n    semifinal_scores_sum = sum of all \"semifinal\" scores above\n    ranking_a = the ranking value computed for value_a\n    ranking_b = the ranking value computed for value_b\n    ranking_score = 1 - abs(ranking_a - ranking_b)\n\n`ranking_bonus` is then calculated per-match as follows:\n\n    bonus = ranking_score * ranking_bonus\n    final_score = semifinal_scores_sum + bonus\n\n`ranking_factor` is also calculated per-match, as follows:\n\n    unranked_portion = (1 - ranking_factor) * semifinal_scores_sum\n    ranked_portion = ranking_factor * semifinal_scores_sum * ranking_score\n    final_score = unranked_portion + ranked_portion\n\n(If you don't use either, the final score for the match is effectively\n`semifinal_scores_sum`.)\n\nObviously, `ranking` must be set on both values in both datasets to\nproperly compute `ranking_score`.  If it's not set on *both* values\nbeing considered for a match, **correlate** still applies\n`ranking_bonus` or `ranking_factor` as usual, but it skips the\ninitial four calculations and just uses a `ranking_score` of 0.\n\n\n## Final Random Topics\n\n### Debugging\n\nWhen all else fails... what next?\n\n**correlate** can optionally produce an enormous amount of debug output.\nThe main feature is showing every match it tests, and the score arrived\nat for that match, including every step along the way.  This log output\nquickly gets very large; even a comparison of 600x600 elements will produce\ntens of megabytes of output.\n\nUnfortunately, producing this much debugging output incurred a measurable\nperformance penalty--even when you had logging turned off!  It was mostly\nin computing the \"f-strings\" for the log, but also simply the calls to\nthe logging functions added overhead too.\n\nMy solution: by default, each of the debug print statements\nis commented out.\n**correlate** ships with a custom script preprocessor called\n`debug.py` that can toggle debugging on and off, by uncommenting and\nre-commenting the debug code.\n\nHow does it know which lines to uncomment?  Each line of the logging-only\ncode ends with the special marker \"`#debug`\".\n\nTo turn on this logging, run the `debug.py` script in the same directory\nas **correlate's** `__init__.py` script.  Each time you run it, it'll\ntoggle the debug print statements.\nNote that the debug feature in **correlate** requires Python 3.8 or higher,\nbecause it frequently uses the beloved \"equals sign inside f-strings\" syntax.\n\nBy default the logging is sent to stdout.  If you want to override where\nit's sent, write your own `print` function, and assign it to your\n`Correlator` object before calling `correlate()`.\n\nThe format of the log is undocumented and subject to change.  Good luck!\nThe main thing you'll want to do is figure out the \"index\" of the values\nin datasets a and b that you want to compare, then search for `\" (index_a) x (index_b) \"`.\nFor example, if the match you want to see is between value index 35 in `dataset_a`\nand value index 51 in `dataset_b`, search in the log for `\" 35 x 51 \"`.\n(The leading and trailing spaces means your search will skip over,\nfor example, `235 x 514`.)\n\n\n### Alternate Fuzzy Scoring Approaches That Didn't Work\n\nThe math behind fuzzy scoring is a bit surprising, at least to me.\nIf you boil down the formula to its constituent factors,\nyou'll notice one of the factors is `fuzzy_score` *cubed.*\nWhy is it *cubed?*\n\nThe simplest answer: that's the first approach that worked\nproperly.  To really understand why, you'll need to understand the\nhistory of fuzzy scoring in **correlate**--all the approaches\nI tried first that *didn't* work.\n\nInitially, the score for a fuzzy match was simply the fuzzy score\nmultiplied by the weights and `key_reuse_penalty_factor`.\nThis was always a dumb idea; it meant fuzzy matches had *way* more\nimpact on the score than they should have.  This was particularly\ntrue when you got down to the last 10% or 20% of your matches,\nby which point the score contributed by exact keys had\nfallen off a great deal.  This approach stayed in for what is,\nin retrospect, an embarassingly long time; I'd convinced myself\nthat fuzzy keys were innately more *interesting* than exact keys,\nand so this comparative importance was fitting.\n\nOnce I realized how dumb that was, the obvious approach was to score\nthem identically to exact keys--divide the fuzzy score by the product\nof the number of keys this *could* have matched against in each\nof the two datasets.  This was obviously wrong right away.\nIn the \"YTJD\" test, every value had the same fuzzy keys, depending\non the test: every value always had a fuzzy date key, and depending\non the test it might have a fuzzy title key and/or a fuzzy episode number\nkey too.  So each of the 812 values in the first dataset had one\nfuzzy key for each type, and each of the 724 values in the second dataset\ndid too.  Even if we got a perfect fuzzy match, the maximum score\nfor a fuzzy match was now `1.0 / (812 * 724)` which is `0.0000017`.  So now\nwe had the opposite problem: instead of being super important, even a perfect\nfuzzy match contributed practically nothing to the final score.\n\nAfter thinking about it for a while,\nI realized that the exact key score wasn't *really* being\ndivided by the number of *keys* in the two datasets, per se;\nit was being divided by the total possible *score* contributed\nby that key in each of the two datasets.  So instead of\ndividing fuzzy scores by the number of keys, they should be divided\nby the cumulative fuzzy score of all matches involving those two keys.\nThat formula looks like\n`fuzzy_score / (sum_of_fuzzy_scores_for_key_in_A * sum_of_fuzzy_scores_for_key_in_B)`.\n\nThis was a lot closer to correct!  But this formula had a glaring new problem.\nLet's say that in your entire correlation, `dataset_a` only had one\nfuzzy key that maps to a single value,\nand `dataset_a` only had one fuzzy key that also only maps to a single value.\nAnd let's say the fuzzy score you get from matching those two keys\nis `0.000001`--a really terrible match.\nLet's plug those numbers into our formula, shall we.  We get `0.000001 / (0.000001 * 0.000001)`\nwhich is `1000000.0`.  A million!  That's crazy!  We've taken an absolutely\nterrible fuzzy match and inflated its score to be nonsensically high.\nClearly that's not right.\n\nThis leads us to the formula that actually works.  The insight here\nis that the same formula needs to work identically for exact keys.\nIf you take this formula and compute it where every `fuzzy_score`\nis 1 (or 0), it produces the same result as the formula for exact keys.\nSo the final trick is that we can multiply by `fuzzy_score` wherever we need\nto, because multiplying by 1 doesn't change anything.  That means\nthe resulting formula will still be consistent with the exact keys\nscoring formula.  And what worked was the formula where we multiply by\n`fuzzy_score` three times!\n\nHere again is the formula used to compute the score for a fuzzy match,\nsimplified to ignore weights and rounds:\n\n    value_a = a value from dataset_a\n    value_b = a value from dataset_b\n    key_a = a fuzzy key in dataset_a that maps to value_a\n    key_b = a fuzzy key in dataset_b that maps to value_b\n    fuzzy_score = the result of key_a.compare(key_b)\n    cumulative_a = the cumulative score of all successful matches between key_a and all fuzzy keys in dataset_b\n    cumulative_b = the cumulative score of all successful matches between key_b and all fuzzy keys in dataset_a\n    score_ratio_a = fuzzy_score / cumulative_a\n    score_ratio_b = fuzzy_score / cumulative_b\n    unweighted_score = fuzzy_score * score_ratio_a * score_ratio_b\n\nThe final trick really was realizing what `score_ratio_a` represents.\nReally, it represents the ratio of how much *this* fuzzy match for `key_a`\ncontributed to the sum of *all* fuzzy matches for `key_a`\nacross all successful matches in `dataset_a`.\n\n### Why correlate Doesn't Use The Gail-Shapley Algorithm\n\nA friend asked me if this was isomorphic to the Stable Matching Problem:\n\nhttps://en.wikipedia.org/wiki/Stable_matching_problem\n\nBecause, if it was, I might be able to use the Gail-Shapley algorithm:\n\nhttps://en.wikipedia.org/wiki/Gale%E2%80%93Shapley_algorithm\n\nI thought about this for quite a while, and I don't think **correlate** maps perfectly onto the stable matching problem.  **correlate**solves a problem that is:\n\n1. simpler, and\n1. different.\n\nI think it *could* use Gail-Shapley, but that wouldn't be guaranteed to produce optimal results... and it's more expensive than my \"greedy\" algorithm.\n\nIn all the following examples, `A`, `B`, and `C` are values in `dataset_a` (aka \"men\") and X, Y, and Z are values in `dataset_b` (aka \"women\").\nThe expression `A: XY` means \"`A` prefers `X` to `Y`\". The expression `A:X=1.5` means \"when matching `A` and `X`, their score is `1.5`\".\n\n*How is it simpler?*\n\nThe stable matching problem only requires a local ordering, where the preferences of any value in either dataset are disjoint\nfrom the orderings of any other value.  But **correlate** uses a \"score\"--a number--to compute these preferences, and this\nscore is symmetric; if `A:X=1.5`, then `X:A=1.5` too.\n\nOn this related Wikipedia page:\n\nhttps://en.wikipedia.org/wiki/Lattice_of_stable_matchings\n\nwe find a classic example of a tricky stable matching problem:\n\n    A: YXZ\n    B: ZYX\n    C: XZY\n\n    X: BAC\n    Y: CBA\n    Z: ACB\n\nGail-Shapley handles this situation with aplomb.  Does **correlate**?  The answer is... this arrangement of constraints\njust can't *happen* with **correlate**, because it uses scores to establish its preferences, and the scores are symmetric.\nThere are nine possible pairings with those six values. It's impossible to assign a unique score to each of those nine\npairings such that the preferences of each value match those constraints.\n\n(I know--I tried. I wrote a brute-force program that tried every combination. 362,880 attempts later, I declared failure.)\n\n*How is it different?*\n\nGail-Shapley requires that every value in each dataset expresses a strictly ordered preference for every value in the\nother dataset. But in **correlate**, two matches can have the same score.\n\nConsider this expression of a **correlate** problem:\n\n    A:X=100\n    A:Y=1\n\n    B:X=100\n    B:Y=2\n\nGail-Shapley can't solve that problem, because X doesn't prefer A or B--it likes them both equally.\n(Happily, **correlate** handles *that* situation with aplomb--see the \"match boiler\" above.)\nIf we weaken Gail-Shapley to permit lack-of-preference, my hunch is you could contrive inputs where\nit would never complete.\n\nIn addition, **correlate** uses a numerical score to weigh the merits of each match, and seeks to\nmaximize the cumulative score across all matches. Gail-Shapley's goals are comparatively modest--any\nmatch that's stable is fine. There may be many stable matchings; Gail-Shapley considers them all\nequally good.  There's no guarantee that, if fed digestible **correlate** datasets, Gail-Shapley\nwould produce the stable match with the highest score.\n\n(I admit, I wasn't able to come up with an example where Gail-Shapley would view two solutions as\nequally desirable, but **correlate** would definitely prefer one over the other. Maybe this last\nthing isn't an actual problem.)\n\n## Version History\n\n**0.6.1**\n\nBugfix for major but rare bug: if there are multiple\ngroups of `len() > 1` of \"connected\" match objects with\nthe same score, the match boiler would only keep the\nsmallest one--the rest were accidentally discarded.\n(`match_boiler_2_test()` was added to `tests/regression_test.py`\nto check for this.)\n\n**0.6**\n\nBig performance boost in \"fuzzy boiling\"!  Clever sorting of fuzzy matches,\nand improvements in the stability (as in \"stable sort\") of `MatchBoiler`,\nallowed using an unmodified boiler to process fuzzy matches.  This allowed\nremoval of `FuzzyMatchBoiler` and the `MatchBoiler.filter()` callback mechanism.\n\nMinor performance improvement in `MatchBoiler`: when recursing, find the\nsmallest group of connected matches with the same score,\nand only recursively check each of those,\nrather than all possibly-connected matches with the same score.\n\nRemoved `key_reuse_penalty_factor`.\nIn the early days of **correlate**, I thought redundant keys were uninteresting.\nInitially **correlate** didn't even understand rounds; if you mapped the same\nkey to the same value twice, it only retained one mapping (the one with the\nhigher weight).  Later I added rounds, but they didn't seem to add much signal.\nSo I added `key_reuse_penalty_factor`, so you could turn it down, in case it\nwas adding more noise than signal.\nIt wasn't until the realization that `key->value` in round 0 and `key->value`\nin round 1 were conceptually *two different keys* that I really understood\nhow redundant mappings of the same key to the same value should work.  And\nonce rounds maintained distinct counts of `keys / scores` for the scoring\nformula, redundant keys in different rounds became *way* more informative\nto the final score.   I now think `key_reuse_penalty_factor` is dumb and worse\nthan useless and I've removed it.  If you think `key_reuse_penalty_factor` is useful,\nplease contact me and tell me why!  Or, quietly just pre-multiply it into\nyour weights.\n\n\nThe cumulative effect: a speedup of up to 30% in fuzzy match boiling,\nand up to 5% on YTJD tests using a lot of fuzzy keys.  Match boiling got\nslightly faster too.\n\n**0.5.1**\n\nBugfix release.  In the original version, if a match didn't have any matches between\nfuzzy keys (with a positive score), it ignored the weights of its exact keys and just\nused the raw exact score.\n\n**0.5**\n\nInitial public release.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/larryhastings/correlate/", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "correlate", "package_url": "https://pypi.org/project/correlate/", "platform": "", "project_url": "https://pypi.org/project/correlate/", "project_urls": {"Homepage": "https://github.com/larryhastings/correlate/"}, "release_url": "https://pypi.org/project/correlate/0.6.1/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Correlates two sets of data by matching unique or fuzzy", "version": "0.6.1"}, "last_serial": 7022658, "releases": {"0.5": [{"comment_text": "", "digests": {"md5": "aa1a83a66f922c303b68c4ced92db9b1", "sha256": "54a772240b0166910c371dfcd9d993f8683872d4835fcfd489ffea13056ff4a7"}, "downloads": -1, "filename": "correlate-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "aa1a83a66f922c303b68c4ced92db9b1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 44992, "upload_time": "2020-04-07T07:42:38", "upload_time_iso_8601": "2020-04-07T07:42:38.072987Z", "url": "https://files.pythonhosted.org/packages/c0/97/bfa2950015686153fd51b94adf9f70beb63aafabfde49bc7ea4296a37e82/correlate-0.5-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "cc83c6313629e86c5f6ca4ed7a1aeef8", "sha256": "c403380ff945d4d0bb28153902b45a336c3684baf600b5224ba2716d136f3455"}, "downloads": -1, "filename": "correlate-0.5.tar.gz", "has_sig": false, "md5_digest": "cc83c6313629e86c5f6ca4ed7a1aeef8", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 85131, "upload_time": "2020-04-07T07:42:40", "upload_time_iso_8601": "2020-04-07T07:42:40.902470Z", "url": "https://files.pythonhosted.org/packages/45/15/7195dda3714caedc5bead5f9d189bcc8ec82c58275edf11a2b70415e7360/correlate-0.5.tar.gz"}], "0.5.1": [{"comment_text": "", "digests": {"md5": "4199960031abbcbcbd6b2a3de8714b76", "sha256": "f018c253f2dc068771446cb88884e03e79768c739164f33a949c5b9cb38529b5"}, "downloads": -1, "filename": "correlate-0.5.1-py3-none-any.whl", "has_sig": false, "md5_digest": "4199960031abbcbcbd6b2a3de8714b76", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 38707, "upload_time": "2020-04-07T11:30:13", "upload_time_iso_8601": "2020-04-07T11:30:13.020536Z", "url": "https://files.pythonhosted.org/packages/44/ad/74313872b4d631aa479918aa6d256b5b17707b366412f152a112bde5cfe8/correlate-0.5.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "102bc39d2164f65e0c765169f2872378", "sha256": "b557700fea65644c18e03f57a80d69a79a09df668bd0b3214140923c2616a5f3"}, "downloads": -1, "filename": "correlate-0.5.1.tar.gz", "has_sig": false, "md5_digest": "102bc39d2164f65e0c765169f2872378", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 79219, "upload_time": "2020-04-07T11:30:14", "upload_time_iso_8601": "2020-04-07T11:30:14.605910Z", "url": "https://files.pythonhosted.org/packages/3f/7b/d9bc869f72c8c3aa7d27908d51b35bd6d63bc280254d7213a0a65f5125db/correlate-0.5.1.tar.gz"}], "0.6": [{"comment_text": "", "digests": {"md5": "2c5da10938082f2365ef44a4d6e2ab5e", "sha256": "cbb152d4f1b600f172df854906e3e340cce25ed9c931a0f8f9de512767cbfae1"}, "downloads": -1, "filename": "correlate-0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "2c5da10938082f2365ef44a4d6e2ab5e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 40528, "upload_time": "2020-04-14T07:43:11", "upload_time_iso_8601": "2020-04-14T07:43:11.845299Z", "url": "https://files.pythonhosted.org/packages/99/d8/42ccb183c606cdd7e31767cbcb6314f0e4d92e20a67c785103eb6a296473/correlate-0.6-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "39141307af648033ce60517cac589b45", "sha256": "09b2225baeb1a5c4649a5698751579f6bfca45b6398e00c32851916d01f6fe9b"}, "downloads": -1, "filename": "correlate-0.6.tar.gz", "has_sig": false, "md5_digest": "39141307af648033ce60517cac589b45", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 81786, "upload_time": "2020-04-14T07:43:14", "upload_time_iso_8601": "2020-04-14T07:43:14.495003Z", "url": "https://files.pythonhosted.org/packages/2a/5c/fecb320795c33961b6da41699fc6ec0c9912f56abe559aadba40f9d4b9cf/correlate-0.6.tar.gz"}], "0.6.1": [{"comment_text": "", "digests": {"md5": "5f2a9f171b9118c2fb3f7bda4b62e6a2", "sha256": "f839a5855f9a647d2e3b1d52edcc4d12806281a00164ec31e2b2b6bb155d7fd9"}, "downloads": -1, "filename": "correlate-0.6.1-py3-none-any.whl", "has_sig": false, "md5_digest": "5f2a9f171b9118c2fb3f7bda4b62e6a2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 41362, "upload_time": "2020-04-15T06:45:10", "upload_time_iso_8601": "2020-04-15T06:45:10.646113Z", "url": "https://files.pythonhosted.org/packages/16/6f/733ccd34eb77dd30ffe58122d43500105397e90c05232deae62c387443f5/correlate-0.6.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "285d342930750661391ede56e4d09f75", "sha256": "c03b50aca2a3936a725d0b7baeed4de1f8651ad69d300d6ce5049263178d69ce"}, "downloads": -1, "filename": "correlate-0.6.1.tar.gz", "has_sig": false, "md5_digest": "285d342930750661391ede56e4d09f75", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 82934, "upload_time": "2020-04-15T06:45:12", "upload_time_iso_8601": "2020-04-15T06:45:12.831241Z", "url": "https://files.pythonhosted.org/packages/2f/93/d55847d1aadd45bbc5f9c5c2d00dd95f52d30bbfe6f04ea251a7990ac481/correlate-0.6.1.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "5f2a9f171b9118c2fb3f7bda4b62e6a2", "sha256": "f839a5855f9a647d2e3b1d52edcc4d12806281a00164ec31e2b2b6bb155d7fd9"}, "downloads": -1, "filename": "correlate-0.6.1-py3-none-any.whl", "has_sig": false, "md5_digest": "5f2a9f171b9118c2fb3f7bda4b62e6a2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 41362, "upload_time": "2020-04-15T06:45:10", "upload_time_iso_8601": "2020-04-15T06:45:10.646113Z", "url": "https://files.pythonhosted.org/packages/16/6f/733ccd34eb77dd30ffe58122d43500105397e90c05232deae62c387443f5/correlate-0.6.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "285d342930750661391ede56e4d09f75", "sha256": "c03b50aca2a3936a725d0b7baeed4de1f8651ad69d300d6ce5049263178d69ce"}, "downloads": -1, "filename": "correlate-0.6.1.tar.gz", "has_sig": false, "md5_digest": "285d342930750661391ede56e4d09f75", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 82934, "upload_time": "2020-04-15T06:45:12", "upload_time_iso_8601": "2020-04-15T06:45:12.831241Z", "url": "https://files.pythonhosted.org/packages/2f/93/d55847d1aadd45bbc5f9c5c2d00dd95f52d30bbfe6f04ea251a7990ac481/correlate-0.6.1.tar.gz"}]}
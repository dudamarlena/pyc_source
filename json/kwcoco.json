{"info": {"author": "Jon Crall", "author_email": "jon.crall@kitware.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "The Kitware COCO Module\n=======================\n\n.. # TODO Get CI services running on gitlab \n\n|GitlabCIPipeline| |GitlabCICoverage| |Appveyor| |Pypi| |Downloads| |ReadTheDocs|\n\nThe Kitware COCO module defines a variant of the Microsoft COCO format,\noriginally developed for the \"collected images in context\" object detection\nchallenge. We are backwards compatible with the original module, but we also\nhave improved implementations in several places, including segmentations and\nkeypoints.\n\n\nThe main data structure in this model is largely based on the implementation in\nhttps://github.com/cocodataset/cocoapi It uses the same efficient core indexing\ndata structures, but in our implementation the indexing can be optionally\nturned off, functions are silent by default (with the exception of long running\nprocesses, which optionally show progress by default). We support helper\nfunctions that add and remove images, categories, and annotations. \n\nWe do not reimplement the scoring code fro pycocotools in this module. Instead\nthat functionality currently lives in netharn:\nhttps://gitlab.kitware.com/computer-vision/netharn/-/blob/master/netharn/metrics/detect_metrics.py\nWe may move that file either this repo or kwannot in the future. This module is\nmore focused on efficient access and modification of a COCO dataset.\n\n\nThe kwcoco CLI\n--------------\n\nAfter installing kwcoco, you will also have the ``kwcoco`` command line tool. \nThis uses a ``scriptconfig`` / ``argparse`` CLI interface. Running ``kwcoco\n--help`` should provide a good starting point.\n\n.. code:: \n\n    usage: kwcoco [-h] {stats,union,split,show,toydata} ...\n\n    The Kitware COCO CLI\n\n    positional arguments:\n      {stats,union,split,show,toydata}\n                            specify a command to run\n        stats               Compute summary statistics about a COCO dataset\n        union               Combine multiple COCO datasets into a single merged dataset.\n        split               Split a single COCO dataset into two sub-datasets.\n        show                Visualize a COCO image\n        toydata             Create COCO toydata\n\n    optional arguments:\n      -h, --help            show this help message and exit\n\n\nThis should help you inspect (via stats and show), combine (via union), and\nmake training splits (via split) using the command line. Also ships with\ntoydata, which generates a COCO file you can use for testing.\n\n\nThe CocoDataset object\n----------------------\n\nThe ``kwcoco.CocoDataset`` class is capable of dynamic addition and removal of\ncategories, images, and annotations. Has better support for keypoints and\nsegmentation formats than the original COCO format. Despite being written in\nPython, this data structure is reasonably efficient.\n\n\n.. code:: python\n\n        >>> import kwcoco\n        >>> import json\n        >>> # Create demo data\n        >>> demo = CocoDataset.demo()\n        >>> # could also use demo.dump / demo.dumps, but this is more explicit\n        >>> text = json.dumps(demo.dataset)\n        >>> with open('demo.json', 'w') as file:\n        >>>    file.write(text)\n\n        >>> # Read from disk\n        >>> self = CocoDataset('demo.json')\n\n        >>> # Add data\n        >>> cid = self.add_category('Cat')\n        >>> gid = self.add_image('new-img.jpg')\n        >>> aid = self.add_annotation(image_id=gid, category_id=cid, bbox=[0, 0, 100, 100])\n\n        >>> # Remove data\n        >>> self.remove_annotations([aid])\n        >>> self.remove_images([gid])  \n        >>> self.remove_categories([cid])\n\n        >>> # Look at data\n        >>> print(ub.repr2(self.basic_stats(), nl=1))\n        >>> print(ub.repr2(self.extended_stats(), nl=2))\n        >>> print(ub.repr2(self.boxsize_stats(), nl=3))\n        >>> print(ub.repr2(self.category_annotation_frequency()))\n        \n\n        >>> # Inspect data\n        >>> import kwplot\n        >>> kwplot.autompl()\n        >>> self.show_image(gid=1)\n\n        >>> # Access single-item data via imgs, cats, anns\n        >>> cid = 1\n        >>> self.cats[cid]\n        {'id': 1, 'name': 'astronaut', 'supercategory': 'human'}\n\n        >>> gid = 1\n        >>> self.imgs[gid]\n        {'id': 1, 'file_name': 'astro.png', 'url': 'https://i.imgur.com/KXhKM72.png'}\n\n        >>> aid = 3\n        >>> self.anns[aid]\n        {'id': 3, 'image_id': 1, 'category_id': 3, 'line': [326, 369, 500, 500]}\n\n        # Access multi-item data via the annots and images helper objects\n        >>> aids = self.index.gid_to_aids[2]\n        >>> annots = self.annots(aids)\n\n        >>> print('annots = {}'.format(ub.repr2(annots, nl=1, sv=1)))\n        annots = <Annots(num=2)>\n\n        >>> annots.lookup('category_id')\n        [6, 4]\n\n        >>> annots.lookup('bbox')\n        [[37, 6, 230, 240], [124, 96, 45, 18]]\n\n        >>> # built in conversions to efficient kwimage array DataStructures\n        >>> print(ub.repr2(annots.detections.data))\n        {\n            'boxes': <Boxes(xywh,\n                         array([[ 37.,   6., 230., 240.],\n                                [124.,  96.,  45.,  18.]], dtype=float32))>,\n            'class_idxs': np.array([5, 3], dtype=np.int64),\n            'keypoints': <PointsList(n=2) at 0x7f07eda33220>,\n            'segmentations': <PolygonList(n=2) at 0x7f086365aa60>,\n        }\n        \n        >>> gids = list(self.imgs.keys())\n        >>> images = self.images(gids)\n        >>> print('images = {}'.format(ub.repr2(images, nl=1, sv=1)))\n        images = <Images(num=3)>\n\n        >>> images.lookup('file_name')\n        ['astro.png', 'carl.png', 'stars.png']\n\n        >>> print('images.annots = {}'.format(images.annots))\n        images.annots = <AnnotGroups(n=3, m=3.7, s=3.9)>\n\n        >>> print('images.annots.cids = {!r}'.format(images.annots.cids))\n        images.annots.cids = [[1, 2, 3, 4, 5, 5, 5, 5, 5], [6, 4], []]\n\n\nThe JSON Spec\n-------------\n\nA COCO file is a json file that follows a particular spec. It is used for\nstoring computer vision datasets: namely images, categories, and annotations.\nImages have an id and a file name, which holds a relative or absolute path to\nthe image data. Images can also have auxillary files (e.g. for depth masks,\ninfared, or motion). A category has an id, a name, and an optional\nsupercategory.  Annotations always have an id, an image-id, and a bounding box.\nUsually they also contain a category-id. Sometimes they contain keypoints,\nsegmentations. \n\nAn implementation and extension of the original MS-COCO API [1]_.\n\nExtends the format to also include line annotations.\n\nDataset Spec:\n\n.. code:: \n\n    dataset = {\n        # these are object level categories\n        'categories': [\n            {\n                'id': <int:category_id>,\n                'name': <str:>,\n                'supercategory': str  # optional\n\n                # Note: this is the original way to specify keypoint\n                # categories, but our implementation supports a more general\n                # alternative schema\n                \"keypoints\": [kpname_1, ..., kpname_K], # length <k> array of keypoint names\n                \"skeleton\": [(kx_a1, kx_b1), ..., (kx_aE, kx_bE)], # list of edge pairs (of keypoint indices), defining connectivity of keypoints.\n            },\n            ...\n        ],\n        'images': [\n            {\n                'id': int, 'file_name': str\n            },\n            ...\n        ],\n        'annotations': [\n            {\n                'id': int,\n                'image_id': int,\n                'category_id': int,\n                'bbox': [tl_x, tl_y, w, h],  # optional (xywh format)\n                \"score\" : float,\n                \"caption\": str,  # an optional text caption for this annotation\n                \"iscrowd\" : <0 or 1>,  # denotes if the annotation covers a single object (0) or multiple objects (1)\n                \"keypoints\" : [x1,y1,v1,...,xk,yk,vk], # or new dict-based format\n                'segmentation': <RunLengthEncoding | Polygon>,  # formats are defined bellow\n            },\n            ...\n        ],\n        'licenses': [],\n        'info': [],\n    }\n\n    Polygon:\n        A flattned list of xy coordinates.\n        [x1, y1, x2, y2, ..., xn, yn]\n\n        or a list of flattned list of xy coordinates if the CCs are disjoint\n        [[x1, y1, x2, y2, ..., xn, yn], [x1, y1, ..., xm, ym],]\n\n        Note: the original COCO spec does not allow for holes in polygons.\n\n        (PENDING) We also allow a non-standard dictionary encoding of polygons\n            {'exterior': [(x1, y1)...],\n             'interiors': [[(x1, y1), ...], ...]}\n\n    RunLengthEncoding:\n        The RLE can be in a special bytes encoding or in a binary array\n        encoding. We reuse the original C functions are in [2]_ in\n        `kwimage.structs.Mask` to provide a convinient way to abstract this\n        rather esoteric bytes encoding.\n\n        For pure python implementations see kwimage:\n            Converting from an image to RLE can be done via kwimage.run_length_encoding\n            Converting from RLE back to an image can be done via:\n                kwimage.decode_run_length\n\n            For compatibility with the COCO specs ensure the binary flags\n            for these functions are set to true.\n\n    Keypoints:\n        (PENDING)\n        Annotation keypoints may also be specified in this non-standard (but\n        ultimately more general) way:\n\n        'annotations': [\n            {\n                'keypoints': [\n                    {\n                        'xy': <x1, y1>,\n                        'visible': <0 or 1 or 2>,\n                        'keypoint_category_id': <kp_cid>,\n                        'keypoint_category': <kp_name, optional>,  # this can be specified instead of an id\n                    }, ...\n                ]\n            }, ...\n        ],\n        'keypoint_categories': [{\n            'name': <str>,\n            'id': <int>,  # an id for this keypoint category\n            'supercategory': <kp_name>  # name of coarser parent keypoint class (for hierarchical keypoints)\n            'reflection_id': <kp_cid>  # specify only if the keypoint id would be swapped with another keypoint type\n        },...\n        ]\n\n        In this scheme the \"keypoints\" property of each annotation (which used\n        to be a list of floats) is now specified as a list of dictionaries that\n        specify each keypoints location, id, and visibility explicitly. This\n        allows for things like non-unique keypoints, partial keypoint\n        annotations. This also removes the ordering requirement, which makes it\n        simpler to keep track of each keypoints class type.\n\n        We also have a new top-level dictionary to specify all the possible\n        keypoint categories.\n\n    Auxillary Channels:\n        For multimodal or multispectral images it is possible to specify\n        auxillary channels in an image dictionary as follows:\n\n        {\n            'id': int, 'file_name': str\n            'channels': <spec>,  # a spec code that indicates the layout of these channels.\n            'auxillary': [  # information about auxillary channels\n                {\n                    'file_name':\n                    'channels': <spec>\n                }, ... # can have many auxillary channels with unique specs\n            ]\n        }\n\n\n.. [1] http://cocodataset.org/#format-data\n\n.. [2] https://github.com/nightrome/cocostuffapi/blob/master/PythonAPI/pycocotools/mask.py\n      \n\n.. |Pypi| image:: https://img.shields.io/pypi/v/kwcoco.svg\n   :target: https://pypi.python.org/pypi/kwcoco\n\n.. |Downloads| image:: https://img.shields.io/pypi/dm/kwcoco.svg\n   :target: https://pypistats.org/packages/kwcoco\n\n.. |ReadTheDocs| image:: https://readthedocs.org/projects/kwcoco/badge/?version=release\n    :target: https://kwcoco.readthedocs.io/en/release/\n\n.. # See: https://ci.appveyor.com/project/jon.crall/kwcoco/settings/badges\n.. |Appveyor| image:: https://ci.appveyor.com/api/projects/status/py3s2d6tyfjc8lm3/branch/master?svg=true\n   :target: https://ci.appveyor.com/project/jon.crall/kwcoco/branch/master\n\n.. |GitlabCIPipeline| image:: https://gitlab.kitware.com/computer-vision/kwcoco/badges/master/pipeline.svg\n   :target: https://gitlab.kitware.com/computer-vision/kwcoco/-/jobs\n\n.. |GitlabCICoverage| image:: https://gitlab.kitware.com/computer-vision/kwcoco/badges/master/coverage.svg?job=coverage\n    :target: https://gitlab.kitware.com/computer-vision/kwcoco/commits/master", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://gitlab.kitware.com/computer-vision/kwcoco", "keywords": "", "license": "Apache 2", "maintainer": "", "maintainer_email": "", "name": "kwcoco", "package_url": "https://pypi.org/project/kwcoco/", "platform": "", "project_url": "https://pypi.org/project/kwcoco/", "project_urls": {"Homepage": "https://gitlab.kitware.com/computer-vision/kwcoco"}, "release_url": "https://pypi.org/project/kwcoco/0.1.0/", "requires_dist": null, "requires_python": "", "summary": "The kwcoco Module", "version": "0.1.0"}, "last_serial": 6978661, "releases": {"0.0.4": [{"comment_text": "", "digests": {"md5": "9281e91af344a768b09e8c85dda84052", "sha256": "9939400b9aa6e92db652671adb0f281e67eb06facfbf512e46b8d475b2b5bc90"}, "downloads": -1, "filename": "kwcoco-0.0.4-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "9281e91af344a768b09e8c85dda84052", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 46112, "upload_time": "2020-03-27T01:00:39", "upload_time_iso_8601": "2020-03-27T01:00:39.144546Z", "url": "https://files.pythonhosted.org/packages/de/c2/5896019590dda3ac0f29290237738921e37160d859f8093adfe592dd9cea/kwcoco-0.0.4-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "03726e4de22420609a80861950e9c01e", "sha256": "dedd2235e3903c7678b1dc0b9dcb785e09d6a2d485025ee2457b9042b39bd1c0"}, "downloads": -1, "filename": "kwcoco-0.0.4-py3-none-any.whl", "has_sig": true, "md5_digest": "03726e4de22420609a80861950e9c01e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 46108, "upload_time": "2020-03-27T01:00:41", "upload_time_iso_8601": "2020-03-27T01:00:41.369523Z", "url": "https://files.pythonhosted.org/packages/42/78/9d9781da0fecebe11fa19c2c544c7665e3f91280b3e958f08414a3ace6d8/kwcoco-0.0.4-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "c4c6a2258f2a128d4c4bdd8b897d9021", "sha256": "0dce1c3a7a22089c929e0d6ba653a59c3a3ae563f55187bbcee2616878d9986b"}, "downloads": -1, "filename": "kwcoco-0.0.4.tar.gz", "has_sig": true, "md5_digest": "c4c6a2258f2a128d4c4bdd8b897d9021", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49525, "upload_time": "2020-03-27T01:00:36", "upload_time_iso_8601": "2020-03-27T01:00:36.178762Z", "url": "https://files.pythonhosted.org/packages/2a/3e/2a12ab3208ae985e72379dd31fb04f4c49b3fc014446dd46d53aaa9c4350/kwcoco-0.0.4.tar.gz"}], "0.1.0": [{"comment_text": "", "digests": {"md5": "976e43e2a3dd7d29f9fbdc3354891043", "sha256": "f7a7a732a2e177be1be24b4c0e1f3fb3f616ba34d61513e19c04a7e081a32e41"}, "downloads": -1, "filename": "kwcoco-0.1.0-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "976e43e2a3dd7d29f9fbdc3354891043", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 60317, "upload_time": "2020-04-08T15:30:50", "upload_time_iso_8601": "2020-04-08T15:30:50.494778Z", "url": "https://files.pythonhosted.org/packages/17/c5/68229131835dd94883ca2d97493f38fda8f9a5e404b23a8b6fcb793b1ca5/kwcoco-0.1.0-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "4fcde31afcff83cb55ffaf250767d701", "sha256": "499c459dc68f1cfc817af320c55094cd1476b71d199343e780e235fb6f1a0d3b"}, "downloads": -1, "filename": "kwcoco-0.1.0-py3-none-any.whl", "has_sig": true, "md5_digest": "4fcde31afcff83cb55ffaf250767d701", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 60313, "upload_time": "2020-04-08T15:30:52", "upload_time_iso_8601": "2020-04-08T15:30:52.570161Z", "url": "https://files.pythonhosted.org/packages/45/09/40c7e7731d93c24ac50b7bcb8bd23ccea2434d227750d45d90d9767f7269/kwcoco-0.1.0-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "124ce53a5431ad6ec8301375e93a9e54", "sha256": "388795f02f8f885c75b5fee2b78f606a89932f5563aea7be43a654adab17373b"}, "downloads": -1, "filename": "kwcoco-0.1.0.tar.gz", "has_sig": true, "md5_digest": "124ce53a5431ad6ec8301375e93a9e54", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61157, "upload_time": "2020-04-08T15:30:48", "upload_time_iso_8601": "2020-04-08T15:30:48.529113Z", "url": "https://files.pythonhosted.org/packages/36/23/a7d8be0018bfade0f4f483c1bab4908ca33d383cc844d61fd943b3008f27/kwcoco-0.1.0.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "976e43e2a3dd7d29f9fbdc3354891043", "sha256": "f7a7a732a2e177be1be24b4c0e1f3fb3f616ba34d61513e19c04a7e081a32e41"}, "downloads": -1, "filename": "kwcoco-0.1.0-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "976e43e2a3dd7d29f9fbdc3354891043", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 60317, "upload_time": "2020-04-08T15:30:50", "upload_time_iso_8601": "2020-04-08T15:30:50.494778Z", "url": "https://files.pythonhosted.org/packages/17/c5/68229131835dd94883ca2d97493f38fda8f9a5e404b23a8b6fcb793b1ca5/kwcoco-0.1.0-py2.py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "4fcde31afcff83cb55ffaf250767d701", "sha256": "499c459dc68f1cfc817af320c55094cd1476b71d199343e780e235fb6f1a0d3b"}, "downloads": -1, "filename": "kwcoco-0.1.0-py3-none-any.whl", "has_sig": true, "md5_digest": "4fcde31afcff83cb55ffaf250767d701", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 60313, "upload_time": "2020-04-08T15:30:52", "upload_time_iso_8601": "2020-04-08T15:30:52.570161Z", "url": "https://files.pythonhosted.org/packages/45/09/40c7e7731d93c24ac50b7bcb8bd23ccea2434d227750d45d90d9767f7269/kwcoco-0.1.0-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "124ce53a5431ad6ec8301375e93a9e54", "sha256": "388795f02f8f885c75b5fee2b78f606a89932f5563aea7be43a654adab17373b"}, "downloads": -1, "filename": "kwcoco-0.1.0.tar.gz", "has_sig": true, "md5_digest": "124ce53a5431ad6ec8301375e93a9e54", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61157, "upload_time": "2020-04-08T15:30:48", "upload_time_iso_8601": "2020-04-08T15:30:48.529113Z", "url": "https://files.pythonhosted.org/packages/36/23/a7d8be0018bfade0f4f483c1bab4908ca33d383cc844d61fd943b3008f27/kwcoco-0.1.0.tar.gz"}]}
{"info": {"author": "Jacob Oscarson", "author_email": "jacob@414soft.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3"], "description": "Funcy Kingston\n==============\n\nI use the excellent `Funcy <https://funcy.readthedocs.io/>`__ library\nfor Python a lot. This is my collection of extras that I have designed\nto work closely together with funcy. Funcy Kingston (Reference, see\n`here <https://youtu.be/U79o7qwul48>`__).\n\nKingston is auto-formatted using\n`yapf <https://github.com/google/yapf>`__.\n\nNice things\n-----------\n\ndig()\n~~~~~\n\nCSS selector like deep value grabbing from almost any object.\n\n.. code:: python\n\n   >>> from kingston import dig\n   >>> dig.xget((1, 2, 3), 1)\n   2\n   >>> dig.xget({'foo': 'bar'}, 'foo')\n   'bar'\n   >>> dig.dig({'foo': 1, 'bar': [1,2,3]}, 'bar.1')\n   2\n   >>> dig.dig({'foo': 1, 'bar': [1,{'baz':'jox'},3]}, 'bar.1.baz')\n   'jox'\n   >>>\n\nThe difference between ``dig.dig()`` and ``funcy.get_in()`` is that you\ncan use shell-like blob patterns to get several values keyed by similar\nnames:\n\n.. code:: python\n\n   >>> from kingston import dig\n   >>> res = dig.dig({'foo': 1, 'foop': 2}, 'f*')\n   >>> res\n   [foo=1:int, foop=2:int]\n   >>> # (textual representation of an indexable object)\n   >>> res[0]\n   foo=1:int\n   >>> res[1]\n   foop=2:int\n   >>>\n\nPattern matching using extended ``dict``'s\n------------------------------------------\n\n``match.Match`` objects are callable objects using a ``dict`` semantic\nthat also matches calls based on the type of the calling parameters:\n\n.. code:: python\n\n   >>> from kingston import match\n   >>> foo = match.Match({int: lambda x: x*100, str: lambda x: f'Hello {x}'})\n   >>> foo(10)\n   1000\n   >>> foo('bar')\n   'Hello bar'\n   >>>\n\n.. code:: python\n\n   >>> from kingston import match\n   >>> foo = match.Match({\n   ...     int: lambda x: x * 100,\n   ...     str: lambda x: f'Hello {x}',\n   ...     (int, int): lambda a, b: a + b\n   ... })\n   >>> foo(10)\n   1000\n   >>> foo('bar')\n   'Hello bar'\n   >>>\n   >>> foo(1, 2)\n   3\n   >>>\n\nYou can use ``typing.Any`` as a wildcard:\n\n.. code:: python\n\n   >>> from typing import Any\n   >>> from kingston import match\n   >>> foo = match.Match({\n   ...     int: lambda x: x * 100,\n   ...     str: (lambda x: f\"Hello {x}\"),\n   ...     (int, Any): (lambda num, x: num * x)\n   ... })\n   >>> foo(10)\n   1000\n   >>> foo('bar')\n   'Hello bar'\n   >>> foo(3, 'X')\n   'XXX'\n   >>> foo(10, 10)\n   100\n   >>>\n\nMatch by value(s)\n~~~~~~~~~~~~~~~~~\n\n``match.VMatch`` will use the *values* of the parameters to do the same\nas as ``match.Match``:\n\n.. code:: python\n\n   >>> from kingston import match\n   >>> foo = match.VMatch({'x': (lambda: 'An x!'), ('x', 'y'): (lambda x,y: 3*(x+y))})\n   >>> foo('x')\n   'An x!'\n   >>> foo('x', 'y')\n   'xyxyxy'\n   >>>\n\nSame as with the type matcher above, ``typing.Any`` works as a wildcard\nwith the value matcher as well:\n\n.. code:: python\n\n   >>> from kingston import match\n   >>> from typing import Any\n   >>> foo = match.VMatch({\n   ...     'x': lambda x: 'An X!',\n   ...     ('y', Any): lambda x, y: 3 * (x + y)\n   ... })\n   >>> foo('x')\n   'An X!'\n   >>> foo('y', 'x')\n   'yxyxyx'\n   >>>\n\nNarrowable collections\n----------------------\n\nUses indexes to narrow collections to fewer values. You can narrow by\ntype, a predicate function or value equality. The return value is always\na new ``Narrowable`` derived type from the initial value. Therefore, you\ncan chain several narrowing operations in the same expression.\n\nErrors raised by the narrowing predicates are considered misses.\n\nSome examples:\n\nNarrow by type\n~~~~~~~~~~~~~~\n\n.. code:: python\n\n   >>> from kingston.primitives import narrowable\n   >>> narrowable((1,2,3,'foo', 'bar'))[int]\n   (1, 2, 3)\n   >>>\n\nNarrow by callable\n~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n   >>> from kingston.primitives import narrowable\n   >>> narrowable((1, 2, 3))[lambda x: x > 1]\n   (2, 3)\n   >>>\n   >>> narrowable((1,2,3,'foo', 'bar'))[int]\n   (1, 2, 3)\n   >>> narrowable((1,2,3,'foo', 'bar'))[lambda x: x > 1]\n   (2, 3)\n   >>> # Note, swallows ValueError raised by 'foo' > 1 etc\n   >>>\n\nSupress empty iterable objects\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n   >>> from kingston.primitives import narrowable\n   >>> narrowable([[1], [2], [], []])[lambda x: x[0]]\n   [[1], [2]]\n   >>>\n\nNarrow using exact match\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n   >>> from kingston.primitives import narrowable\n   >>> narrowable((1, 2, 3, 'foo'))['foo']\n   ('foo',)\n   >>>\n\nNarrow using a regexp\n~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n   >>> from kingston.primitives import narrowable\n   >>> import re\n   >>> narrowable(('foo', 'fom', 'jox', 8, 'fim'))[re.compile('fo.*').match]\n   ('foo', 'fom')\n   >>>\n\nCombine\n~~~~~~~\n\n.. code:: python\n\n   >>> from kingston.primitives import narrowable\n   >>> narrowable((1,2,3,'foo', 'bar'))[str]['foo']\n   ('foo',)\n   >>>\n\nGo deeper\n---------\n\n.. code:: python\n\n   >>> from kingston.primitives import narrowable\n   >>> narrowable((1, 2, 3, (41, 42, 43)))[tuple][0][lambda x: x > 41]\n   (42, 43)\n   >>>\n\nNo matches found\n~~~~~~~~~~~~~~~~\n\nIf no element matches, an empty version of the collection parameter will\nbe returned:\n\n.. code:: python\n\n   >>> from kingston.primitives import narrowable\n   >>> narrowable((1,2,3))[lambda x: x > 3]\n   ()\n   >>>\n\nProgrammatic class creation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nProgrammatic creation of arbitrary named classes in module definition,\nadd methods using a decorator notation:\n\n.. code:: python\n\n   >>> from kingston import lang\n   >>> mystuff = (('Foo', 1), ('Bar', 2))\n   >>> for name, num in mystuff: locals()[name] = lang.mkclass(name, **{'num': num})\n   >>> Foo\n   <class 'kingston.lang.Foo'>\n   >>> Foo.num\n   1\n   >>> \\\n   ... @Foo.classmethod\n   ... def myclassmethod(cls, x):\n   ...     return x + 1\n   >>> Foo.myclassmethod(1)\n   2\n   >>>\n   >>> \\\n   ... @Foo.staticmethod\n   ... def mystaticmethod(x, y):\n   ...     return x + y\n   >>> Foo.mystaticmethod(1, 2)\n   3\n   >>> \\\n   ... @Foo.method\n   ... def mymethod(self, x):\n   ...     self.y = self.num + x\n   ...     return self.y\n   >>> foo = Foo()\n   >>> foo.mymethod(1)\n   2\n   >>> foo.y\n   2\n   >>>\n\nkingston module with developer convenience tools\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``kingston.microscope`` module contains utilities that aid\ndevelopment. It has to ways to inspect live objects:\n\n#. Via 'AbneuYAML'\n\n   AbneuYAML is *\u201cAlmost, but not entirely unlike YAML\u201d*. Objects dumped\n   to \u2018AbneuYAML\u2019 should be easy to get a visual overview of for humans.\n\n   To dump any object:\n\n   .. code:: python\n\n      >>> from kingston import microscope\n      >>> class Cls: pass\n      ...\n      >>> c = Cls()\n      >>> c.foo, c.bar = 1, 2\n      >>> c.sub = Cls()\n      >>> c.sub.foo, c.sub.bar, c.sub.baz = 3, 4, [1, 2]\n      >>> encoded = microscope.abneuyaml(c)\n      >>> print(encoded) #doctest: +ELLIPSIS\n      <__main__.Cls object at 0x...>:Cls\n        foo=1:int\n        bar=2:int\n        sub=<__main__.Cls object at 0x...>:Cls\n          foo=3:int\n          bar=4:int\n          baz=[1, 2]:list\n      >>>\n\nA simple way of creating small DSL's using Python operator overloading.\n-----------------------------------------------------------------------\n\n.. code:: python\n\n   >>> from kingston import lang\n   >>> \\\n   ... class PipingExample(lang.Piping):\n   ...     def __add__(self, value) -> lang.Piping:\n   ...         self.queue(lambda a, b: a + b, value)\n   ...         return self\n   ...\n   >>> simplest_pipe = PipingExample(10)\n   >>> res = simplest_pipe + 10 + 20\n   >>> res()\n   40\n   >>>\n\nMostly, you'll want to use the pipe operator to define simple\ncomposition:\n\n.. code:: python\n\n   >>> from kingston import lang\n   >>> incr = lambda x: x + 1\n   >>> showr = \"It is {}!\".format\n   >>> (lang.ComposePiping(5) >> incr >> incr >> showr)()\n   'It is 7!'\n   >>>", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://www.414soft.com/kingston", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "kingston", "package_url": "https://pypi.org/project/kingston/", "platform": "", "project_url": "https://pypi.org/project/kingston/", "project_urls": {"Homepage": "https://www.414soft.com/kingston"}, "release_url": "https://pypi.org/project/kingston/0.6.4/", "requires_dist": null, "requires_python": "", "summary": "Some Python nicieties", "version": "0.6.4"}, "last_serial": 6928340, "releases": {"0.6.3": [{"comment_text": "", "digests": {"md5": "bf7de0b1aa147c207178447dd8cc4f28", "sha256": "a5c874688e38a4e115985c398bc481e0d9f217a99b7ef065ed97f40620b63184"}, "downloads": -1, "filename": "kingston-0.6.3.tar.gz", "has_sig": false, "md5_digest": "bf7de0b1aa147c207178447dd8cc4f28", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15792, "upload_time": "2020-03-24T15:35:34", "upload_time_iso_8601": "2020-03-24T15:35:34.766817Z", "url": "https://files.pythonhosted.org/packages/28/f5/8bd6e394e268c21e4c6b315e877cc71880111f217e6c2b1a0271529aa53c/kingston-0.6.3.tar.gz"}], "0.6.4": [{"comment_text": "", "digests": {"md5": "4637e5c54edd3c6075e758d690be162a", "sha256": "8b6a7e84b48d09849a2f9e92334240435a3d7b9d2ecfa71f8952fd3fe3a2dc27"}, "downloads": -1, "filename": "kingston-0.6.4.tar.gz", "has_sig": false, "md5_digest": "4637e5c54edd3c6075e758d690be162a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17563, "upload_time": "2020-04-01T15:11:50", "upload_time_iso_8601": "2020-04-01T15:11:50.221457Z", "url": "https://files.pythonhosted.org/packages/4e/81/f7cdf1010756fe1ad076bafe4bd52d1420f668d1473e70e8c533fc350086/kingston-0.6.4.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "4637e5c54edd3c6075e758d690be162a", "sha256": "8b6a7e84b48d09849a2f9e92334240435a3d7b9d2ecfa71f8952fd3fe3a2dc27"}, "downloads": -1, "filename": "kingston-0.6.4.tar.gz", "has_sig": false, "md5_digest": "4637e5c54edd3c6075e758d690be162a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17563, "upload_time": "2020-04-01T15:11:50", "upload_time_iso_8601": "2020-04-01T15:11:50.221457Z", "url": "https://files.pythonhosted.org/packages/4e/81/f7cdf1010756fe1ad076bafe4bd52d1420f668d1473e70e8c533fc350086/kingston-0.6.4.tar.gz"}]}
{"info": {"author": "Danilo de Jesus da Silva Bellini", "author_email": "danilo.bellini@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Environment :: Console", "Environment :: Other Environment", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Java", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only", "Topic :: Database", "Topic :: Scientific/Engineering :: Information Analysis"], "description": "# IOISIS - I/O tools for converting ISIS data in Python\n\nThis is a Python library with a command line interface\nintended to access data from ISIS database files\nand convert among distinct file formats.\n\nThe `bruma-mst2jsonl` command and the `bruma` module\nuses a pre-compiled version\nof [Bruma](https://github.com/scieloorg/Bruma)\nthrough [JPype](https://github.com/jpype-project/jpype),\nwhich requires the JVM.\nThe `iso` and `mst` modules, as well as\nthe `mst2jsonl`, `jsonl2mst`, `iso2jsonl` and `jsonl2iso` commands\ndon't require Bruma.\nBruma only gets downloaded in its first use.\n\n\n## Command Line Interface (CLI)\n\nTo use the CLI command, use `ioisis` or `python -m ioisis`.\nExamples:\n\n```bash\n# Convert file.mst to a JSONL in the standard output stream\nioisis mst2jsonl file.mst\n\n# Convert file.iso to an ASCII file.jsonl\nioisis iso2jsonl --jenc ascii file.iso file.jsonl\n\n# Convert file.jsonl to file.iso where the JSON lines are like\n# {\"tag\": [\"field\", ...], ...}\nioisis jsonl2iso file.jsonl file.iso\n\n# Convert active and logically deleted records from file.mst\n# to file.iso, selecting records and filtering out fields with jq\nioisis mst2jsonl --all file.mst \\\n| jq -c 'select(.[\"35\"] == [\"PRINT\"]) | del(.[\"901\"]) | del(.[\"540\"])'\n| ioisis jsonl2iso - file.iso\n```\n\nBy default, the input and output are the standard streams,\nbut the `bruma-mst2jsonl` MST input and the `jsonl2mst` MST output\nmust be a file name, not a pipe/stream.\nFor the former command,\nthe matching XRF will be found based on the file name.\nFor the latter,\nthe control record is created at the end,\nwhich makes the random access a requirement.\n\nThere are several other options to these commands\nintended to customize the process,\nperhaps the most important of these options\nis the `-m/--mode`, which regards to the JSONL field format.\nThe valid values for it are:\n\n* `field` (*default*):\n  Use the raw field value string (ignore the subfield parsing options)\n* `pairs`:\n  Split the field string as an array of `[key, value]` subfield pairs\n* `nest`:\n  Split the field string as a `{key: value}` object\n\nWhen used together with `--no-number`,\nthese 3 modes are respectively similar\nto the `-mt1`, `-mt2` and `-mt3` options of `isis2json`.\n\nTry `ioisis --help` for more information.\n\n\n## Library\n\nTo load ISIS data, you can use the `iter_records` function\nof the respective module:\n\n```python\nfrom ioisis import bruma, iso\n\n# For MST files with Bruma, you must use the filename\nfor record_dict in bruma.iter_records(\"file.mst\"):\n    ...\n\n# For ISO files, you can either use a file name\n# or any file-like object open in \"rb\" mode\nwith open(\"file.iso\", \"rb\") as raw_iso_file:\n    for record_dict in iso.iter_records(raw_iso_file):\n        ...\n```\n\nSee also the `iter_raw_tl` functions and the `mst.StructCreator` class\nfor more information on how to load data in a more customized way.\n\nOne can generate a single ISO record from a dict of data:\n\n```python\n>>> from ioisis import iso\n>>> iso.dict2bytes({\"1\": [\"testing\"], \"8\": [\"it\"]})\nb'000610000000000490004500001000800000008000300008#testing#it##\\n'\n\n```\n\nSee also the `mst.StructCreator.build_stream` method\nfor information on how to create MST files.\n\nBy default, the `mst` module doesn't use/create XRF files.\nOne can create/load XRF data using the struct created by\nthe `mst.StructCreator.create_xrf_struct` method.\n\n\n### ISO construct containers (lower level data access Python API)\n\nThe `iso` module\nuses the [Construct](https://github.com/construct/construct) library,\nwhich makes it possible to create\na declarative \"structure\" object\nthat can perform bidirectional building/parsing\nof bytestrings (instances of `bytes`)\nor streams (files open in the `\"rb\"` mode)\nfrom/to construct containers (dictionaries).\n\n\n#### Building and parsing a single record\n\nThis low level data access\ndoesn't perform any string encoding/decoding,\nso every *value* in the input dictionary\nused for building some ISO data\nshould be a raw bytestring.\nLikewise, the parser doesn't decode the encoded strings\n(tags, fields and metadata),\nkeeping bytestrings in the result.\n\nHere's an example\nwith a record in the \"minimal\" format expected by the ISO builder.\nThe values are bytestrings,\nand each directory entry matches its field value based on their index.\n\n```python\n>>> lowlevel_dict = {\n...     \"dir\": [{\"tag\": b\"001\"}, {\"tag\": b\"555\"}],\n...     \"fields\": [b\"a\", b\"test\"],\n... }\n\n# Build a single ISO record bytestring from a construct.Container/dict\n>>> iso_data = iso.DEFAULT_RECORD_STRUCT.build(lowlevel_dict)\n>>> iso_data\nb'000570000000000490004500001000200000555000500002#a#test##\\n'\n\n# Parse a single ISO record bytestring to a construct.Container\n>>> con = iso.DEFAULT_RECORD_STRUCT.parse(iso_data)\n\n# The construct.Container instance inherits from dict.\n# The directory and fields are instances of construct.ListContainer,\n# a class that inherits from list.\n>>> [directory[\"tag\"] for directory in con[\"dir\"]]\n[b'001', b'555']\n>>> con.fields  # Its items can be accessed as attributes\nListContainer([b'a', b'test'])\n>>> len(con.fields) == con.num_fields == 2  # A computed attribute\nTrue\n\n# This function directly converts that construct.Container object\n# to a dictionary of already decoded strings in the the more common\n# {tag: [field, ...], ..} format (default ISO encoding is cp1252):\n>>> iso.con2dict(con).items()  # It's a defaultdict(list)\ndict_items([('1', ['a']), ('555', ['test'])])\n\n```\n\n\n#### Other record fields\n\nEach ISO record is divided in 3 parts:\n\n* Leader (24 bytes header with metadata)\n* Directory (metadata for each field value, mainly its 3-bytes *tag*)\n* Fields (the field values themselves as bytestrings)\n\nThe *leader* has:\n\n* Single character metadata (`status`, `type`, `coding`)\n* Two numeric metadata (`indicator_count` and `identifier_len`),\n  which should range only from 0 to 9\n* Free room for \"vendor-specific\" stuff as bytestrings:\n  `custom_2` and `custom_3`,\n  where the numbers are their size in bytes\n* An entry map, i.e., the size of each field of the directory:\n  `len_len`, `pos_len` and `custom_len`,\n  which should range only from 0 to 9\n* A single byte, `reserved`, literally reserved for future use\n\n```python\n>>> con.len_len, con.pos_len, con.custom_len\n(4, 5, 0)\n\n```\n\nActually, the `reserved` is part of the entry map,\nbut it has no specific meaning there,\nand it doesn't need to be a number.\nApart from the entry map and the not included length/address fields,\nnone of these metadata has any meaning when reading the ISO content,\nand they're all filled with zeros by default\n(the ASCII zero when they're strings).\n\n```python\n>>> con.status, con.type, con.coding, con.indicator_count\n(b'0', b'0', b'0', 0)\n\n```\n\nLength and position fields that are stored in the record\n(`total_len`, `base_addr`, `dir.len`, `dir.pos`)\nare computed in build time and checked on parsing.\nWe don't need to worry about these fields,\nbut we can read them if needed.\nFor example, one directory record (a dictionary) has this:\n\n```python\n>>> con.dir[1]\nContainer(tag=b'555', len=5, pos=2, custom=b'')\n\n```\n\nAs the default `dir.custom` field has zero length,\nit's not really useful for most use cases.\nGiven that, we've already seen all the fields there are\nin the low level ISO representation of a single record.\n\n\n#### Tweaking the field lengths\n\nThe ISO2709 specification tells us\nthat a directory entry should have exactly 12 bytes,\nwhich means that `len_len + pos_len + custom_len` should be 9.\nHowever, that's not an actual restriction for this library,\nso we don't need to worry about that,\nas long as the entry map have the correct information.\n\nLet's customize the length to get a smaller ISO\nwith some data in the `custom` field of the directory,\nusing a 8 bytes directory:\n\n```python\n>>> dir8_dict = {\n...     \"len_len\": 1,\n...     \"pos_len\": 3,\n...     \"custom_len\": 1,\n...     \"dir\": [{\"tag\": b\"001\", \"custom\": b\"X\"}, {\"tag\": b\"555\"}],\n...     \"fields\": [b\"a\", b\"test\"],\n... }\n>>> dir8_iso = iso.DEFAULT_RECORD_STRUCT.build(dir8_dict)\n>>> dir8_iso\nb'0004900000000004100013100012000X55550020#a#test##\\n'\n>>> dir8_con = iso.DEFAULT_RECORD_STRUCT.parse(dir8_iso)\n>>> dir8_con.dir[0]\nContainer(tag=b'001', len=2, pos=0, custom=b'X')\n>>> dir8_con.dir[1]  # The default is always zero!\nContainer(tag=b'555', len=5, pos=2, custom=b'0')\n>>> dir8_con.len_len, dir8_con.pos_len, dir8_con.custom_len\n(1, 3, 1)\n\n```\n\nWhat happens if we try to build from a dictionary\nthat doesn't fit with the given sizes?\n\n```python\n>>> invalid_dict = {\n...     \"len_len\": 1,\n...     \"pos_len\": 9,\n...     \"dir\": [{\"tag\": b\"555\"}],\n...     \"fields\": [b\"a string with more than 9 characters\"],\n... }\n>>> iso.DEFAULT_RECORD_STRUCT.build(invalid_dict)\nTraceback (most recent call last):\n  ...\nconstruct.core.StreamError: Error in path (building) -> dir -> len\nbytes object of wrong length, expected 1, found 2\n\n```\n\n\n### ISO files, line breaking and delimiters\n\nThe ISO files usually have more than a single record.\nHowever, these files are created by simply concatenating ISO records.\nThat simple: concatenating two ISO files\nshould result in another valid ISO file\nwith all the records from both.\n\nAlthough that's not part of the ISO2709 specification,\nthe `iso.DEFAULT_RECORD_STRUCT` parser/builder object\nassumes that:\n\n* All lines of a given record but the last one\n  must have exactly 80 bytes,\n  and a line feed (`\\x0a`) must be included after that;\n* Every line must belong to a single record;\n* The last line of a single record must finish with a `\\x0a`.\n\nThat's the behavior of `iso.LineSplitRestreamed`,\nwhich \"wraps\" internally the record structure\nto give this \"line splitting\" behavior,\nbut that can be avoided by setting the `line_len` to `None` or zero\nwhen creating a custom record struct.\n\n\n#### Parsing/building data with meaningful line breaking characters\n\nSuppose we want to store these values:\n\n```python\n>>> newline_info_dict = {\n...     \"dir\": [{\"tag\": b\"SIZ\"}, {\"tag\": b\"SIZ\"}, {\"tag\": b\"SIZ\"}],\n...     \"fields\": [b\"linux^c\\n^s1\", b\"win^c\\r\\n^s2\", b\"mac^c\\r^s1\"],\n... }\n\n```\n\nThat makes sense as an example of an ISO record\nwith three `SIZ` fields, each with three subfields,\nwhere the second subfield\nis the default newline character of some environment,\nand the third subfield is its size.\nAlthough can build that using the `DEFAULT_RECORD_STRUCT`\n(the end of line never gets mixed with the content),\nwe know beforehand that our values have newline characters,\nand we might want an alternative struct\nwithout that \"wrapped\" line breaking behavior:\n\n```python\n>>> breakless_struct = iso.create_record_struct(line_len=0)\n>>> newline_info_iso = breakless_struct.build(newline_info_dict)\n>>> newline_info_iso\nb'000950000000000610004500SIZ001200000SIZ001100012SIZ001000023#linux^c\\n^s1#win^c\\r\\n^s2#mac^c\\r^s1##'\n>>> newline_info_con = breakless_struct.parse(newline_info_iso)\n>>> newline_info_simple_dict = dict(iso.con2dict(newline_info_con))\n>>> newline_info_simple_dict\n{'SIZ': ['linux^c\\n^s1', 'win^c\\r\\n^s2', 'mac^c\\r^s1']}\n>>> newline_info_iso == iso.dict2bytes(\n...     newline_info_simple_dict,\n...     record_struct=breakless_struct,\n... )\nTrue\n\n```\n\n\n#### Parsing/building with a custom line breaking and delimiters\n\nThe default builder/parser for a single record\nwas created with:\n\n```python\nDEFAULT_RECORD_STRUCT = iso.create_record_struct(\n    field_terminator=iso.DEFAULT_FIELD_TERMINATOR,\n    record_terminator=iso.DEFAULT_RECORD_TERMINATOR,\n    line_len=iso.DEFAULT_LINE_LEN,\n    newline=iso.DEFAULT_NEWLINE,\n)\n```\n\nWe can create a custom object using other values.\nTo use it, we'll pass that object\nas the `record_struct` keyword argument\nwhen calling the functions.\n\n\n```python\n>>> simple_data = {\n...     \"OBJ\": [\"mouse\", \"keyboard\"],\n...     \"INF\": [\"old\"],\n...     \"SIZ\": [\"34\"],\n... }\n>>> custom_struct = iso.create_record_struct(\n...     field_terminator=b\";\",\n...     record_terminator=b\"@\",\n...     line_len=20,\n...     newline=b\"\\n\",\n... )\n>>> simple_data_iso = iso.dict2bytes(\n...     simple_data,\n...     record_struct=custom_struct,\n... )\n>>> from pprint import pprint\n>>> pprint(simple_data_iso.decode(\"ascii\"))\n('00096000000000073000\\n'\n '4500OBJ000600000OBJ0\\n'\n '00900006INF000400015\\n'\n 'SIZ000300019;mouse;k\\n'\n 'eyboard;old;34;@\\n')\n>>> simple_data_con = custom_struct.parse(simple_data_iso)\n>>> simple_data == iso.con2dict(simple_data_con)\nTrue\n\n```\n\nThe calculated sizes don't count the extra line breaking characters:\n\n```python\n>>> simple_data_con.total_len, simple_data_con.base_addr\n(96, 73)\n\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/scieloorg/ioisis", "keywords": "", "license": "2-clause BSD", "maintainer": "", "maintainer_email": "", "name": "ioisis", "package_url": "https://pypi.org/project/ioisis/", "platform": "", "project_url": "https://pypi.org/project/ioisis/", "project_urls": {"Homepage": "https://github.com/scieloorg/ioisis"}, "release_url": "https://pypi.org/project/ioisis/0.3.0/", "requires_dist": null, "requires_python": ">=3.6", "summary": "I/O for ISIS files in Python", "version": "0.3.0"}, "last_serial": 6829186, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "178e5c084114ea778f3b84fe04bd35a5", "sha256": "fb2f4922a0d16b30b56c9d40a228cab108a60ac24a89f1001470451fcf4035b7"}, "downloads": -1, "filename": "ioisis-0.1.0.tar.gz", "has_sig": false, "md5_digest": "178e5c084114ea778f3b84fe04bd35a5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 8367, "upload_time": "2019-11-08T22:20:46", "upload_time_iso_8601": "2019-11-08T22:20:46.695813Z", "url": "https://files.pythonhosted.org/packages/37/22/2e8b6022181ad73dbe089c96a7399850d86546322f87689bd1de99051de5/ioisis-0.1.0.tar.gz"}], "0.1.1": [{"comment_text": "", "digests": {"md5": "f70f7ce1dc724d2053d543f51dbcf19e", "sha256": "f007e67a75c5b2496b527174dd004d616e320b463483ebc374bef9090f3316cf"}, "downloads": -1, "filename": "ioisis-0.1.1.tar.gz", "has_sig": false, "md5_digest": "f70f7ce1dc724d2053d543f51dbcf19e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 18097, "upload_time": "2019-11-28T00:22:08", "upload_time_iso_8601": "2019-11-28T00:22:08.998337Z", "url": "https://files.pythonhosted.org/packages/f5/1a/507d9069567ae8c6f1e20f1a0dd9660ebf0116089db15e6c4ed667ee6491/ioisis-0.1.1.tar.gz"}], "0.1.2": [{"comment_text": "", "digests": {"md5": "a7acfee50d5b38f95ec238dad97cb800", "sha256": "8ac76e4ca3ae3aa07502b79f285a8c0a953070c2b3d4b87c974b0376c8c69e18"}, "downloads": -1, "filename": "ioisis-0.1.2.tar.gz", "has_sig": false, "md5_digest": "a7acfee50d5b38f95ec238dad97cb800", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 19042, "upload_time": "2019-12-05T21:07:11", "upload_time_iso_8601": "2019-12-05T21:07:11.216555Z", "url": "https://files.pythonhosted.org/packages/78/4b/22ab2def9099a121ae8d9a770ef3d36ab5b036393b26a0cc1183adc504fb/ioisis-0.1.2.tar.gz"}], "0.2.0": [{"comment_text": "", "digests": {"md5": "e0e39e282e9707a543bf1563ed7b5b67", "sha256": "eafc8e407b73c76fa1a13bdf6399ae9067f3ecb19406bcdf2f71b82a6102951c"}, "downloads": -1, "filename": "ioisis-0.2.0.tar.gz", "has_sig": false, "md5_digest": "e0e39e282e9707a543bf1563ed7b5b67", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 26661, "upload_time": "2019-12-18T20:52:48", "upload_time_iso_8601": "2019-12-18T20:52:48.369263Z", "url": "https://files.pythonhosted.org/packages/fa/f8/44992ec9fdfe6f4d7a1a19352ee993ecdb4cbe210ccfb1bb1c593c9fdb83/ioisis-0.2.0.tar.gz"}], "0.3.0": [{"comment_text": "", "digests": {"md5": "4babc543846a2f7af45343565301550c", "sha256": "3e291b1e8b3e183d39339f516d65d24d14501e118f0b8f7fccabb55a809b8af7"}, "downloads": -1, "filename": "ioisis-0.3.0.tar.gz", "has_sig": false, "md5_digest": "4babc543846a2f7af45343565301550c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 38001, "upload_time": "2020-02-27T17:52:42", "upload_time_iso_8601": "2020-02-27T17:52:42.800992Z", "url": "https://files.pythonhosted.org/packages/16/e7/b57c5b21143864c2b1b7bef871d12797a3a9314fd04ad58be446ca252100/ioisis-0.3.0.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "4babc543846a2f7af45343565301550c", "sha256": "3e291b1e8b3e183d39339f516d65d24d14501e118f0b8f7fccabb55a809b8af7"}, "downloads": -1, "filename": "ioisis-0.3.0.tar.gz", "has_sig": false, "md5_digest": "4babc543846a2f7af45343565301550c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 38001, "upload_time": "2020-02-27T17:52:42", "upload_time_iso_8601": "2020-02-27T17:52:42.800992Z", "url": "https://files.pythonhosted.org/packages/16/e7/b57c5b21143864c2b1b7bef871d12797a3a9314fd04ad58be446ca252100/ioisis-0.3.0.tar.gz"}]}
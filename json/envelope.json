{"info": {"author": "Edvard Rejthar", "author_email": "edvard.rejthar@nic.cz", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 3"], "description": "# envelope\n\n[![Build Status](https://travis-ci.org/CZ-NIC/envelope.svg?branch=master)](https://travis-ci.org/CZ-NIC/envelope)\n\nQuick layer over [python-gnupg](https://bitbucket.org/vinay.sajip/python-gnupg/src), [M2Crypto](https://m2crypto.readthedocs.io/), [smtplib](https://docs.python.org/3/library/smtplib.html), [magic](https://pypi.org/project/python-magic/) and [email](https://docs.python.org/3/library/email.html?highlight=email#module-email) handling packages. Their common usecases merged into a single function. Want to sign a text and tired of forgetting how to do it right? You do not need to know everything about GPG or S/MIME, you do not have to bother with importing keys. Do not hassle with reconnecting SMTP server. Do not study various headers meanings to let your users unsubscribe via a URL.  \nYou insert a message and attachments and receive signed and/or encrypted output to the file or to your recipients' e-mail.  \nJust single line of code. With the great help of the examples below.  \n\n```python3\nenvelope(\"my message\")\n    .subject(\"hello world\")\n    .to(\"example@example.com\")\n    .attach(file_contents, filename=\"attached-file.txt\")\n    .smtp(\"localhost\", 587, \"user\", \"pass\", \"starttls\")\n    .signature()\n    .send()\n```\n\n- [Installation](#installation)\n  * [Bash completion](#bash-completion)\n- [Usage](#usage)\n  * [CLI](#cli)\n  * [Module: one-liner function](#module-one-liner-function)\n  * [Module: fluent interface](#module-fluent-interface)\n- [Documentation](#documentation)\n  * [Command list](#command-list)\n    + [Input / Output](#input--output)\n    + [Cipher standard method](#cipher-standard-method)\n    + [Signing](#signing)\n    + [Encrypting](#encrypting)\n    + [Sending](#sending)\n      - [Specific headers](#specific-headers)\n    + [Supportive](#supportive)\n  * [Default values](#default-values)\n  * [Converting object to str or bool](#converting-object-to-str-or-bool)\n- [Examples](#examples)\n  * [Signing and encrypting](#signing-and-encrypting)\n  * [Sending](#sending-1)\n  * [Attachment](#attachment)\n  * [Complex example](#complex-example)\n- [Related affairs](#related-affairs)\n  * [Configure your SMTP](#configure-your-smtp)\n  * [Choose ciphering method](#choose-ciphering-method)\n    + [Configure your GPG](#configure-your-gpg)\n    + [Configure your S/MIME](#configure-your-smime)\n  * [DNS validation tools](#dns-validation-tools)\n    + [SPF](#spf)\n    + [DKIM](#dkim)\n    + [DMARC](#dmarc)\n\n\n# Installation\n* If planning to use S/MIME, you should ensure some prerequisites:\n```bash\nsudo apt install swig\npip3 install M2Crypto\n```\n* Install with a single command from [PyPi](https://pypi.org/project/envelope/)\n    ```bash \n    pip3 install envelope\n    ```\n    * Or install current GitHub master\n    ```bash\n    pip3 install git+https://github.com/CZ-NIC/envelope.git\n    ```\n    * Or just download the project and launch `./envelope.py`\n* If planning to send e-mails, prepare SMTP credentials or visit [Configure your SMTP](#configure-your-smtp) tutorial.\n* If your e-mails are to be received outside your local domain, visit [DMARC](#dmarc) section.\n* If planning to sign/encrypt with GPG, install the corresponding package and possibly see [Configure your GPG](#configure-your-gpg) tutorial.\n```bash\nsudo apt install gpg\n```\n\n## Bash completion\n1. Run: apt-get install bash-completion jq\n2. Copy: extra/convey-autocompletion.bash to /etc/bash_completion.d/\n3. Restart terminal\n\n# Usage\nAs an example, let's produce in three equal ways an `output_file` with the GPG-encrypted \"Hello world\" content.\n## CLI\nLaunch as a CLI application in terminal, see `envelope --help`\n  \n```bash\nenvelope --message \"Hello world\" \\\n               --output \"/tmp/output_file\" \\\n               --sender \"me@example.com\" \\\n               --to \"remote_person@example.com\" \\\n               --encrypt-path \"/tmp/remote_key.asc\"\n```\n## Module: one-liner function\nYou can easily write a one-liner function that encrypts your code or sends an e-mail from within your application when imported as a module. See `pydoc3 envelope` or documentation below.\n\n```python3\nimport envelope\nenvelope(message=\"Hello world\",\n        output=\"/tmp/output_file\",\n        sender=\"me@example.com\",\n        to=\"remote_person@example.com\",\n        encrypt=\"/tmp/remote_key.asc\")\n```\n\n## Module: fluent interface\nComfortable way to create the structure if your IDE supports autocompletion.\n```python3\nimport envelope\nenvelope().message(\"Hello world\")\\\n    .output(\"/tmp/output_file\")\\\n    .sender(\"me@example.com\")\\\n    .to(\"remote_person@example.com\")\\\n    .encrypt(key_path=\"/tmp/remote_key.asc\")\n```\n\nNote: if autocompletion does not work, use **`from envelope import envelope`** instead of `import envelope`.  \n(For example, Jupyter can autocomplete with `import envelope` but PyCharm cannot because it does not serves itself with a [running kernel](https://youtrack.jetbrains.com/issue/PY-38086#comment=27-3716668).)\n\n# Documentation\n\nBoth `envelope --help` for CLI arguments help and `pydoc3 envelope` to see module arguments help should contain same information as here.\n\n## Command list\nAll parameters are optional. \n\n* **--param** is used in CLI\n* **envelope(param=)** is a one-liner argument\n* **.param(value)** denotes a positional argument\n* **.param(value=)** denotes a keyword argument\n \nAny fetchable contents means plain text, bytes or stream (ex: from open()). In *module interface*, you may use Path object to the file. In *CLI interface*, additional flags are provided.         \n\n### Input / Output\n  * **message**: Message / body text.\n    * **--message**: String\n    * **--input**: *(CLI only)* Path to the message file. (Alternative to `--message` parameter.)\n    * **envelope(message=)**: Any fetchable contents\n    * **.message(text)**:  String or stream.\n    * **.message(path=None)**: Path to the file.\n    \n    Equivalents for setting a string (in *Python* and in *Bash*).\n    ```python3\n    envelope(message=\"hello\") == envelope().message(\"hello\")\n    ```\n    ```bash\n    envelope --message \"hello\"\n    ``` \n    Equivalents for setting contents of a file (in *Python* and in *Bash*).\n    ```python3\n    from pathlib import Path\n    envelope(message=Path(\"file.txt\")) == envelope(message=open(\"file.txt\")) == envelope.message(path=\"file.txt\") \n    ```\n    ```bash\n    envelope --input file.txt\n    ```\n  * **output**: Path to file to be written to (else the contents is returned).\n    * **--output**\n    * **envelope(output=)**\n    * **.output(output_file)**\n### Cipher standard method\nNote that if neither *gpg* nor *smime* is specified, we try to determine the method automatically.\n  * **gpg**: True to prefer GPG over S/MIME or home path to GNUPG rings (otherwise default ~/.gnupg is used)\n    * **--gpg [path]**\n    * **envelope(gpg=True)**\n    * **.gpg(gnugp_home=True)**\n  * **.smime**: Prefer S/MIME over GPG\n    * **--smime**\n    * **envelope(smime=True)**\n    * **.smime()**\n### Signing\n  * **sign**: Sign the message.\n    * **--sign**:\n        * \"auto\" for turning on signing if there is a key matching to the \"from\" header\n        * GPG: Blank for user default key or key ID/fingerprint.\n        * S/MIME: Any fetchable contents with key.\n    * **--sign-path**: S/MIME: Filename with the sender\\'s private key. (Alternative to `sign` parameter.)\n    * **--passphrase**: Passphrase to the key if needed.\n    * **--attach-key**: GPG: Blank for appending public key to the attachments when sending.\n    * **--cert**: S/MIME: Certificate contents if not included in the key.\n    * **--cert-path**: S/MIME: Filename with the sender's private cert if cert not included in the key. (Alternative to `cert` parameter.)\n    * **envelope(sign=)**:\n        * GPG: True for user default key or key ID/fingerprint.\n        * S/MIME: Key contents.\n    * **envelope(passphrase=)**: Passphrase to the key if needed.\n    * **envelope(attach_key=)**: GPG: Append public key to the attachments when sending.\n    * **envelope(cert=)**: S/MIME: Any fetchable contents.\n    * **.sign(key=True, passphrase=, attach_key=False, cert=None, key_path=None)**: Sign now (and you may specify the parameters)         \n    * **.signature(key=True, passphrase=, attach_key=False, cert=None, key_path=None)**: Sign later (when launched with *.sign()*, *.encrypt()* or *.send()* functions\n### Encrypting\nIf the GPG encryption fails, it tries to determine which recipient misses the key.\n\n  * **encrypt**:  Recipient GPG public key or S/MIME certificate to be encrypted with. \n    * **--encrypt**: Key string or blank or 1/true/yes if the key should be in the ring from before. Put 0/false/no to disable `encrypt-path`.\n    * **--encrypt-path** *(CLI only)*: Recipient public key stored in a file path. (Alternative to `--encrypt`.)  \n    * **envelope(encrypt=)**: Any fetchable contents\n    * **.encrypt(key=True, sign=, key_path=)**: With *sign*, you may specify boolean or default signing key ID/fingerprint for GPG or Any fetchable contents with S/MIME key + signing certificate. If import needed, put your encrypting GPG key contents or S/MIME certificate to *key* or path to the key/certificate contents file in *key_path*.\n    * **.encryption(key=True, key_path=)**: Encrypt later (when launched with *.sign()*, *.encrypt()* or *.send()* functions. If needed, in the parameters specify Any fetchable contents with GPG encryption key or S/MIME encryption certificate. \n  * **to**: E-mail or list. When encrypting, we use keys of these identities.\n    * **--to**: One or more e-mail addresses.\n    * **envelope(to=)**: E-mail or their list.\n    * **.to(email_or_list)**:\n      ```bash\n      envelope --to first@example.com second@example.com --message \"hello\" \n      ```  \n  * **sender**: E-mail \u2013 needed to choose our key if encrypting.\n    * **--sender** E-mail\n    * **--no-sender** Declare we want to encrypt and never decrypt back.\n    * **--from** Alias for *--sender*\n    * **envelope(sender=)**: Sender e-mail or False to explicitly omit. When encrypting without sender, we do not use their key so that we will not be able to decipher again.\n    * **.sender(email)**: E-mail or False.\n    * **.from_(email)**: an alias for *.sender*\n### Sending\n  * **send**: Send the message to the recipients by e-mail. True (blank in *CLI*) to send now or False to print out debug information.\n    * **--send**\n    * **envelope(send=)**\n    * **.send(send=True, sign=None, encrypt=None)**\n        * *send*: True to send now. False (or 0/false/no in *CLI*) to print debug information.\n    \n    ```bash\n    $ envelope --to \"user@example.org\" --message \"Hello world\" --send 0\n    ****************************************************************************************************\n    Have not been sent from  to user@example.org\n    \n    Content-Type: text/html; charset=\"utf-8\"\n    Content-Transfer-Encoding: 7bit\n    MIME-Version: 1.0\n    Subject:\n    From:\n    To: user@example.org\n    Date: Mon, 07 Oct 2019 16:13:37 +0200\n    Message-ID: <157045761791.29779.5279828659897745855@...>\n    \n    Hello world\n    ```\n  * **subject**: Mail subject. Gets encrypted with GPG, stays visible with S/MIME.\n    * **--subject**\n    * **envelope(subject=)**\n    * **.subject(text)**     \n  * **cc**: E-mail or their list\n    * **--cc**\n    * **envelope(cc=)**\n    * **.cc(email_or_list)**\n  * **bcc**: E-mail or their list\n    * **--bcc**\n    * **envelope(bcc=)**\n    * **.bcc(email_or_list)**\n  * **reply-to**: E-mail to be replied to. The field is not encrypted.\n    * **--reply-to**\n    * **envelope(reply_to=)**\n    * **.reply_to(email)**\n  * **smtp**: SMTP server\n    * **--smtp**\n    * **envelope(smtp=)**\n    * **.smtp(host=\"localhost\", port=25, user=, password=, security=)**\n    * Parameters:\n        * `host` may include hostname or any of the following input formats (ex: path to an INI file or a `dict`)\n        * `security` if not set, automatically set to `starttls` for port *587* and to `tls` for port *465*\n    * Input format may be in the following form:\n        * `None` default localhost server used\n        * `smtplib.SMTP` object\n        * `list` or `tuple` having `host, [port, [username, password, [security]]]` parameters\n            * ex: `envelope --smtp localhost 125 me@example.com` will set up host, port and username parameters\n        * `dict` specifying {\"host\": ..., \"port\": ...}\n            * ex: `envelope --smtp '{\"host\": \"localhost\"}'` will set up host parameter\n        * `str` hostname or path to an INI file (existing file, ending at `.ini`, with the section [SMTP])\n            ```ini\n            [SMTP]\n            host = example.com\n            port = 587            \n            ```\n    * Do not fear to pass the `smtp` in a loop, we make just a single connection to the server. If timed out, we attempt to reconnect once.\n    ```python3\n    smtp = localhost, 25\n    for mail in mails:\n        envelope(...).smtp(smtp).send()\n    ```\n  * **attachments**\n    * **--attachment**: Path to the attachment, followed by optional file name to be used and/or mime type. This parameter may be used multiple times.\n    ```bash\n    envelope --attachment \"/tmp/file.txt\" \"displayed-name.txt\" \"text/plain\" --attachment \"/tmp/another-file.txt\"\n    ```\n    * **gpggp(attachments=)**: Attachment or their list. Attachment is defined by any fetchable contents, optionally in tuple with the file name to be used in the e-mail and/or mime type: `content [,name] [,mimetype]`\n    ```python3\n    envelope(attachments=[(Path(\"/tmp/file.txt\"), \"displayed-name.txt\", \"text/plain\"), Path(\"/tmp/another-file.txt\"])\n    ```    \n    * **.attach(attachment_or_list=, path=, mimetype=, filename=)**: Three different usages.\n        * **.attach(attachment_or_list=, mimetype=, filename=)**: You can put Any fetchable contents in *attachment_or_list* and optionally mimetype or displayed filename.\n        * **.attach(path=, mimetype=, filename=)**: You can specify path and optionally mimetype or displayed filename.\n        * **.attach(attachment_or_list=)**: You can put a list of attachments.\n    ```python3\n    envelope().attach(path=\"/tmp/file.txt\").attach(path=\"/tmp/another-file.txt\")\n    ```\n    * **mime**: Set contents mime subtype: \"auto\" (default), \"html\" or \"plain\" for plain text. Ignored if `Content-Type` header put to the message.         \n        * **--mime SUBTYPE**\n        * **envelope(mime=)**\n        * **.mime(subtype=\"auto\", nl2br=\"auto\")**\n            * nl2br: True: envelope will append `<br>` to every line break in the HTML message. \"auto\": line breaks are changed only if there is no `<br` or `<p` in the HTML message,\n    * **headers**: Any custom headers (these will not be encrypted with GPG nor S/MIME)\n        * **--header name value** (may be used multiple times)\n        * **envelope(headers=[(name, value)])**\n        * **.header(name, value)**\n        \n        Equivalent headers: \n        ```bash\n        envelope --header X-Mailer my-app\n        ```\n        \n        ```python3\n        envelope(headers=[(\"X-Mailer\", \"my-app\")])\n        envelope().header(\"X-Mailer\", \"my-app\")\n        ```                \n#### Specific headers\nThese helpers are available via fluent interface.\n    \n* **.list_unsubscribe(uri=None, one_click=False, web=None, email=None)**: You can specify either url, email or both.\n    * **.list_unsubscribe(uri)**: We try to determine whether this is e-mail and prepend brackets and 'https:'/'mailto:' if needed. Ex: `me@example.com?subject=unsubscribe`, `example.com/unsubscribe`, `<https://example.com/unsubscribe>`\n    * **.list_unsubscribe(email=)**: E-mail address. Ex: `me@example.com`, `mailto:me@example.com`\n    * **.list_unsubscribe(web=, one_click=False)**: Specify URL. Ex: `example.com/unsubscribe`, `http://example.com/unsubscribe`. If `one_click=True`, rfc8058 List-Unsubscribe-Post header is added. This says user can unsubscribe with a single click that is realized by a POST request in order to prevent e-mail scanner to access the unsubscribe page by mistake. A 'https' url must be present.\n\n    ```python3\n    # These will produce:\n    # List-Unsubscribe: <https://example.com/unsubscribe>\n    envelope().list_unsubscribe(\"example.com/unsubscribe\")\n    envelope().list_unsubscribe(web=\"example.com/unsubscribe\")\n    envelope().list_unsubscribe(\"<https://example.com/unsubscribe>\")\n    \n    # This will produce:\n    # List-Unsubscribe: <https://example.com/unsubscribe>, <mailto:me@example.com?subject=unsubscribe>\n    envelope().list_unsubscribe(\"example.com/unsubscribe\", mail=\"me@example.com?subject=unsubscribe\")\n    ```    \n    \n* **.auto_submitted**: \n    * **.auto_submitted(val=\"auto-replied\")**: Direct response to another message by an automatic process. \n    * **.auto_submitted.auto_generated()**: automatic (often periodic) processes (such as UNIX \"cron jobs\") which are not direct responses to other messages\n    * **.auto_submitted.no()**: message was originated by a human\n\n```python3\nenvelope().auto_submitted()  # mark message as automatic        \nenvelope().auto_submitted.no()  # mark message as human produced\n```    \n### Supportive\n  * **.recipients()**: Return set of all recipients \u2013 To, Cc, Bcc\n    * **.recipients(clear=True)**: All To, Cc and Bcc recipients are removed and the object is returned.\n  * Read message and subject by **.message()** and **.subject()**\n  * **.preview()**: Returns the string of the message or data with the readable text.\n            Ex: whilst we have to use quoted-printable (as seen in __str__), here the output will be plain text.\n  * **check**: Check SMTP connection and returns True/False if succeeded. Tries to find SPF, DKIM and DMARC DNS records depending on the sender's domain and print them out.\n    * **--check**\n    * **.check()**\n    \n    ```bash\n    $ envelope --smtp localhost 25 --sender me@example.com --check \n    SPF found on the domain example.com: v=spf1 -all\n    See: dig -t SPF example.com && dig -t TXT example.com\n    DKIM found: ['v=DKIM1; g=*; k=rsa; p=...']\n    Could not spot DMARC.\n    Trying to connect to the SMTP...\n    Check succeeded.\n    ```\n * *static* **.load(message)** **(experimental)**: Parse any fetchable contents like an EML file to build an Envelope object.\n    * Still considered experimental: it cannot read an attachment which stays a mere part of the body, it cannot decrypt.\n    * Note that if you will send this reconstructed message, you might not probably receive it due to the Message-ID duplication.\n        Delete at least Message-ID header prior to re-sending. \n    ```python3\n   envelope.load(\"Subject: testing message\").subject()  # \"testing message\"\n    ```\n    \n## Default values\n\nIn *module* interface, you may set the defaults when accessing `envelope.default` instance. \n\n```python3\nenvelope.default.subject(\"Test subject\").signature()\nenvelope(\"Hello\")  # this message has a default subject and is signed by default when sent\n```\n\n## Converting object to str or bool\n\nWhen successfully signing, encrypting or sending, object is resolvable to True and signed text / produced e-mail could be obtained via str().\n\n```python3\no = envelope(\"message\", sign=True)\nstr(o)  # signed text\nbool(o)  # True\n```\n\n# Examples\n\n## Signing and encrypting\n\nSign the message.\n```python3\nenvelope(message=\"Hello world\", sign=True)\n```\n\nSign the message loaded from a file by standard pathlib library\n```python3\nfrom pathlib import Path\nenvelope(message=Path(\"/tmp/message.txt\"), sign=True)\n```\n\nSign the message got from a file-stream\n```python3\nwith open(\"/tmp/message.txt\") as f:\n    envelope(message=f, sign=True)\n```\n\nSign and encrypt the message so that's decryptable by keys for me@example.com and remote_person@example.com (that should already be loaded in the keyring).\n```python3 \nenvelope(message=\"Hello world\", sign=True\n        encrypt=True,\n        sender=\"me@example.com\",\n        to=\"remote_person@example.com\")\n```\n\nSign and encrypt the message so that's decryptable by keys for me@example.com and remote_person@example.com (that get's imported to the keyring from the file).\n```python3 \nenvelope(message=\"Hello world\", sign=True\n        encrypt=Path(\"/tmp/remote_key.asc\"),\n        sender=\"me@example.com\",\n        to=\"remote_person@example.com\")\n```\n\nSign the message via different keyring.\n```python3\nenvelope(message=\"Hello world\", sign=True, gnupg=\"/tmp/my-keyring/\")\n```\n\nSign the message with a key that needs passphrase.\n```python3 \nenvelope(message=\"Hello world\", sign=True, passphrase=\"my-password\")\n```\n\nSign a message without signing by default turned previously on and having a default keyring path. Every `envelope` call will honour these defaults. \n```python3 \nenvelope.default.signature(True).gnupghome(\"/tmp/my-keyring\")\nenvelope(message=\"Hello world\")\n```\n\n## Sending\nSend an e-mail via module call.\n```python3\nenvelope(message=\"Hello world\", send=True)\n```\n\nSend an e-mail via CLI and default SMTP server localhost on port 25.\n```bash\nenvelope --to \"user@example.org\" --message \"Hello world\" --send\n```\n\nSend while having specified the SMTP server host, port, username, password.\n\n```bash\nenvelope --to \"user@example.org\" message \"Hello world\" --send --smtp localhost 123 username password \n```\n\nSend while having specified the SMTP server through a dictionary.\n```bash\nenvelope --to \"user@example.org\" --message \"Hello world\" --send --smtp '{\"host\": \"localhost\", \"port\": \"123\"}' \n```\n\nSend while having specified the SMTP server via module call.\n```python3\nenvelope(message=\"Hello world\", to=\"user@example.org\", send=True, smtp={\"host\":\"localhost\"}) \n```\n\n## Attachment\nYou can attach a file in many different ways. Pick the one that suits you the best.\n```python3\nenvelope(attachment=Path(\"/tmp/file.txt\"))  # filename will be 'file.txt'\n\nwith open(\"/tmp/file.txt\") as f:\n    envelope(attachment=f)  # filename will be 'file.txt'\n    \nwith open(\"/tmp/file.txt\") as f:\n    envelope(attachment=(f, \"filename.txt\"))\n    \nenvelope().attach(path=\"/tmp/file.txt\",filename=\"filename.txt\")\n```\n\n## Complex example\nSend an encrypted and signed message via the default SMTP server, via all three interfaces.\n```bash\n# CLI interface\nenvelope --message \"Hello world\" --to \"user@example.org\" --sender \"me@example.org\" --subject \"Test\" --sign --encrypt -a /tmp/file.txt -a /tmp/file2 application/gzip zipped-file.zip --send\n```\n```python3\n# one-liner interface\nfrom pathlib import Path\nenvelope().message(\"Hello world\").to(\"user@example.org\").sender(\"me@example.org\").subject(\"Test\").signature().encryption().attach(path=\"/tmp/file.txt\").attach(Path(\"/tmp/file2\"), \"application/gzip\", \"zipped-file.zip\").send()\n\n# fluent interface\nenvelope(message=\"Hello world\", to=\"user@example.org\", sender=\"me@example.org\", subject=\"Test\", sign=True, encrypt=True, attachments=[(Path(\"/tmp/file.txt\"), (Path(\"/tmp/file2\"), \"application/gzip\", \"zipped-file.zip\")], send=True)\n```\n\nIn the condition *me@example.com* private key for signing, *user@example.com* public key for encrypting and open SMTP server on *localhost:25* are available, change `--send` to `--send 0` (or `.send()` to `.send(False)` or `send=True` to `send=False`) to investigate the generated message that may be similar to the following output:\n```bash\n****************************************************************************************************\nHave not been sent from me@example.org to user@example.org\nEncrypted subject: Test\nEncrypted message: b'Hello world'\n\nSubject: Encrypted message\nMIME-Version: 1.0\nContent-Type: multipart/encrypted; protocol=\"application/pgp-encrypted\";\n boundary=\"===============8462917939563016793==\"\nFrom: me@example.org\nTo: user@example.org\nDate: Tue, 08 Oct 2019 16:16:18 +0200\nMessage-ID: <157054417817.4405.938581433237601455@promyka>\n\n--===============8462917939563016793==\nContent-Type: application/pgp-encrypted\n\nVersion: 1\n--===============8462917939563016793==\nContent-Type: application/octet-stream; name=\"encrypted.asc\"\nContent-Description: OpenPGP encrypted message\nContent-Disposition: inline; filename=\"encrypted.asc\"\n\n-----BEGIN PGP MESSAGE-----\n\nhQMOAyx1c9zl1h4wEAv+PmtwjQDt+4XCn8YQJ6d7kyrp2R7xzS3PQwOZ7e+HWJjY\n(...)\nRQ8QtLLEza+rs+1lgcPgdBZEHFpYpgDb0AUvYg9d\n=YuqI\n-----END PGP MESSAGE-----\n\n--===============8462917939563016793==--\n```\n\n# Related affairs\nSending an e-mail does not mean it will be received. Sending it successfully through your local domain does not mean a public mailbox will accept it as well. If you are not trustworthy enough, your e-mail may not even appear at the recipient's spam bin, it can just be discarded without notice. \n\n## Configure your SMTP\nIt is always easier if you have an account on an SMTP server the application is able to send e-mails with. If it is not the case, various SMTP server exist but as a quick and non-secure solution, I've tested [bytemark/smtp](https://hub.docker.com/r/bytemark/smtp/) docker image that allows you to start up a SMTP server by a single line.\n\n```bash\ndocker run --network=host --restart always -d bytemark/smtp   # starts open port 25 on localhost\nenvelope --message \"SMTP test\" --from [your e-mail] --to [your e-mail] --smtp localhost 25 --send\n```\n\n## Choose ciphering method\n\n### Configure your GPG\nIn order to sign messages, you need a private key. Let's pretend a usecase when your application will run under `www-data` user and GPG sign messages through the keys located at: `/var/www/.gnupg`. You have got a SMTP server with an e-mail account the application may use.\n```bash \nGNUPGHOME=/var/www/.gnupg sudo -H -u www-data gpg --full-generate-key  # put application e-mail your are able to send the e-mail from\n# if the generation fails now because you are on a remote terminal, you may want to change temporarily the ownership of the terminal by the following command: \n# sudo chown www-data $(tty)  # put it back afterwards\nGNUPGHOME=/var/www/.gnupg sudo -H -u www-data gpg --list-secret-keys  # get key ID\nGNUPGHOME=/var/www/.gnupg sudo -H -u www-data gpg --send-keys [key ID]  # now the world is able to pull the key from a global webserver when they receive an e-mail from you\nGNUPGHOME=/var/www/.gnupg sudo -H -u www-data envelope --message \"Hello world\" --subject \"GPG signing test\" --sign [key ID] --from [application e-mail] --to [your e-mail] --send  # you now receive e-mail and may import the key and set the trust to the key\n```\n\nIt takes few hours to a key to propagate. If the key cannot be imported in your e-mail client because not found on the servers, try in the morning again or check the online search form at http://hkps.pool.sks-keyservers.net.  \nPut your fingerprint on the web or on the business card then so that everybody can check your signature is valid.\n\n### Configure your S/MIME\nIf you are supposed to use S/MIME, you would probably be told where to take your key and certificate from. If planning to try it all by yourself, generate your `certificate.pem`.\n \n* Either: Do you have private key?\n```bash\nopenssl req -key YOUR-KEY.pem -nodes -x509 -days 365 -out certificate.pem  # will generate privkey.pem alongside\n```\n \n* Or: Do not you have private key? \n```bash\nopenssl req -newkey rsa:1024 -nodes -x509 -days 365 -out certificate.pem  # will generate privkey.pem alongside\n```\n\nNow, you may sign a message with your key and certificate. (However, the messages **will not be trustworthy** because no authority signed the certificate.) Give your friend the certificate so that they might verify the message comes from you. Receive a certificate from a friend to encrypt them a message with.\n```\nenvelope --message \"Hello world\" --subject \"S/MIME signing test\" --sign-path [key file] --cert-path [certificate file] --from [application e-mail] --to [your e-mail] --send # you now receive e-mail\n```\n\n## DNS validation tools\nThis is just a short explanation on these anti-spam mechanisms so that you can take basic notion what is going on.\n\nEvery time, the receiver should ask the sender's domain these questions over DNS.  \n\n### SPF\nThe receiver asks the sender's domain: Do you allow the senders IP/domain to send the e-mail on your behalf?\n\nCheck your domain on SPF:\n```bash\ndig -t TXT example.com\n``` \n\n### DKIM\nThe receiver asks the sender's domain: Give me the public key so that I may check the hash in the e-mail header that assert the message was composed by your private key. So that the e-mail comes trustworthy from you and nobody modified it on the way.\n\nCheck your domain on DKIM:\n```bash\ndig -t TXT [selector]._domainkey.example.com\n``` \nYou can obtain the `selector` from an e-mail message you received. Check the line `DKIM-Signature` and the value of the param `s`.\n```\nDKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=example.com; s=default;\n```\n\n## DMARC\nWhat is your policy concerning SPF and DKIM? What abuse address do you have?\n\nCheck your domain on DMARC:\n```bash\ndig -t TXT _dmarc.example.com\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/CZ-NIC/envelope", "keywords": "", "license": "GNU GPLv3", "maintainer": "", "maintainer_email": "", "name": "envelope", "package_url": "https://pypi.org/project/envelope/", "platform": "", "project_url": "https://pypi.org/project/envelope/", "project_urls": {"Homepage": "https://github.com/CZ-NIC/envelope"}, "release_url": "https://pypi.org/project/envelope/0.9.9/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Insert a message and attachments and send e-mail / sign / encrypt contents by a single line.", "version": "0.9.9"}, "last_serial": 6604395, "releases": {"0.9.1": [{"comment_text": "", "digests": {"md5": "64db16f61bad8312afc2b16dbce122e0", "sha256": "26f56de14602eb499274207a8452b197f16bcfeeefa937ee7200f964c68b6cd8"}, "downloads": -1, "filename": "envelope-0.9.1.tar.gz", "has_sig": false, "md5_digest": "64db16f61bad8312afc2b16dbce122e0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 21718, "upload_time": "2019-10-02T18:21:09", "upload_time_iso_8601": "2019-10-02T18:21:09.587075Z", "url": "https://files.pythonhosted.org/packages/91/64/73c64971a8634b581c201c131a96e5e2249ab4c5e5337aa1cd41b2d33aa3/envelope-0.9.1.tar.gz"}], "0.9.2": [{"comment_text": "", "digests": {"md5": "2ac3128124bb130d5a72c992c161c8bb", "sha256": "27e96b6eb748b5da2cfe30343f419a893a415933ae28df90339a03fcf3e708ac"}, "downloads": -1, "filename": "envelope-0.9.2.tar.gz", "has_sig": false, "md5_digest": "2ac3128124bb130d5a72c992c161c8bb", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 28611, "upload_time": "2019-10-07T14:22:13", "upload_time_iso_8601": "2019-10-07T14:22:13.984532Z", "url": "https://files.pythonhosted.org/packages/19/81/2acb5cd58ec9b818ec3d55d87a3ac5e62794555edf0b7cd940be88905186/envelope-0.9.2.tar.gz"}], "0.9.3": [{"comment_text": "", "digests": {"md5": "6a26cbf1b690be7ab1b26b79e9fa8a42", "sha256": "ded1881d0892c7fee80a6433a7194652e397bd0d296f4fe429886fca6e74843f"}, "downloads": -1, "filename": "envelope-0.9.3.tar.gz", "has_sig": false, "md5_digest": "6a26cbf1b690be7ab1b26b79e9fa8a42", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30046, "upload_time": "2019-11-29T23:11:07", "upload_time_iso_8601": "2019-11-29T23:11:07.704846Z", "url": "https://files.pythonhosted.org/packages/22/b3/873d30519b19d5df4a2e9224ce43b009344ec0d1d14c5faf677917168979/envelope-0.9.3.tar.gz"}], "0.9.4": [{"comment_text": "", "digests": {"md5": "2786902bf1e8a2c3a41e48e2472f6391", "sha256": "2918fc8294982cff7993d16c21a976e4fdd3e704a56221b5faccefb9cb5cdf4b"}, "downloads": -1, "filename": "envelope-0.9.4.tar.gz", "has_sig": false, "md5_digest": "2786902bf1e8a2c3a41e48e2472f6391", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30063, "upload_time": "2019-12-03T16:46:42", "upload_time_iso_8601": "2019-12-03T16:46:42.769521Z", "url": "https://files.pythonhosted.org/packages/20/59/1a47bc023888d7ae9234aeb36e732fb44ed75b5b8b45a797bcca37ddb4c8/envelope-0.9.4.tar.gz"}], "0.9.5": [{"comment_text": "", "digests": {"md5": "59705c6c6ec5dac2a4f431587878174e", "sha256": "6fae8b9f166877a9fb9213efb901d820e2e9c69622b44a68cdda5ecab7115f04"}, "downloads": -1, "filename": "envelope-0.9.5.tar.gz", "has_sig": false, "md5_digest": "59705c6c6ec5dac2a4f431587878174e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 34645, "upload_time": "2019-12-12T18:32:21", "upload_time_iso_8601": "2019-12-12T18:32:21.677469Z", "url": "https://files.pythonhosted.org/packages/1e/97/811aa8164d43d597cb7bde258d6e1ee70895d5f350487b3ac3d1cac53613/envelope-0.9.5.tar.gz"}], "0.9.6": [{"comment_text": "", "digests": {"md5": "2ca76c997e7bfd6b947a9003d54d97a5", "sha256": "5eedf251150e57c912f17473a47780ce75eaecea84fd5d5d5d84678e919daa25"}, "downloads": -1, "filename": "envelope-0.9.6.tar.gz", "has_sig": false, "md5_digest": "2ca76c997e7bfd6b947a9003d54d97a5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 34771, "upload_time": "2020-01-14T20:47:41", "upload_time_iso_8601": "2020-01-14T20:47:41.568518Z", "url": "https://files.pythonhosted.org/packages/34/b0/de451416c42e73fc7f739e03d0e1d637737f1abdcf392ce8a354a1217582/envelope-0.9.6.tar.gz"}], "0.9.7": [{"comment_text": "", "digests": {"md5": "0e0dcae1de79f18b22356d743920b353", "sha256": "bca5f4a450277ff6cb6dbbf456f9f8a55ad7e444da279016946bd159023b142f"}, "downloads": -1, "filename": "envelope-0.9.7.tar.gz", "has_sig": false, "md5_digest": "0e0dcae1de79f18b22356d743920b353", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 37642, "upload_time": "2020-01-17T00:53:40", "upload_time_iso_8601": "2020-01-17T00:53:40.338858Z", "url": "https://files.pythonhosted.org/packages/9c/a9/67c005f1d23d4689259d6cb083f51b58225df5ee4783f2407017273c0174/envelope-0.9.7.tar.gz"}], "0.9.8": [{"comment_text": "", "digests": {"md5": "4ee81e7ebb3cbf620e88dfc45db73eed", "sha256": "0af93adf30fb7c57ae85f7b99d301a3e7febef2244eb63204f03927e6c846c90"}, "downloads": -1, "filename": "envelope-0.9.8.tar.gz", "has_sig": false, "md5_digest": "4ee81e7ebb3cbf620e88dfc45db73eed", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40615, "upload_time": "2020-01-27T22:23:27", "upload_time_iso_8601": "2020-01-27T22:23:27.120722Z", "url": "https://files.pythonhosted.org/packages/04/f1/f950cbce0fc6d703bd9b9f4b0688d509c52fcf034f73cbe16a53be66b8fc/envelope-0.9.8.tar.gz"}], "0.9.9": [{"comment_text": "", "digests": {"md5": "ff1453a200697c8d7b4d2bab1bf6f906", "sha256": "a3db86660fa121ab2f31b443aaa7d753f7b4ee34a12c420c122f86f73aa87ff5"}, "downloads": -1, "filename": "envelope-0.9.9.tar.gz", "has_sig": false, "md5_digest": "ff1453a200697c8d7b4d2bab1bf6f906", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40606, "upload_time": "2020-02-10T18:58:48", "upload_time_iso_8601": "2020-02-10T18:58:48.670690Z", "url": "https://files.pythonhosted.org/packages/8f/cb/405a99221f6df352e2b50cdfa8a7f2659519e6d6ab6d4dbcfef82e73856d/envelope-0.9.9.tar.gz"}], "0.9.9rc1": [{"comment_text": "", "digests": {"md5": "48b8b1ac44546d04c9e9dbe10590ab01", "sha256": "154aaee4fc4bb36584634e95947f33d2c6b1f4b95b092eb35dfa2f97b587a34d"}, "downloads": -1, "filename": "envelope-0.9.9rc1.tar.gz", "has_sig": false, "md5_digest": "48b8b1ac44546d04c9e9dbe10590ab01", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40525, "upload_time": "2020-02-10T17:16:16", "upload_time_iso_8601": "2020-02-10T17:16:16.579234Z", "url": "https://files.pythonhosted.org/packages/24/b7/2f6ff99849ae201f00f6730d9792e8d30502f986eb483797780ba65142ab/envelope-0.9.9rc1.tar.gz"}], "0.9.9rc2": [{"comment_text": "", "digests": {"md5": "75f0e1bbd616e32d047b7e9b7106329f", "sha256": "73f159e83840e8e33f7a8f7d789081ddf0d8f0af7a10fa3a3b04961be94cc040"}, "downloads": -1, "filename": "envelope-0.9.9rc2.tar.gz", "has_sig": false, "md5_digest": "75f0e1bbd616e32d047b7e9b7106329f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40654, "upload_time": "2020-02-10T18:41:55", "upload_time_iso_8601": "2020-02-10T18:41:55.769498Z", "url": "https://files.pythonhosted.org/packages/9b/44/49586327e90b0363537bac7e4e93af671a714ec718b465242afd5dd9e4c3/envelope-0.9.9rc2.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "ff1453a200697c8d7b4d2bab1bf6f906", "sha256": "a3db86660fa121ab2f31b443aaa7d753f7b4ee34a12c420c122f86f73aa87ff5"}, "downloads": -1, "filename": "envelope-0.9.9.tar.gz", "has_sig": false, "md5_digest": "ff1453a200697c8d7b4d2bab1bf6f906", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40606, "upload_time": "2020-02-10T18:58:48", "upload_time_iso_8601": "2020-02-10T18:58:48.670690Z", "url": "https://files.pythonhosted.org/packages/8f/cb/405a99221f6df352e2b50cdfa8a7f2659519e6d6ab6d4dbcfef82e73856d/envelope-0.9.9.tar.gz"}]}
{"info": {"author": "Leo Simpson", "author_email": "leo.bill.simpson@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "Constrained sparse regression functions in Python\n\nTo install the package : \n    pip install c_lasso\n\nTo import the package :\n    import classo\n\n\n1) Different type of problem : \n\t- Least square :             min || Ax-y ||^2 + lambda * ||x||_1\t\t\t\n\t- Huber  :                   min  h_rho(Ax-y) + lambda * ||x||_1\t\n\t- Concomitant Least square : min || Ax-y ||^2/sigma + n*sigma + lambda * ||x||_1\n\t- Concomitant Huber :        min h_rho( (Ax-y)/sigma ) + n)*sigma + lambda * ||x||_1\n\n\n\n2) Different methods for solving the problems : \n\n    Four main methods have been implemented for those.\n\n\n        Forward Backward splitting method:\n            Standard way to solve a convex minimisation problem with an addition of\n            smooth and non-smooth function : Projected Proximal Gradient Descent. This\n            method only works with the two non concomitants problems. For the huber\n            problem, we use the second formulation.\n\n        No-proj method\n            Similar to the Projected Proximal Gradient Descent, but which does not involve\n            a projection, which can be difficult to compute for some matrix C. Only for\n            non concomitant problems.\n\n        Double prox method\n            Use of Doulgas Rachford splitting algorithm which use the proximal operator of\n            both functions. It also solves concomitant problems, but it is usefull even in the\n            non concomitant case because it is usually more efficient than forward backward\n            splitting method. For the huber problem, we use the second formulation, then\n            we change it into a Least square problem of dimension m (m + d) instead of m d.\n\n        ODE method  \n            From the KKT conditions, we can derive an simple ODE for the solution of\n            the non concomitants problems, which shows that the solution is piecewise-\n            affine. For the least square, as the problem can always be reported to a a non\n            concomitant problem for another lambda, one can use the whole non-concomitant-\n            path computed with the ODE method to then solve the concomitant-path.\n\n\n\n3) Two main functions \n\n    For solving the problem for a fix \\lambda : \n\n    fixlasso (matrix, lam, typ ='LS ', meth ='choose ', plot_time =True, plot_sol =True, plot_sigm =True, rho = 1.345)\n\n         -matrix\n            Matrices (A;C; y) of the problem.\n\n         -lam\n            Lambda/lambdamax in [0; 1] where lambdamax is a majoration of the lambda when the solution is null \n            (depends on the type of problem).\n\n         -typ\n            Type of problem : 'Huber', 'Concomitant' , 'Concomitant Huber' or 'LS'. \n            Any other string will set the type of problem to Least Square.\n\n         -meth\n            Method to solve the problem. If wrong input, the algorithm choose the method according to lambda\n                - Possibilities for types 'LS' and 'Huber' : 'FB', 'Noproj', '2prox', 'ODE'.\n                - Possibilities for type 'Concomitant' : '2prox', 'ODE'.\n                - Possibilities for type 'Concomitant Huber' : '2prox'.\n\n         -plot_time\n            If set to True : prints the running time.\n\n         -plot_sol\n            If set to True : plots the solution in a bars diagram.\n\n         -plot_sigm\n            If set to True and the type we solve a concomitant problem : prints sigma/sigmamax.\n\n         -rho\n            Normalized rho for non-concomitant Huber problem : rho * sqrt(m) / norm_inf(y)\n            Unormalized sigma for concomitant Huber problem.\n\n\n         -returns\n            The function returns : \n                An 'numpy.ndarray' type vector representing the solution betafor non concomitant problems, \n                A tuple containing beta and sigma for the concomitant problems.\n\n\n\n\n\n\n    For solving the problem for the whole path :\n\n    pathlasso (matrix, lambdas ='choose ', lamin =1e -2, typ='LS ', meth ='ODE ', plot_time =True, plot_sol =True, plot_sigm =True, rho = 1.345, compare = False )\n\n\n\n        -matrix\n            Matrices (A;C; y) of the problem.\n\n        -lambdas\n            Gives the list of lambda/lambdamax in [0; 1] where we need the problem to be solved. \n            If a boolean is given, it is the next parameter that will give the path.\n\n        -lamin\n            If lambdas is a boolean, it gives the lambda/lambdamax minimum : \n            the algorithm will solve the problem for all lambda in [lamin * lambdamax; lambdamax] \n            (with 100 points).\t\n\n        -typ\n            Type of problem : 'Huber', 'Concomitant' , 'Concomitant Huber' or 'LS'. \n            Any other string will set the type of problem to Least Square.\n\n        -meth\n            Method to solve the problem. If wrong input, the algorithm choose the method according to lambda.\n                - Possibilities for types 'LS' and 'Huber' : 'FB', 'Noproj', '2prox', 'ODE'.\n                - Possibilities for type 'Concomitant' : '2prox', 'ODE'.\n                - Possibilities for type 'Concomitant Huber' : '2prox'.\n\n            For each case except 'ODE', the algorithm solves the problem for each lambda of the path using warm starts.\n\n\n        -plot_time\n            If set to True : prints the running time.\n\n        -plot_sol\n            If set to True : plots the solution in a bars diagram.\n\n        -plot_sigm\n            If set to True and the type we solve a concomitant problem : prints sigma/sigmamax.\n\n        -rho\n            Normalized rho for non-concomitant Huber problem : rho * sqrt(m) / norm_inf(y)\n            Unormalized sigma for concomitant Huber problem.\n\n\n        -returns\n            The function returns :  \n                a list 'numpy.ndarray' type vector representing the solution beta for each lambda ;\n                the list of lambda corresponding (unormalized), \n                also the list of sigmas for the concomitant problems.\n\n\n\n\n\n4) Little functions :\n\n    For computing the theoretical lambda/lambdamax in the case of concomitant problems :  \n\n        model_selection(m,d)\n\n            Where m is the number of sample and d the number of parameter, it returns : lam0 = sqrt(2/m) invPhi(1-t), with invPhi the quantile function for the standard normal distribution, and t is the solution to the equation t*p = invPhi(1-t)**4 + 2*invPhi(1-t)**2\n\n\n\n    For computing the solution using cross-validation and the previous main functions : \n\n        CV(matrices,k=5,typ='LS',test=0.4,lamin=1e-2, print_lam= True)\n\n            Where k is the number of 'cluster' used, test is the proportion of sample kept for testing, and print lam tells us if the function also print the lambda/lambdamax used. The function returns the solution Beta as a 'numpy.ndarray'.\n\n\n\n\n\n\n\n\n\n\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Leo-Simpson/CLasso", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "c-lasso", "package_url": "https://pypi.org/project/c-lasso/", "platform": "", "project_url": "https://pypi.org/project/c-lasso/", "project_urls": {"Homepage": "https://github.com/Leo-Simpson/CLasso"}, "release_url": "https://pypi.org/project/c-lasso/0.1/", "requires_dist": null, "requires_python": "", "summary": "Algorithms for constrained Lasso problems", "version": "0.1"}, "last_serial": 5579024, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "f1f0b15bd80101b60b106bddc767d2e9", "sha256": "f52e4e3a3a29bb7c5198464248a4b650be49d7ac876e997ba568dafab3694e47"}, "downloads": -1, "filename": "c_lasso-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f1f0b15bd80101b60b106bddc767d2e9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 29180, "upload_time": "2019-07-19T00:09:41", "upload_time_iso_8601": "2019-07-19T00:09:41.281372Z", "url": "https://files.pythonhosted.org/packages/3f/82/539ad5c753b456fb0e54b42bf03816edf2f6b11cb994be3ed9f1900847a7/c_lasso-0.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "08d4d050eaac3a0c36398e6a37544567", "sha256": "4c033448dc3a83b813a7f4c3dc458cdb021dce303993ecb4890c1a276a80b2f8"}, "downloads": -1, "filename": "c_lasso-0.1.tar.gz", "has_sig": false, "md5_digest": "08d4d050eaac3a0c36398e6a37544567", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17710, "upload_time": "2019-07-19T00:09:44", "upload_time_iso_8601": "2019-07-19T00:09:44.438214Z", "url": "https://files.pythonhosted.org/packages/57/13/6d90e37a5afce90d7b55ddf22ae733c18e6bd259a29e165b8da797cc6a27/c_lasso-0.1.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "f1f0b15bd80101b60b106bddc767d2e9", "sha256": "f52e4e3a3a29bb7c5198464248a4b650be49d7ac876e997ba568dafab3694e47"}, "downloads": -1, "filename": "c_lasso-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f1f0b15bd80101b60b106bddc767d2e9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 29180, "upload_time": "2019-07-19T00:09:41", "upload_time_iso_8601": "2019-07-19T00:09:41.281372Z", "url": "https://files.pythonhosted.org/packages/3f/82/539ad5c753b456fb0e54b42bf03816edf2f6b11cb994be3ed9f1900847a7/c_lasso-0.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "08d4d050eaac3a0c36398e6a37544567", "sha256": "4c033448dc3a83b813a7f4c3dc458cdb021dce303993ecb4890c1a276a80b2f8"}, "downloads": -1, "filename": "c_lasso-0.1.tar.gz", "has_sig": false, "md5_digest": "08d4d050eaac3a0c36398e6a37544567", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17710, "upload_time": "2019-07-19T00:09:44", "upload_time_iso_8601": "2019-07-19T00:09:44.438214Z", "url": "https://files.pythonhosted.org/packages/57/13/6d90e37a5afce90d7b55ddf22ae733c18e6bd259a29e165b8da797cc6a27/c_lasso-0.1.tar.gz"}]}
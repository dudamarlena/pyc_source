{"info": {"author": "ABHIJITH BOPPE", "author_email": "abhijithas.eh@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: Unix", "Programming Language :: Python", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# Secured IOT Socket Server \n\n - Time based verification\n - TLS/SSL \n - Device Validation\n\n\n## ABOUT\n\nIOT Socket Server handle multiple clients (with unique deviceID and its key) simultaneously for bidirectional communication.\n\nIt is similar to websocket. Here we can handle each client individually from there device id.\n\nIOT devices like Raspberry can also use this module as client with IOTSocketClient module.\n\n\n**How is it secured ?**\n\nTo prevent Replay attacks and device cloning attacks.\n\nFor every data transmission from client to server or vice versa there is a time stamp which is compared with server/client present time. If the time doesn't match (tolerance of -2 sec) or if there is any reused time then socket is closed.\n\nBy using these headers for every transmission, IOT devices over WiFi can also be secured.\n\n*NOTE:*\n\n- Make sure the device time is in sync with server time (use RTC)\n- Re-establish client socket connection every 24 hours\n- SSL key pinning on client side.\n- Verify device id and key from database\n- Client socket will be closed if there is no data for 90 sec\n\n### Example Server \n\n```python\n\n'''\nDeveloped by Abhijith Boppe - linkedin.com/in/abhijith-boppe/\n'''\nfrom IOTSocket import IOTSocketServer, IOTSocketServerSSL, IOTSocket\nimport time\n\nhost = \"127.0.0.1\"\nport = 9000\n\n# give certificate path and key path\ncertfile_path = \"/user/cert.pem\"\nkeyfile_path = \"/user/cert.key\"\ndelimiter = '\\r\\n#*\\r\\n'\n\n# give some insecure data te be filtered and sanitized to ''\nlst_of_data_to_remove = [delimiter]\nprev_call = 0\n\n# this function will be called recursively to check if server want to push any data\ndef from_server_to_client():\n    '''\n    create a FIFO named pipe, make your backend application like PHP\n    to write into it and you return a list. Like: ['id1 data1', 'id2 data2', 'id3 data3', .....]\n\n    Ex: ['23234 ON SWITCH 1','23235 OFF LIGHT','232365 GET ALL SENSOR VALUES']\n    (id must be numaric values only)\n\n    '''\n    return []\n\nclass handleEachClientHere(IOTSocket):\n    def DeviceVerify(self, id_, key):          # 'id_' - int , 'key' - string\n        '''\n        This method is called when a new client is connected.\n        Verify whether device id and key matches in database records\n        and check if it is activated.\n        (Check from DB)\n        '''\n\n        return 1    #return True if verified successfully else false\n\n    def handleMessage(self, id_, data):\n        '''\n        handle client id and data for further processing.\n        create a fifo named pipe and pass the data to your\n        backed application\n\n        (make sure u remove delimeters and other vulnerable strings which effect the backend application)\n        '''\n\n        for i in lst_of_data_to_remove:         # remove delimiters/data, if any are present in client data to prevent clashes\n            data.replace(i, '')\n        print(id_, data)\n\n    def handleClose(self, error_repo=''):\n        '''\n        handle error if any during socket handling\n        error start with \"ERROR: \"\n        and normal socket close will end with normal message\n        '''\n\n        if \"ERROR:\" in str(error_repo):\n            print(error_repo)\n        else:\n            pass\n            #print(error_repo)\n\n\nserver = IOTSocketServer(host, port, from_server_to_client,handleEachClientHere)        # without ssl\n# server = IOTSocketServerSSL(host, port, from_server_to_client, handleEachClientHere, certfile = certfile_path, keyfile = keyfile_path)\nserver.serveforever()\n```\n\n### Example client\n```python\n\n'''\nDeveloped by Abhijith Boppe - linkedin.com/in/abhijith-boppe/\n\nclient for raspberry \n'''\n\nfrom IOTSocket import IOTSocketClient as sock\nimport time\n\nhost = '127.0.0.1'\nport = 9000\ndevice_id = '1234567890'\ndevice_key ='1432qrzd23'\ncertfile_path = \"/user/cert.pem\"      # for key pinning (certificate pinning)\nprev_call = 0\n\ndef someThingtoSend():\n    '''\n    this function is called recursively.\n    read data from sensor and return data\n    '''\n    global prev_call\n    now = time.time()\n    if ((now - prev_call) > 10) or prev_call == 0:\n        example = 'temp=33.5&humid=40%'\n        prev_call = now\n        return example\n    else:\n        return ''\n\ndef handleCmdsFromServer(data):\n    '''\n    This function is called when ever there is \n    data/command from the server.\n    '''\n    print(data)\n\nwhile 1: # reconnect if socket is closed\n    try:\n        sock.connectionSet(host,port,device_id,device_key,Encrypt=False, cert_path= certfile_path)  # set IOT Socket connection with valid Device ID and Key.\n        # Continiously check for receiving / tansmiting of data\n        while 1:\n            data = someThingtoSend()\n            if data != '':\n                sock.sendData(data)     # send data to server if data is available to send\n            rcv_data = sock.recvData()  # receive data from server if available\n            if len(rcv_data) > 5:\n                handleCmdsFromServer(rcv_data)   # handle your data here\n\n    except Exception as n:\n        print(n)\n\n\n\n```\n\n### Additional Information\n\nThere is no hand shake. Connection is established directly on 1st request from client. Make sure the client and server time are in sync.\n\nRead/Write to your application from using fifo named pipe recursively without closing. \n\nPlease go through the code for better understanding of the protocol.\n\n\n## License & copyright\n\n\u00a9 Abhijith Boppe, Security analyst\n\nlinkedin.com/in/abhijith-boppe\n\nLicensed under the [MIT License](LICENSE)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/AbhijithAJ/IOTSocket", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "IOTSocket", "package_url": "https://pypi.org/project/IOTSocket/", "platform": "", "project_url": "https://pypi.org/project/IOTSocket/", "project_urls": {"Homepage": "https://github.com/AbhijithAJ/IOTSocket"}, "release_url": "https://pypi.org/project/IOTSocket/0.3.3/", "requires_dist": null, "requires_python": ">=3.2", "summary": "to make bidirectional full-duplex comunications securely for iot devices", "version": "0.3.3"}, "last_serial": 6628256, "releases": {"0.3.3": [{"comment_text": "", "digests": {"md5": "4c97cad648275eff461843a23dba94d2", "sha256": "a3ddcdf5091da756219286a6ca5846741002f66ca809a8082df628ce21409511"}, "downloads": -1, "filename": "IOTSocket-0.3.3-py2-none-any.whl", "has_sig": false, "md5_digest": "4c97cad648275eff461843a23dba94d2", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=3.2", "size": 10201, "upload_time": "2020-02-14T05:18:16", "upload_time_iso_8601": "2020-02-14T05:18:16.803559Z", "url": "https://files.pythonhosted.org/packages/e4/8f/5c7b7e3a0c84b9893dc1f2bc1d2473f46d988f2cfd3184dde0e4642eee38/IOTSocket-0.3.3-py2-none-any.whl"}, {"comment_text": "", "digests": {"md5": "aaacbd06985dadae4eb9bb41846dd2e1", "sha256": "b68cb8796772cfda7dd503f87ada635bb3818548cfb836e5af740f5508e5388f"}, "downloads": -1, "filename": "IOTSocket-0.3.3.tar.gz", "has_sig": false, "md5_digest": "aaacbd06985dadae4eb9bb41846dd2e1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.2", "size": 8322, "upload_time": "2020-02-14T05:18:22", "upload_time_iso_8601": "2020-02-14T05:18:22.109106Z", "url": "https://files.pythonhosted.org/packages/8b/8d/149ba1872a0f214c4c8a747dbaec3d86e78c36d969f7ee957d3ac4378503/IOTSocket-0.3.3.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "4c97cad648275eff461843a23dba94d2", "sha256": "a3ddcdf5091da756219286a6ca5846741002f66ca809a8082df628ce21409511"}, "downloads": -1, "filename": "IOTSocket-0.3.3-py2-none-any.whl", "has_sig": false, "md5_digest": "4c97cad648275eff461843a23dba94d2", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=3.2", "size": 10201, "upload_time": "2020-02-14T05:18:16", "upload_time_iso_8601": "2020-02-14T05:18:16.803559Z", "url": "https://files.pythonhosted.org/packages/e4/8f/5c7b7e3a0c84b9893dc1f2bc1d2473f46d988f2cfd3184dde0e4642eee38/IOTSocket-0.3.3-py2-none-any.whl"}, {"comment_text": "", "digests": {"md5": "aaacbd06985dadae4eb9bb41846dd2e1", "sha256": "b68cb8796772cfda7dd503f87ada635bb3818548cfb836e5af740f5508e5388f"}, "downloads": -1, "filename": "IOTSocket-0.3.3.tar.gz", "has_sig": false, "md5_digest": "aaacbd06985dadae4eb9bb41846dd2e1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.2", "size": 8322, "upload_time": "2020-02-14T05:18:22", "upload_time_iso_8601": "2020-02-14T05:18:22.109106Z", "url": "https://files.pythonhosted.org/packages/8b/8d/149ba1872a0f214c4c8a747dbaec3d86e78c36d969f7ee957d3ac4378503/IOTSocket-0.3.3.tar.gz"}]}
{"info": {"author": "Caleb Mackey", "author_email": "calebma@bolton-menk.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v2 (GPLv2)", "Natural Language :: English", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: GIS"], "description": "# restapi\nThis is a Python API for working with ArcGIS REST API, ArcGIS Online, and Portal/ArcGIS Enterprise.  This package has been designed to work with [arcpy](https://pro.arcgis.com/en/pro-app/arcpy/get-started/what-is-arcpy-.htm) when available, or the included open source module [pyshp](https://pypi.org/project/pyshp/).  It will try to use arcpy if available for some data conversions, otherwise will use open source options. Also included is a subpackage for administering ArcGIS Server Sites.  This is updated often, so continue checking here for new functionality!\n\n### Why would you use this package?\nEsri currently provides the [ArcGIS API for Python](https://developers.arcgis.com/python/) which provides complete bindings to the ArcGIS REST API.  This package has less coverage of the REST API, but has many convience functions not available in the ArcGIS API for Python.  This package will also support older versions of Python (i.e. 2.7.x) whereas Esri's package only supports 3.x.\n\n\n## Installation\n`restapi` is supported on Python 2.7 and 3.x. It can be found on [Github](https://github.com/Bolton-and-Menk-GIS/restapi) and [PyPi](https://pypi.org/project/bmi-arcgis-restapi/). To install using pip:  \n````py\npip install bmi-arcgis-restapi\n````\n\nAfter installation, it should be available to use in Python:  \n````py\nimport restapi\n````\n\n## A note about `arcpy`\nBy default, `restapi` will import Esri's `arcpy` module if available. However, this module is not required to use this package.  `arcpy` is only used when available to write data to disk in esri specific formats (file geodatabase, etc) and working with `arcpy` Geometries.  When `arcpy` is not availalbe, the  [pyshp](https://pypi.org/project/pyshp/) module is used to write data (shapefile format only) and work with `shapefile.Shape` objects (geometry).  Also worth noting is that open source version is much faster than using `arcpy`.\n\nThat being said, there may be times when you want to force `restapi` to use the open source version, even when you have access to `arcpy`.  Some example scenarios being when you don't need to write any data in an Esri specific format, you want the script to execute very fast, or you are working in an environment where `arcpy` may not play very nicely ([Flask](https://palletsprojects.com/p/flask/), [Django](https://www.djangoproject.com/), etc.).  To force `restapi` to use the open source version, you can simply create an environment variable called `RESTAPI_USE_ARCPY` and set it to `FALSE` or `0`.  This variable will be checked before attempting to import `arcpy`.\n\nHere is an example on how to force open source at runtime:\n\n```py\nimport os\nos.environ['RESTAPI_USE_ARCPY'] = 'FALSE'\n\n# now import restapi\nimport restapi\n```\n\n\n\n\n## Connecting to an ArcGIS Server\nOne of the first things you might do is to connect to a services directory (or catalog):\n\n\nConnect to external services\n\n````py\n# connect NOAA ArcGIS Server Instance\nrest_url = 'https://gis.ngdc.noaa.gov/arcgis/rest/services'\n\n# no authentication is required, so no username and password are supplied\nags = restapi.ArcServer(rest_url)\n\n# get folder and service properties\nprint('Number of folders: {}'.format(len(ags.folders)))\nprint('Number of services: {}'.format(len(ags.services)))\n\n# walk thru directories\nfor root, folders, services in ags.walk():\n    print(root)\n    print(folders)\n    print(services)\n    print('\\n')\n````\n\nConnecting to a map service from within the ArcServer object\n````py\n# access \"ahps_gauges\" service (stream gauges)\ngauges = ags.getService('ahps_gauges')\nprint(gauges.url) #print(MapService url\n\n# print(layer names\nprint(gauges.list_layers())\n\n# access \"observed river stages\" layer\nlyr = gauges.layer('observed_river_stages') #not case sensitive, also supports wildcard search (*)\n\n# list fields from col layer\nprint(lyr.list_fields())\n````\n\nYou can also query the layer and get back arcpy.da Cursor like access\n\n````py\n# run search cursor for gauges in California\n# (maximimum limit may be 1000 records, can use get_all=True to exceed transfer limit)\n# can filter fields by putting a field list, can use actual shape field name to get\n#  geometry or use the ArcGIS-like token \"SHAPE@\"\n# all fields are gathered by the default (\"*\") and fields can be filtered by providing a list\nquery = \"state = 'CA'\"\nfor row in lyr.cursor(where=query, fields=['SHAPE@', u'gaugelid', u'status', u'location']):\n    print(row)\n\n# Note: can also do this from the MapService level like this:\n# cursor = gauges.cursor('observed_river_stages', where=query)\n````\n\nThe layer can also be exported to a shapefile or KMZ\n\n````py\n# export Nebraska \"College/University\" layer to feature class\n# make scratch folder first\nfolder = os.path.join(os.environ['USERPROFILE'], r'Desktop\\restapi_test_data')\nif not os.path.exists(folder):\n    os.makedirs(folder)\n\n# export layer to shapefile (can also call from Map Service)\noutput = os.path.join(folder, 'California_Stream_Gauges.shp')\nlyr.layer_to_fc(output, where=query, sr=102100) #override spatial reference with web mercator\n\n# export to KMZ\nkmz = output.replace('.shp', '.kmz')\nlyr.layer_to_kmz(kmz, where=query)\n````\n\nClipping a layer is also easy\n\n````py\n# clip lyr by polygon (Sacramento area)\nesri_json = {\"rings\":[[[-121.5,38.6],[-121.4,38.6],\n                      [-121.3,38.6],[-121.2,38.6],\n                      [-121.2,38.3],[-121.5,38.3],\n                      [-121.5,38.6]]],\n            \"spatialReference\":\n                {\"wkid\":4326,\"latestWkid\":4326}}\n\n# clip by polygon and filter fields (can use polygon shapefile or feature class as well)\nsac = os.path.join(folder, 'Sacramento_gauges.shp')\nlyr.clip(esri_json, sac, fields=['gaugelid', 'location'])\n````\n\nYou can also connect to a MapService directly\n\n```py\nurl = 'http://gis.srh.noaa.gov/arcgis/rest/services/ahps_gauges/MapServer'\ngauges = restapi.MapService(url)\n```\n\nWorking with Feature Layers\n---------------\n\n### query examples\n```py\n\n# create FeatureLayer\nurl = 'https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/Hazards_Uptown_Charlotte/FeatureServer/0'\nhazards = restapi.FeatureLayer(url)\n\n# QUERY EXAMPLES\n\n# query all features, to fetch all regardless of `maxRecordCount` \n# use `exceed_limit=true` keyword arg\nfs = hazards.query()\nprint('All Hazards Count: {}'.format(fs.count))\n\n# query features that are \"High\" Priority\nhigh_priority = hazards.query(where=\"Priority = 'High'\")\nprint('High Priority Hazards count: {}'.format(high_priority.count))\n```\n\n### download features\n```py\n# download features - choosing a geodatbase output will bring over domain \n# info (when you have access to arcpy), whereas a shapefile output will \n# just bring over the domain values\nshp = os.path.join(test_data_folder, 'hazards.shp')\n    \n# export layer to shapefile in WGS 1984 projection\nhazards.export_layer(shp, outSR=4326)\n```\n\n## feature editing\n\n### add features using `FeatureLayer.addFeatures()`\n```py\n# add new records via FeatureLayer.addFeatures()\ndesc = \"restapi edit test\"\nnew_ft = {\n    \"attributes\": {\n        \"HazardType\": \"Flooding\",\n        \"Description\": desc,\n        \"SpecialInstructions\": None,\n        \"Status\": \"Active\",\n        \"GlobalID\": \"416f04e5-0ae9-4444-8d0c-d4e9b44e7f87\",\n        \"Priority\": \"Moderate\"\n    },\n    \"geometry\": create_random_coordinates()\n}\n\n# add new feature\nresults = hazards.addFeatures([new_ft])\nprint(results)\n```\n### using `restapi` cursors\n\n`restapi` also supports cursors similar to what you get when using `arcpy`.  However, these work directly with the REST API and JSON features while also supporting `arcpy` and `shapefile` geometry types.  See the below example on how to use an `insertCursor` to add new records:\n\n```py\n# add 3 new features using an insert cursor \n# using this in a \"with\" statement will call applyEdits on __exit__\nfields = [\"SHAPE@\", 'HazardType', \"Description\", \"Priority\"]\nwith hazards.insertCursor(fields) as irows:\n    for i in range(3):\n        irows.insertRow([create_random_coordinates(), \"Wire Down\", desc, \"High\"])\n```\n\nrecords can be updated with an `updateCursor` and a where clause.  Note that the `OBJECTID` field must be included in the query to indicate which records will be updated.  The `OID@` field token can be used to retreive the `objectIdFieldName`:\n\n```py\n# now update records with updateCursor\nwhereClause = \"Description = '{}'\".format(desc)\n\nwith hazards.updateCursor([\"Priority\", \"OID@\"], where=whereClause) as rows:\n    for row in rows:\n        row[0] = \"Low\"\n        rows.updateRow(row)\n```\n\nDeleting features can be done with a simple `where` clause:\n\n```py\n# now delete the records we added\nhazards.deleteFeatures(where=whereClause)\n```\n\nWe can also add attachments\n````py\n# add attachment, get new OID from add results\noid = result.addResults[0]  # must get an OID to add attachment to\n\n# download python image online and add it to the featuer we just added above\nurl = 'http://www.cis.upenn.edu/~lhuang3/cse399-python/images/pslytherin.png'\nim = urllib.urlopen(url).read()\ntmp = os.path.join(os.path.dirname(sys.argv[0]), 'python.png')\nwith open(tmp, 'wb') as f:\n    f.write(im)\n\n# add attachment\nincidents.addAttachment(oid, tmp)\nos.remove(tmp)\n\n# get attachment info from service and download it\nattachments = incidents.attachments(oid)\n\nfor attachment in attachments:\n    print(attachment)\n    print attachment.contentType, attachment.size)\n    attachment.download(folder) # folder is a user specified output directory\n````\nUpdate feature and delete features\n\n````py\n# update the feature we just added\nadds[0]['attributes']['address'] = 'Address Not Available'\nadds[0]['attributes']['objectid'] = oid\nincidents.updateFeatures(adds)\n\n# now delete feature\nincidents.deleteFeatures(oid)\n````\n\nOffline capabilities (Sync)\n\n````py\n# if sync were enabled, we could create a replica like this:\n# can pass in layer ID (0) or name ('incidents', not case sensative)\nreplica = fs.createReplica(0, 'test_replica', geometry=adds[0]['geometry'], geometryType='esriGeometryPoint', inSR=4326)\n\n# now export the replica object to file geodatabase (if arcpy access) or shapefile with hyperlinks (if open source)\nrestapi.exportReplica(replica, folder)\n````\n\nWorking with Image Services\n---------------------------\n\n````py\nurl = 'http://pca-gis02.pca.state.mn.us/arcgis/rest/services/Elevation/DEM_1m/ImageServer'\nim = restapi.ImageService(url)\n\n# clip DEM\ngeometry = {\"rings\":[[\n                [240006.00808044084, 4954874.19629429],\n                [240157.31010183255, 4954868.8053006204],\n                [240154.85966611796, 4954800.0316874133],\n                [240003.55764305394, 4954805.4226145679],\n                [240006.00808044084, 4954874.19629429]]],\n            \"spatialReference\":{\"wkid\":26915,\"latestWkid\":26915}}\n\ntif = os.path.join(folder, 'dem.tif')\nim.clip(geometry, tif)\n\n# test point identify\nx, y = 400994.780878, 157878.398217\nelevation = im.pointIdentify(x=x, y=y, sr=103793)\nprint(elevation)\n````\n\nGeocoding\n---------\n\n````py\n# hennepin county, MN geocoder\nhenn = 'http://gis.hennepin.us/arcgis/rest/services/Locators/HC_COMPOSITE/GeocodeServer'\ngeocoder = restapi.Geocoder(henn)\n# find target field, use the SingleLine address field by default\ngeoResult = geocoder.findAddressCandidates('353 N 5th St, Minneapolis, MN 55403')\n\n# export results to shapefile\nprint('found {} candidates'.format(len(geoResult))\ngeocoder.exportResults(geoResult, os.path.join(folder, 'target_field.shp'))\n\n# Esri geocoder\nesri_url = 'http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Locators/ESRI_Geocode_USA/GeocodeServer'\nesri_geocoder = restapi.Geocoder(esri_url)\n\n# find candidates using key word arguments (**kwargs) to fill in locator fields, no single line option\ncandidates = esri_geocoder.findAddressCandidates(Address='380 New York Street', City='Redlands', State='CA', Zip='92373')\nprint('Number of address candidates: {}'.format(len(candidates)))\nfor candidate in candidates:\n    print(candidate.location)\n\n# export results to shapefile\nout_shp = os.path.join(folder, 'Esri_headquarters.shp')\ngeocoder.exportResults(candidates, out_shp)\n````\n\nGeoprocessing Services\n----------------------\n\n````py\n# test esri's drive time analysis GP Task\ngp_url = 'http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Network/ESRI_DriveTime_US/GPServer/CreateDriveTimePolygons'\ngp = restapi.GPTask(gp_url)\n\n# get a list of gp parameters (so we know what to pass in as kwargs)\nprint('\\nGP Task \"{}\" parameters:\\n'.format(gp.name)\nfor p in gp.parameters:\n    print('\\t', p.name, p.dataType)\n\npoint = {\"geometryType\":\"esriGeometryPoint\",\n         \"features\":[\n             {\"geometry\":{\"x\":-10603050.16225853,\"y\":4715351.1473399615,\n                          \"spatialReference\":{\"wkid\":102100,\"latestWkid\":3857}}}],\n         \"sr\":{\"wkid\":102100,\"latestWkid\":3857}}\n\n# run task, passing in gp parameters as keyword arguments (**kwargs)\ngp_res = gp.run(Input_Location=str(point), Drive_Times = '1 2 3', inSR = 102100)\n\n# returns a GPResult() object, can get at the first result by indexing (usually only one result)\n# can test if there are results by __nonzero__()\nif gp_res:\n    result = gp_res.results[0]\n    \n    # this returned a GPFeatureRecordSetLayer as an outputParameter, so we can export this to polygons\n    print('\\nOutput Result: \"{}\", data type: {}\\n'.format(result.paramName, result.dataType))\n\n    # now export the result value to fc (use the value property of the GPResult object from run())\n    drive_times = os.path.join(folder, 'drive_times.shp')\n    restapi.exportFeatureSet(drive_times, gp_res.value)\n````\n\nA note about input Geometries\n-----------------------------\n\nrestapi will try to use arcpy first if you have it, otherwise will defer to open source.  Both\nsupport the reading of shapefiles to return the first feature back as a restapi.Geometry object\n\nIt also supports arcpy Geometries and shapefile.Shape() objects\n````py\n>>> shp = r'C:\\TEMP\\Polygons.shp' # a shapefile on disk somewhere\n>>> geom = restapi.Geometry(shp)\n>>> print(geom.envelope())\n-121.5,38.3000000007,-121.199999999,38.6000000015\n````\n\nToken Based Security\n--------------------\n\nrestapi also supports secured services.  This is also session based, so if you sign in once to an\nArcGIS Server Resource (on the same ArcGIS Site), the token will automatically persist via the \nIdentityManager().\n\nThere are 3 ways to authticate:\n\n````py\n# **kwargs for all accessing all ArcGIS resources are\n# usr   -- username\n# pw    -- password\n# token -- token (as string or restapi.Token object)\n# proxy -- url to proxy\n\n# secured url\nsecured_url = 'http://some-domain.com/arcgis/rest/services'\n\n# 1. username and password\nags = restapi.ArcServer(url, 'username', 'password')  # token is generated and persists\n\n# 2. a token that has already been requested\nags = restapi.ArcServer(url, token=token)  # uses a token that is already active\n\n# 3. via a proxy (assuming using the standard esri proxy)\n#   this will forward all subsequent requests through the proxy\nags = restapi.ArcServer(url, proxy='http://some-domain.com/proxy.ashx')\n````\n\nYou can even just generate a token and let the IdentityManager handle the rest.  It is even smart enough to handle multiple tokens for different sites:\n\n```py\n# login to instance 1\nusr = 'username'\npw = 'password'\n\n# urls to two different ArcGIS Server sites\nurl_1 = 'http://some-domain.com/arcserver1/rest/services'\nurl_2 = 'http://domain2.com/arcgis/rest/services'\n\n# generate tokens\ntok1 = restapi.generate_token(url_1, usr, pw)\ntok2 = restapi.generate_token(url_2, usr, pw)\n\n# now we should be able to access both ArcGIS Server sites via the IdentityManager\narcserver1 = restapi.ArcServer(url_1) # tok1 is automatically passed in and handled\narcserver2 = restapi.ArcServer(url_2) # tok2 is used here\n```\n\nThe admin Subpackage\n--------------------\n\nrestapi also contains an administrative subpackage (warning: most functionality has not been tested!).  You can import this module like this:\n\n```py\nfrom restapi import admin\n```\n\n\n### Connecting to a Portal\n```py\nurl = 'https://domain.gis.com/portal/home'\nportal = restapi.admin.Portal(url, 'username', 'password')\n\n# get servers\nservers = portal.servers\n\n# stop sample cities service\nserver = servers[0]\n\nservice = server.service('SampleWorldCities.MapServer')\nservice.stop()\n\n```\n\nTo connect to an ArcGIS Server instance that you would like to administer you can do the following:\n\n```py\n# test with your own servers\nurl = 'localhost:6080/arcgis/admin/services' #server url\nusr = 'username'\npw = 'password'\n\n# connect to ArcGIS Server instance\narcserver = admin.ArcServerAdmin(url, usr, pw)\n```\n\nTo list services within a folder, you can do this:\n\n```py\nfolder = arcserver.folder('SomeFolder')  # supply name of folder as argument\nfor service in folder.iter_services():\n    print(service.serviceName, service.configuredState\n\n    # can stop a service like this\n    # service.stop()\n\n    # or start like this\n    # service.start()\n\nprint('\\n' * 3)\n\n# show all services and configured state (use iter_services to return restapi.admin.Service() object!)\nfor service in arcserver.iter_services():\n    print(service.serviceName, service.configuredState)\n```\nSecurity\n--------\n\nYou can set security at the folder or service level.  By default, the addPermssion() method used by Folder and Service objects will make the service unavailable to the general public and only those in the administrator role can view the services.  This is done by setting the 'esriEveryone' principal \"isAllowed\" value to false.  You can also assign permissions based on roles.\n\n```py\narcserver.addPermission('SomeFolder')  # by default it will make private True \n\n# now make it publically avaiable (unsecure)\narcserver.addPermission('SomeFolder', private=False)\n\n# secure based on role, in this case will not allow assessor group to see utility data\n#   assessor is name of assessor group role, Watermain is folder to secure\narcserver.addPermission('Watermain', 'assessor', False)  \n\n# note, this can also be done at the folder level:\nfolder = arcserver.folder('Watermain')\nfolder.addPermission('assessor', False)\n```\n\nStopping and Starting Services\n------------------------------\n\nServices can easily be started and stopped with this module.  This can be done from the ArcServerAdmin() or Folder() object:\n\n```py\n# stop all services in a folder\narcserver.stopServices(folderName='SomeFolder') # this can take a few minutes\n\n# look thru the folder to check the configured states, should be stopped\nfor service in arcserver.folder('SomeFolder').iter_services():\n    print(service.serviceName, service.configuredState)\n\n# now restart\narcserver.startServices(folderName='SomeFolder') # this can take a few minutes\n\n# look thru folder, services should be started\nfor service in arcserver.folder('SomeFolder').iter_services():\n    print(service.serviceName, service.configuredState)\n    \n# to do this from a folder, simply get a folder object back\nfolder = arcserver.folder('SomeFolder')\nfolder.stopServices()\nfor service in folder.iter_services():\n    print(service.serviceName, service.configuredState)\n```\n\nUpdating Service Properties\n---------------------------\n\nThe admin package can be used to update the service definitions via JSON.  By default, the Service.edit() method will pass in the original service definition as JSON so no changes are made if no arguments are supplied.  The first argument is the service config as JSON, but this method also supports keyword arguments to update single properties (**kwargs).  These represent keys of a the dictionary in Python.\n\n```py\n# connect to an individual service (by wildcard) - do not need to include full name, just\n# enough of the name to make it a unique name query\nservice = arcserver.service('SampleWorldCities') #provide name of service here\n\n# get original service description\ndescription = service.description\n\n# now edit the description only by using description kwarg (must match key exactly to update)\nservice.edit(description='This is an updated service description')\n\n# edit description again to set it back to the original description\nservice.edit(description=description)\n```\n\nThere are also some helper methods that aren't available out of the box from the ArcGIS REST API such as enabling or disabling extensions:\n\n```py\n# disable Feature Access and kml downloads\nservice.disableExtensions(['FeatureServer', 'KmlServer'])\n\n# you can also list enabled/disabled services\nprint(service.enabledExtensions)\n# [u'KmlServer', u'WFSServer', u'FeatureServer']\n\nservice.disabledExtensions\n# [u'NAServer', u'MobileServer', u'SchematicsServer', u'WCSServer', u'WMSServer']\n\n# Edit service extension properites\n# get an extension and view its properties\nfs_extension = service.getExtension('FeatureServer')\n\nprint(fs_extension) # will print as pretty json\n```\n\nFor Service objects, all properties are represented as pretty json.  Below is what the FeatureService Extension looks like:\n\n```py\n{\n  \"allowedUploadFileTypes\": \"\", \n  \"capabilities\": \"Query,Create,Update,Delete,Uploads,Editing\", \n  \"enabled\": \"true\", \n  \"maxUploadFileSize\": 0, \n  \"properties\": {\n    \"allowGeometryUpdates\": \"true\", \n    \"allowOthersToDelete\": \"false\", \n    \"allowOthersToQuery\": \"true\", \n    \"allowOthersToUpdate\": \"false\", \n    \"allowTrueCurvesUpdates\": \"false\", \n    \"creatorPresent\": \"false\", \n    \"dataInGdb\": \"true\", \n    \"datasetInspected\": \"true\", \n    \"editorTrackingRespectsDayLightSavingTime\": \"false\", \n    \"editorTrackingTimeInUTC\": \"true\", \n    \"editorTrackingTimeZoneID\": \"UTC\", \n    \"enableOwnershipBasedAccessControl\": \"false\", \n    \"enableZDefaults\": \"false\", \n    \"maxRecordCount\": \"1000\", \n    \"realm\": \"\", \n    \"syncEnabled\": \"false\", \n    \"syncVersionCreationRule\": \"versionPerDownloadedMap\", \n    \"versionedData\": \"false\", \n    \"xssPreventionEnabled\": \"true\", \n    \"zDefaultValue\": \"0\"\n  }, \n  \"typeName\": \"FeatureServer\"\n}\n```\n\nSetting properties for extensions is also easy:\n\n```py\n# set properties for an extension using helper method, use **kwargs for setting capabilities\nservice.setExtensionProperties('FeatureServer', capabilities='Query,Update,Delete,Editing')\n\n# verify changes were made\nprint(fs_extension.capabilities\n# 'Query,Update,Delete,Editing'\n\n# alternatively, you can edit the service json directly and call the edit method\n# change it back to original settings\nfs_extension.capabilities = 'Query,Create,Update,Delete,Uploads,Editing'\nservice.edit()\n\n# verify one more time...\nprint(fs_extension.capabilities)\n# 'Query,Create,Update,Delete,Uploads,Editing'\n```\n\nAccess the Data Store\n---------------------\n\nYou can iterate through the data store items easily to read/update/add items:\n\n```py\n# connect to the server's data store\nds = arcserver.dataStore\n\n# iterate through all items of data store\nfor item in ds:\n    print(item.type, item.path\n    # if it is an enterprise database connection, you can get the connection string like this\n    if item.type == 'egdb':\n        print(item.info.connectionString)\n    # else if a folder, print(server path\n    elif item.type == 'folder':\n        print(item.info.path)\n    print('\\n')\n```\n\nUser and Role Stores\n--------------------\n\nWhen viewing usernames/roles you can limit the number of names returned using the \"maxCount\" keyword argument.  To view and make changes to Role Store:\n\n```py\n# connect to role store\nrs = arcserver.roleStore\n\n# print roles\nfor role in rs:\n    print(role)\n\n# find users within roles\nfor role in rs:\n    print(role, 'Users: ', rs.getUsersWithinRole(role))\n\n# add a user to role\nrs.addUsersToRole('Administrators', 'your-domain\\\\someuser')\n\n# remove user from role\nrs.removeUsersFromRole('Administrators', 'your-domain\\\\someuser')\n\n# remove an entire role\nrs.removeRole('transportation')\n```\n\nTo view and make changes to the User Store:\n\n```py\n# connect to user store\nus = arcserver.userStore\n\n# get number of users\nprint(len(us)\n\n# iterate through first 10 users\nfor user in us.searchUsers(maxCount=10):\n    print(user)\n    \n# add new user\nus.addUser('your-domain\\\\someuser', 'password')\n\n# assign roles by using comma separated list of role names\nus.assignRoles('your-domain\\\\someuser', 'Administrators,Publishers')\n\n# get privileges from user\nus.getPrivilegeForUser('your-domain\\\\someuser')\n\n# remove roles from user \nus.removeRoles('your-domain\\\\someuser', 'Administrators,Publishers')\n```\n\nLog Files\n---------\n\nYou can easily query server log files like this:\n\n```py\nimport restapi\nimport datetime\n\n# query log files (within last 3 days), need to convert to milliseconds\nthreeDaysAgo = restapi.date_to_mil(datetime.datetime.now() - relativedelta(days=3))\nfor log in arcserver.queryLogs(endTime=threeDaysAgo, pageSize=25):\n    print(log.time\n    for message in log:\n        print(message)\n    print('\\n')\n```\n\nA note about verbosity\n----------------------\n\nWhen using the admin subpackage you will likely be making changes to services/permissions etc.  On operations that change a configuration, the @passthrough decorator will report back if the operation is successful and return results like this:\n\n```py\n{u'status': u'SUCCESS'}\n```\n\nThe printing of these messages can be shut off by changing the global \"VERBOSE\" variable so these messages are not reported.  This can be disabled like this:\n\n```py\nadmin.VERBOSE = False \n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Bolton-and-Menk-GIS/restapi", "keywords": "", "license": "GPL", "maintainer": "", "maintainer_email": "", "name": "bmi-arcgis-restapi", "package_url": "https://pypi.org/project/bmi-arcgis-restapi/", "platform": "", "project_url": "https://pypi.org/project/bmi-arcgis-restapi/", "project_urls": {"Homepage": "https://github.com/Bolton-and-Menk-GIS/restapi"}, "release_url": "https://pypi.org/project/bmi-arcgis-restapi/1.0.4/", "requires_dist": null, "requires_python": "", "summary": "Package for working with ArcGIS REST API", "version": "1.0.4"}, "last_serial": 6750186, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "2a2344ca5dfdd5c5d7178753266f8cfc", "sha256": "5f1cafd2d0f3352bb4df16ae1a189cd8eb0bac7f40e6099ece9e7f8cfd8ece29"}, "downloads": -1, "filename": "bmi-arcgis-restapi-1.0.tar.gz", "has_sig": false, "md5_digest": "2a2344ca5dfdd5c5d7178753266f8cfc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 472518, "upload_time": "2019-10-29T17:18:46", "upload_time_iso_8601": "2019-10-29T17:18:46.580862Z", "url": "https://files.pythonhosted.org/packages/ca/c4/ff5698e57c5b8c7d23d6bf97d014af73f135f627fb2401c9efbc40b7a1b4/bmi-arcgis-restapi-1.0.tar.gz"}], "1.0.2": [{"comment_text": "", "digests": {"md5": "0dde14fc817982d8254780a7d99aa23b", "sha256": "0a912590158c1e6ce17e3983bc1abcb22d8c8224b5fa5ceb60b3aa2e8e50ec30"}, "downloads": -1, "filename": "bmi-arcgis-restapi-1.0.2.tar.gz", "has_sig": false, "md5_digest": "0dde14fc817982d8254780a7d99aa23b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 472955, "upload_time": "2019-12-06T21:52:52", "upload_time_iso_8601": "2019-12-06T21:52:52.495301Z", "url": "https://files.pythonhosted.org/packages/29/89/d1bb161a032acc83f0fe38bbf9db553562836555deabf00c15d7812f003c/bmi-arcgis-restapi-1.0.2.tar.gz"}], "1.0.3": [{"comment_text": "", "digests": {"md5": "a2357c237a130389ee8aa8f175dbadde", "sha256": "9a4651ae5ff518f6863372472490904d0633b8087b96ed072971ff1d64e8667e"}, "downloads": -1, "filename": "bmi-arcgis-restapi-1.0.3.tar.gz", "has_sig": false, "md5_digest": "a2357c237a130389ee8aa8f175dbadde", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 472975, "upload_time": "2020-01-06T19:00:33", "upload_time_iso_8601": "2020-01-06T19:00:33.897451Z", "url": "https://files.pythonhosted.org/packages/a7/21/8bb8eea7557761b1870db3a0838db624a00da5c9c8709a6991edc77f8bd9/bmi-arcgis-restapi-1.0.3.tar.gz"}], "1.0.4": [{"comment_text": "", "digests": {"md5": "ba2ae50775c633e30563d86591bbe4b9", "sha256": "52fd6d3c2bbdedf5d11df2ebdeef53c116ac26188248c2ad3033ad166d248614"}, "downloads": -1, "filename": "bmi-arcgis-restapi-1.0.4.tar.gz", "has_sig": false, "md5_digest": "ba2ae50775c633e30563d86591bbe4b9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 473944, "upload_time": "2020-03-04T20:09:07", "upload_time_iso_8601": "2020-03-04T20:09:07.995062Z", "url": "https://files.pythonhosted.org/packages/72/b1/e5fcd6d3b70a36a8e91259f5a828e39dfc650d8128850e6433a1320e1876/bmi-arcgis-restapi-1.0.4.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "ba2ae50775c633e30563d86591bbe4b9", "sha256": "52fd6d3c2bbdedf5d11df2ebdeef53c116ac26188248c2ad3033ad166d248614"}, "downloads": -1, "filename": "bmi-arcgis-restapi-1.0.4.tar.gz", "has_sig": false, "md5_digest": "ba2ae50775c633e30563d86591bbe4b9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 473944, "upload_time": "2020-03-04T20:09:07", "upload_time_iso_8601": "2020-03-04T20:09:07.995062Z", "url": "https://files.pythonhosted.org/packages/72/b1/e5fcd6d3b70a36a8e91259f5a828e39dfc650d8128850e6433a1320e1876/bmi-arcgis-restapi-1.0.4.tar.gz"}]}
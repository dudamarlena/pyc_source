{"info": {"author": "Xia Wu", "author_email": "xiawu@zeuux.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6"], "description": "NewChain Keys\n=============\n\nA common API for NewChain key operations with pluggable backends.\n\n    This library and repository is original forked from\n    https://github.com/ethereum/eth-keys.\n\nInstallation\n------------\n\n.. code:: sh\n\n    pip install newchain-keys\n\nDevelopment\n-----------\n\n.. code:: sh\n\n    pip install -e .[dev]\n\nRunning the tests\n~~~~~~~~~~~~~~~~~\n\nYou can run the tests with:\n\n.. code:: sh\n\n    py.test tests\n\nOr you can install ``tox`` to run the full test suite.\n\nReleasing\n~~~~~~~~~\n\nPandoc is required for transforming the markdown README to the proper\nformat to render correctly on pypi.\n\nFor Debian-like systems:\n\n::\n\n    apt install pandoc\n\nOr on OSX:\n\n.. code:: sh\n\n    brew install pandoc\n\nTo release a new version:\n\n.. code:: sh\n\n    make release bump=$$VERSION_PART_TO_BUMP$$\n\nHow to bumpversion\n^^^^^^^^^^^^^^^^^^\n\nThe version format for this repo is ``{major}.{minor}.{patch}`` for\nstable, and ``{major}.{minor}.{patch}-{stage}.{devnum}`` for unstable\n(``stage`` can be alpha or beta).\n\nTo issue the next version in line, specify which part to bump, like\n``make release bump=minor`` or ``make release bump=devnum``.\n\nIf you are in a beta version, ``make release bump=stage`` will switch to\na stable.\n\nTo issue an unstable version when the current version is stable, specify\nthe new version explicitly, like\n``make release bump=\"--new-version 2.0.0-alpha.1 devnum\"``\n\nQuickStart\n----------\n\n.. code:: python\n\n    >>> from newchain_keys import keys\n    >>> pk = keys.PrivateKey(b'\\x01' * 32)\n    >>> signature = pk.sign_msg(b'a message')\n    >>> pk\n    '0x0101010101010101010101010101010101010101010101010101010101010101'\n    >>> pk.public_key\n    '0x6ff03b949241ce1dadd43519e6960e0a85b41a69a05c328103aa2bce1594ca163c4f753a55bf01dc53f6c0b0c7eee78b40c6ff7d25a96e2282b989cef71c144a'\n    >>> signature\n    '0xf5a024b434c72877e7cd4c1f086896477babb10153ef2a787c9276763e6dad1d17d5dcc2a5a611d77e22b06832d84ba6560b0ae36013710156715ea92244fd8901'\n    >>> pk.public_key.to_checksum_address()\n    '0xa0E0162b1a12Ed06d63DD1BF0CD5b0d1e6614B3c'\n    >>> signature.verify_msg(b'a message', pk.public_key)\n    True\n    >>> signature.recover_public_key_from_msg(b'a message') == pk.public_key\n    True\n\nDocumentation\n-------------\n\n``KeyAPI(backend=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``KeyAPI`` object is the primary API for interacting with the\n``newchain-keys`` libary. The object takes a single optional argument in\nits constructor which designates what backend will be used for eliptical\ncurve cryptography operations. The built-in backends are:\n\n-  ``newchain_keys.backends.NativeECCBackend``: A pure python\n   implementation of the ECC operations.\n\nBy default, ``newchain-keys`` will *try* to use the\n``NativeECCBackend``.\n\nThe ``backend`` argument can be given in any of the following forms.\n\n-  Instance of the backend class\n-  The backend class\n-  String with the dot-separated import path for the backend class.\n\n.. code:: python\n\n    >>> from newchain_keys import KeyAPI\n    >>> from newchain_keys.backends import NativeECCBackend\n    # These are all the same\n    >>> keys = KeyAPI(NativeECCBackend)\n    >>> keys = KeyAPI(NativeECCBackend())\n    >>> keys = KeyAPI('newchain_keys.backends.NativeECCBackend')\n\nThe backend can also be configured using the environment variable\n``ECC_BACKEND_CLASS`` which should be set to the dot-separated python\nimport path to the desired backend.\n\n``KeyAPI.ecdsa_sign(message_hash, private_key) -> Signature``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis method returns a signature for the given ``message_hash``, signed\nby the provided ``private_key``.\n\n-  ``message_hash``: **must** be a byte string of length 32\n-  ``private_key``: **must** be an instance of ``PrivateKey``\n\n``KeyAPI.ecdsa_verify(message_hash, signature, public_key) -> bool``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nReturns ``True`` or ``False`` based on whether the provided\n``signature`` is a valid signature for the provided ``message_hash`` and\n``public_key``.\n\n-  ``message_hash``: **must** be a byte string of length 32\n-  ``signature``: **must** be an instance of ``Signature``\n-  ``public_key``: **must** be an instance of ``PublicKey``\n\n``KeyAPI.ecdsa_recover(message_hash, signature) -> PublicKey``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nReturns the ``PublicKey`` instances recovered from the given\n``signature`` and ``message_hash``.\n\n-  ``message_hash``: **must** be a byte string of length 32\n-  ``signature``: **must** be an instance of ``Signature``\n\n``KeyAPI.private_key_to_public_key(private_key) -> PublicKey``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nReturns the ``PublicKey`` instances computed from the given\n``private_key`` instance.\n\n-  ``private_key``: **must** be an instance of ``PublicKey``\n\nCommon APIs for ``PublicKey``, ``PrivateKey`` and ``Signature``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThere is a common API for the following objects.\n\n-  ``PublicKey``\n-  ``PrivateKey``\n-  ``Signature``\n\nEach of these objects has all of the following APIs.\n\n-  ``obj.to_bytes()``: Returns the object in it\u2019s canonical ``bytes``\n   serialization.\n-  ``obj.to_hex()``: Returns a text string of the hex encoded canonical\n   representation.\n\n``KeyAPI.PublicKey(public_key_bytes)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``PublicKey`` class takes a single argument which must be a bytes\nstring with length 64.\n\n    Note that some libraries prefix the byte serialized public key with\n    a leading ``\\x04`` byte which must be removed before use with the\n    ``PublicKey`` object.\n\nThe following methods are available:\n\n``PublicKey.from_private(private_key) -> PublicKey``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis ``classmethod`` returns a new ``PublicKey`` instance computed from\nthe given ``private_key``.\n\n-  ``private_key`` may either be a byte string of length 32 or an\n   instance of the ``KeyAPI.PrivateKey`` class.\n\n``PublicKey.recover_from_msg(message, signature) -> PublicKey``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis ``classmethod`` returns a new ``PublicKey`` instance computed from\nthe provided ``message`` and ``signature``.\n\n-  ``message`` **must** be a byte string\n-  ``signature`` **must** be an instance of ``KeyAPI.Signature``\n\n``PublicKey.recover_from_msg_hash(message_hash, signature) -> PublicKey``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSame as ``PublicKey.recover_from_msg`` except that ``message_hash``\nshould be the Keccak hash of the ``message``.\n\n``PublicKey.verify_msg(message, signature) -> bool``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis method returns ``True`` or ``False`` based on whether the signature\nis a valid for the given message.\n\n``PublicKey.verify_msg_hash(message_hash, signature) -> bool``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSame as ``PublicKey.verify_msg`` except that ``message_hash`` should be\nthe Keccak hash of the ``message``.\n\n``PublicKey.to_address() -> text``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns the hex encoded ethereum address for this public key.\n\n``PublicKey.to_checksum_address() -> text``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns the ERC55 checksum formatted ethereum address for this public\nkey.\n\n``PublicKey.to_canonical_address() -> bytes``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns the 20-byte representation of the ethereum address for this\npublic key.\n\n``KeyAPI.PrivateKey(private_key_bytes)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``PrivateKey`` class takes a single argument which must be a bytes\nstring with length 32.\n\nThe following methods and properties are available\n\n``PrivateKey.public_key``\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis *property* holds the ``PublicKey`` instance coresponding to this\nprivate key.\n\n``PrivateKey.sign_msg(message) -> Signature``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis method returns a signature for the given ``message`` in the form of\na ``Signature`` instance\n\n-  ``message`` **must** be a byte string.\n\n``PrivateKey.sign_msg_hash(message_hash) -> Signature``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSame as ``PrivateKey.sign`` except that ``message_hash`` should be the\nKeccak hash of the ``message``.\n\n``KeyAPI.Signature(signature_bytes=None, vrs=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``Signature`` class can be instantiated in one of two ways.\n\n-  ``signature_bytes``: a bytes string with length 65.\n-  ``vrs``: a 3-tuple composed of the integers ``v``, ``r``, and ``s``.\n\n    Note: If using the ``signature_bytes`` to instantiate, the byte\n    string should be encoded as ``r_bytes | s_bytes | v_bytes`` where\n    ``|`` represents concatenation. ``r_bytes`` and ``s_bytes`` should\n    be 32 bytes in length. ``v_bytes`` should be a single byte ``\\x00``\n    or ``\\x01``.\n\nSignatures are expected to use ``1`` or ``0`` for their ``v`` value.\n\nThe following methods and properties are available\n\n``Signature.v``\n^^^^^^^^^^^^^^^\n\nThis property returns the ``v`` value from the signature as an integer.\n\n``Signature.r``\n^^^^^^^^^^^^^^^\n\nThis property returns the ``r`` value from the signature as an integer.\n\n``Signature.s``\n^^^^^^^^^^^^^^^\n\nThis property returns the ``s`` value from the signature as an integer.\n\n``Signature.vrs``\n^^^^^^^^^^^^^^^^^\n\nThis property returns a 3-tuple of ``(v, r, s)``.\n\n``Signature.verify_msg(message, public_key) -> bool``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis method returns ``True`` or ``False`` based on whether the signature\nis a valid for the given public key.\n\n-  ``message``: **must** be a byte string.\n-  ``public_key``: **must** be an instance of ``PublicKey``\n\n``Signature.verify_msg_hash(message_hash, public_key) -> bool``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSame as ``Signature.verify_msg`` except that ``message_hash`` should be\nthe Keccak hash of the ``message``.\n\n``Signature.recover_public_key_from_msg(message) -> PublicKey``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis method returns a ``PublicKey`` instance recovered from the\nsignature.\n\n-  ``message``: **must** be a byte string.\n\n``Signature.recover_public_key_from_msg_hash(message_hash) -> PublicKey``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSame as ``Signature.recover_public_key_from_msg`` except that\n``message_hash`` should be the Keccak hash of the ``message``.\n\nExceptions\n~~~~~~~~~~\n\n``eth_api.exceptions.ValidationError``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis error is raised during instantaition of any of the ``PublicKey``,\n``PrivateKey`` or ``Signature`` classes if their constructor parameters\nare invalid.\n\n``eth_api.exceptions.BadSignature``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis error is raised from any of the ``recover`` or ``verify`` methods\ninvolving signatures if the signature is invalid.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/xiawu/newchain-keys-py", "keywords": "newchain", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "newchain-keys", "package_url": "https://pypi.org/project/newchain-keys/", "platform": "", "project_url": "https://pypi.org/project/newchain-keys/", "project_urls": {"Homepage": "https://github.com/xiawu/newchain-keys-py"}, "release_url": "https://pypi.org/project/newchain-keys/0.1.0/", "requires_dist": ["eth-utils (<2.0.0,>=1.3.0)", "tox (==2.7.0) ; extra == 'dev'", "bumpversion (==0.5.3) ; extra == 'dev'", "twine ; extra == 'dev'", "eth-utils (<2.0.0,>=1.3.0) ; extra == 'dev'", "flake8 (==3.0.4) ; extra == 'dev'", "mypy (<0.600) ; extra == 'dev'", "pytest (==3.2.2) ; extra == 'dev'", "hypothesis (==3.30.0) ; extra == 'dev'", "eth-hash[pysha3] ; (implementation_name == \"cpython\") and extra == 'dev'", "eth-hash[pycryptodome] ; (implementation_name == \"pypy\") and extra == 'dev'", "flake8 (==3.0.4) ; extra == 'lint'", "mypy (<0.600) ; extra == 'lint'", "eth-utils (<2.0.0,>=1.3.0) ; extra == 'newchain-keys'", "pytest (==3.2.2) ; extra == 'test'", "hypothesis (==3.30.0) ; extra == 'test'", "eth-hash[pysha3] ; (implementation_name == \"cpython\") and extra == 'test'", "eth-hash[pycryptodome] ; (implementation_name == \"pypy\") and extra == 'test'"], "requires_python": "", "summary": "Common API for NewChain key operations.", "version": "0.1.0"}, "last_serial": 4917985, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "4bb70b402becb2f71285c4ec015aad9a", "sha256": "0d67f109188738f768a1470cc3a01772041b35b144a48ec4b74e655022b8080f"}, "downloads": -1, "filename": "newchain_keys-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "4bb70b402becb2f71285c4ec015aad9a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17625, "upload_time": "2019-03-09T04:30:25", "upload_time_iso_8601": "2019-03-09T04:30:25.592818Z", "url": "https://files.pythonhosted.org/packages/ca/e7/02860287dba0c66f7d99992bae8d1cfa47bd1a535c5d543a295a5f39519b/newchain_keys-0.1.0-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "43e6ecb9353c3a17b0322548f70e435d", "sha256": "eac25aa97db102d68a46d27264a6d407fb0d40821a21ba97bbf3ca9ffe7330ff"}, "downloads": -1, "filename": "newchain-keys-0.1.0.tar.gz", "has_sig": false, "md5_digest": "43e6ecb9353c3a17b0322548f70e435d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15748, "upload_time": "2019-03-09T04:30:27", "upload_time_iso_8601": "2019-03-09T04:30:27.979622Z", "url": "https://files.pythonhosted.org/packages/6d/76/13746cae28cfe9143e038766b70dd6b93f20d95bdfb42883f293a778cbf1/newchain-keys-0.1.0.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "4bb70b402becb2f71285c4ec015aad9a", "sha256": "0d67f109188738f768a1470cc3a01772041b35b144a48ec4b74e655022b8080f"}, "downloads": -1, "filename": "newchain_keys-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "4bb70b402becb2f71285c4ec015aad9a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17625, "upload_time": "2019-03-09T04:30:25", "upload_time_iso_8601": "2019-03-09T04:30:25.592818Z", "url": "https://files.pythonhosted.org/packages/ca/e7/02860287dba0c66f7d99992bae8d1cfa47bd1a535c5d543a295a5f39519b/newchain_keys-0.1.0-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "43e6ecb9353c3a17b0322548f70e435d", "sha256": "eac25aa97db102d68a46d27264a6d407fb0d40821a21ba97bbf3ca9ffe7330ff"}, "downloads": -1, "filename": "newchain-keys-0.1.0.tar.gz", "has_sig": false, "md5_digest": "43e6ecb9353c3a17b0322548f70e435d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15748, "upload_time": "2019-03-09T04:30:27", "upload_time_iso_8601": "2019-03-09T04:30:27.979622Z", "url": "https://files.pythonhosted.org/packages/6d/76/13746cae28cfe9143e038766b70dd6b93f20d95bdfb42883f293a778cbf1/newchain-keys-0.1.0.tar.gz"}]}
{"info": {"author": "Luiza Labs", "author_email": "pypi@luizalabs.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Lasier\nA sync/async circuit breaker implementation\n\n[![Build Status](https://travis-ci.org/luizalabs/lasier.svg?branch=master)](https://travis-ci.org/luizalabs/lasier)\n\nAccording to Nygard on your masterpiece book [Release It!](http://pragprog.com/titles/mnee/release-it):\n\n> [...] circuit breakers protect overeager gadget hounds from burning their houses down. The principle is the same: detect excess usage, fail first, and open the circuit. More abstractly, the circuit breaker exists to allow one subsystem (an electrical circuit) to fail (excessive current draw, possibly from a short circuit) without destroying the entire system (the house). Furthermore, once the danger has passed, the circuit breaker can be reset to restore full function to the system.\n\n## Requirements\n* Python >= 3.7\n\n## Instalation (WIP)\nUsing `pip`:\n\n```\npip install lasier\n```\n\n## Usage\nTo use lasier circuit breaker you'll need a `rule` and a `cache` (the circuit state storage) instance\n\n### Rule\nA `Rule` is the mechanism that define where circuit will open or close.\n\n#### MaxFailuresRule\nRule to open circuit based on maximum number of failures\n\n```python\nfrom lasier.circuit_breaker.rules import MaxFailuresRule\n\nrule = MaxFailuresRule(\n    max_failures=500,\n    failure_cache_key='my_cb'\n)\n```\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| max\\_failures | Maximum number of errors |\n| failure\\_cache\\_key | Cache key where the number of errors is incremented |\n\n#### PercentageFailuresRule\nRule to open circuit based on a percentage of failures\n\n```python\nfrom lasier.circuit_breaker.rules import PercentageFailuresRule\n\nrule = PercentageFailuresRule(\n    max_failures_percentage=60,\n    failure_cache_key='my_cb',\n    min_accepted_requests=100,\n    request_cache_key='my_cb_request'\n)\n```\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| max\\_failures\\_percentage | Maximum percentage of errors |\n| failure\\_cache\\_key | Cache key where the number of errors is incremented |\n| min\\_accepted\\_requests | Minimum number of requests accepted to not open circuit breaker |\n| request\\_cache\\_key | Cache key where the number of requests is incremented |\n\n### Circuit Breaker\nYou can use the Lasier circuit breaker with a *context\\_manager* f.ex:\n\n```python\nfrom lasier.circuit_breaker.sync import CircuitBreaker\n\n...\n\ndef some_protected_func():\n    with CircuitBreaker(\n        rule=rule,\n        cache=cache,\n        failure_exception=ValueError,\n        catch_exceptions=(KeyError, TypeError)\n    ):\n        # some process\n```\nOr a _decorator_, f.ex:\n\n```python\nfrom lasier.circuit_breaker.asyncio import circuit_breaker\n\n...\n\n@circuit_breaker(\n    rule=rule,\n    cache=cache,\n    failure_exception=ValueError,\n    catch_exceptions=(KeyError, TypeError)\n)\nasync def some_protected_func():\n    # some process\n```\n\nThe **sync** and **async** implementations follow the same interface, so you only need to change the import path:\n\n* `lasier.circuit_breaker.sync`: for sync implementataion\n* `lasier.circuit_breaker.asyncio`: for async implementataion\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| rule | Instance of class [rule](https://github.com/luizalabs/lasier#rule). |\n| cache | Instance of the circuit breaker [state storage](https://github.com/luizalabs/lasier#circuit-state-storage). |\n| failure\\_exception | Exception to be raised when it exceeds the maximum number of errors and when the circuit is open. |\n| failure\\_timeout | This value is set on first error. It is used to validate the number of errors by time. |\n| circuit\\_timeout | Time that the circuit will be open. |\n| catch\\_exceptions | List of exceptions catched to increase the number of errors. |\n\n## Circuit state storage\nLasier works with a storage to register the current state of the circuit, number of failures, etc. That storage respects the follow interface:\n\n```python\nclass Storage:\n\n    def add(self, key=str, value=int, timeout=Optional[int]):\n        pass\n\n    def set(self, key=str, value=int, timeout=Optional[int]):\n        pass\n\n    def incr(self, key=str):\n        pass\n\n    def get(self, key=str) -> int:\n        pass\n\n    def delete(self, key=str):\n        pass\n\n    def flushdb(self):\n        pass\n```\n\n> For `async` circuit breaker, lasier works with that same interface however with async syntax, f.ex: `async def set(self, key=str, value=int, timeout=Optional[int])`\n\nSo you can use any cache/storage that respects that interface, f.ex the [django caches object](https://docs.djangoproject.com/en/3.0/topics/cache/)\n\n### Adapters\nIf you'll use Lasier with [redis-py](https://github.com/andymccurdy/redis-py) as cache, you can use `lasier.adapters.caches.redis.RedisAdapter`\n\n```python\nfrom lasier.adapters.cache import RedisAdapter\nfrom redis import Redis\n\ncache = RedisAdapter(Redis(host='localhost', port=6479, db=0))\n```\n\n#### Implemented Adapters\n| Lib | Adapter |\n| --- | --- |\n| redis-py | `lasier.adapters.caches.RedisAdapter`|\n| aiocache | `lasier.adapters.caches.AiocacheAdapter`|\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/luizalabs/lasier/tarball/master", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/luizalabs/lasier", "keywords": "circuit breaker sync async", "license": "", "maintainer": "", "maintainer_email": "", "name": "lasier", "package_url": "https://pypi.org/project/lasier/", "platform": "", "project_url": "https://pypi.org/project/lasier/", "project_urls": {"Download": "https://github.com/luizalabs/lasier/tarball/master", "Homepage": "https://github.com/luizalabs/lasier"}, "release_url": "https://pypi.org/project/lasier/0.0.1/", "requires_dist": null, "requires_python": "", "summary": "A sync/async circuit breaker implementation", "version": "0.0.1"}, "last_serial": 6978331, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "9228a1421513c788985fab308f917a45", "sha256": "6c74b79d8f6389014add4c5a44e1aa0e8c57a6543c9b8fb5515923e98fbe64bd"}, "downloads": -1, "filename": "lasier-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "9228a1421513c788985fab308f917a45", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9220, "upload_time": "2020-04-08T14:54:27", "upload_time_iso_8601": "2020-04-08T14:54:27.869244Z", "url": "https://files.pythonhosted.org/packages/50/db/6c816680e8af0eb0551749fc3e19e3291f0cdb74af6aff5ee9ce475163e2/lasier-0.0.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "c67adbd1a6bd99a60b36e5de4f36690c", "sha256": "16e72a04d8d1e32725406a7d6b697874383c2d34a3dd7827ee3ad4fd36040e85"}, "downloads": -1, "filename": "lasier-0.0.1.tar.gz", "has_sig": false, "md5_digest": "c67adbd1a6bd99a60b36e5de4f36690c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7651, "upload_time": "2020-04-08T14:54:30", "upload_time_iso_8601": "2020-04-08T14:54:30.281176Z", "url": "https://files.pythonhosted.org/packages/f0/ec/8356703c53bde8ac02f628fc0af6d98e30aa433f050eb56081d13b679f3f/lasier-0.0.1.tar.gz"}]}, "urls": [{"comment_text": "", "digests": {"md5": "9228a1421513c788985fab308f917a45", "sha256": "6c74b79d8f6389014add4c5a44e1aa0e8c57a6543c9b8fb5515923e98fbe64bd"}, "downloads": -1, "filename": "lasier-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "9228a1421513c788985fab308f917a45", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9220, "upload_time": "2020-04-08T14:54:27", "upload_time_iso_8601": "2020-04-08T14:54:27.869244Z", "url": "https://files.pythonhosted.org/packages/50/db/6c816680e8af0eb0551749fc3e19e3291f0cdb74af6aff5ee9ce475163e2/lasier-0.0.1-py3-none-any.whl"}, {"comment_text": "", "digests": {"md5": "c67adbd1a6bd99a60b36e5de4f36690c", "sha256": "16e72a04d8d1e32725406a7d6b697874383c2d34a3dd7827ee3ad4fd36040e85"}, "downloads": -1, "filename": "lasier-0.0.1.tar.gz", "has_sig": false, "md5_digest": "c67adbd1a6bd99a60b36e5de4f36690c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7651, "upload_time": "2020-04-08T14:54:30", "upload_time_iso_8601": "2020-04-08T14:54:30.281176Z", "url": "https://files.pythonhosted.org/packages/f0/ec/8356703c53bde8ac02f628fc0af6d98e30aa433f050eb56081d13b679f3f/lasier-0.0.1.tar.gz"}]}